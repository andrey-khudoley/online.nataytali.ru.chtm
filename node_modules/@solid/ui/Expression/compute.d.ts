import { Condition, Expression, Expressions } from './types';
export declare function computeExpression(expression: Expression, values: Record<string, unknown>): boolean;
export declare function computeExpressions(expressions: Expressions, values: Record<string, unknown>): boolean;
export declare function computeCondition(condition: Condition, values: Record<string, unknown>): boolean;
export declare function computeConditionString(condition: Condition<'string'>, values: Record<string, unknown>): boolean;
export declare function computeConditionNumber(condition: Condition<'number'>, values: Record<string, unknown>): boolean;
export declare function computeConditionBoolean(condition: Condition<'boolean'>, values: Record<string, unknown>): boolean;
export declare function computeConditionDate(condition: Condition<'date'>, values: Record<string, unknown>): boolean;
export declare function computeConditionRefbook(condition: Condition<'refbook'>, values: Record<string, unknown>): boolean;
/**
 * Returns an unique array of all condition keys in the expression.
 *
 * Recursively traverses the expression tree and returns an array of all
 * condition keys.
 *
 * @param expression The expression to traverse.
 * @returns An array of condition keys.
 */
export declare function getExpressionConditionsKeys(expression: Expression): string[];
/**
 * Recursively flattens an object into a single level.
 *
 * Given an object with nested objects, returns a new object with all nested
 * objects flattened into a single level.
 *
 * @param obj The object to flatten.
 * @returns A new object with all nested objects flattened.
 */
export declare function flattenObject(obj: Record<string, unknown>): Record<string, unknown>;
export declare function expressionToWhere(expression: Expression): any;
