/// <reference types="node" />

import * as tb from '@sinclair/typebox'
import { Filter, FindAllOptions, OrderByDefinition, SortDirection } from 'core/db/dbQueryTypes'
import {
  HeapId,
  HeapObjectBaseRaw,
  HeapObjectType,
  HeapOrderBy,
  HeapRecord,
  HeapRecordFilter,
  HeapRecordSearchByOptions,
  HeapRecordSelectOptions,
} from 'core/heap/heapTypes'
import * as hs from 'core/heap/v2/heapSchemaTypes'
import { HeapLinkInfo, OptionalHeapTableInfo } from 'core/heap/v2/HeapTableRecordApi'
import { ReadOnlyHeapTableRepo } from 'core/heap/v2/HeapTableRepo'
import { ChatMessage, ChatiumActions } from 'lib/chatium-json'
import { Icon, StatusIcon } from 'lib/chatium-json/v1'
import { DesktopLayout, IconProps, PlainIconName } from 'lib/chatium-json/v2'
import { AnyObject, JSONInputObject, JSONObject, JSONValue, PublicFieldsOfClass } from 'utils/types'

interface CqlSelectQuery {
  from: CqlFrom
  select: CqlSelect
  distinct?: boolean
  where?: CqlWhere
  having?: CqlHaving
  order?: CqlOrder
  group?: CqlGroup
  limit?: number
  offset?: number
}
declare type CqlFrom = CqlTable | CqlSubQuery
declare type CqlTable = {
  kind: 'table'
  schema: string
  name: string
}
declare type CqlSubQuery = {
  kind: 'sub'
  query: CqlSelectQuery
}
declare type CqlSelect = Record<string, CqlExpr> | undefined
declare type CqlExpr = CqlPlainColumn | CqlExprFn | CqlDynParam | CqlJsonPath | CqlAsterisk
declare type CqlPlainColumn = {
  kind: 'col'
  name: string
  type?: CqlFieldType
}
declare type CqlExprFn = {
  kind: 'fn'
  fn: string
  args: CqlExpr[]
  distinct?: boolean
  type?: CqlFieldType
}
declare type CqlDynParam = {
  kind: 'dyn'
  value: unknown
  type?: CqlFieldType
}
declare type CqlJsonPath = {
  kind: 'json'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type CqlAsterisk = {
  kind: '*'
  type?: undefined
}
declare type CqlFieldType = 'string' | 'number' | 'boolean' | 'date' | 'json'
declare type CqlDeepPath = [string, ...(string | number)[]]
declare type CqlGroup = CqlSelectAlias[]
declare type CqlSelectAlias = string
declare type CqlWhere = Filter<any>
declare type CqlHaving = Filter<any>
declare type CqlOrder = OrderByDefinition<any>
declare class MessageHelperClass {
  id: string
  account_id: number
  feed_id: number
  external_id: string | null
  origin_id: string | null
  origin_type: string | null
  type: MessageType
  text: string | null
  as_feed: boolean
  reply_to: string | null
  files: MessageFile[] | null
  sticker: MessageSticker | null
  data:
    | JSONInputObject
    | {
        blocks: JSONValue[]
      }
    | ChangeMessageData
    | null
  reactions: Record<
    string,
    Array<{
      user_id: HeapId
    }>
  > | null
  created_at: Date
  updated_at: Date
  created_by: string
  updated_by: string
  is_deleted: boolean
  constructor(
    id: string,
    account_id: number,
    feed_id: number,
    external_id: string | null,
    origin_id: string | null,
    origin_type: string | null,
    type: MessageType,
    text: string | null,
    as_feed: boolean,
    reply_to: string | null,
    files: MessageFile[] | null,
    sticker: MessageSticker | null,
    data:
      | JSONInputObject
      | {
          blocks: JSONValue[]
        }
      | ChangeMessageData
      | null,
    reactions: Record<
      string,
      Array<{
        user_id: HeapId
      }>
    > | null,
    created_at: Date,
    updated_at: Date,
    created_by: string,
    updated_by: string,
    is_deleted: boolean,
  )
}
declare type Message = PublicFieldsOfClass<MessageHelperClass>
declare type ChangeMessageData = {
  action: string
  messageId: string
}
declare type MessageType = 'Message' | 'System' | 'Change' | 'Blocks'
declare const MessageType: {
  readonly Message: MessageType
  readonly System: MessageType
  readonly Change: MessageType
  readonly Blocks: MessageType
}
declare type MessageFile = {
  url: string
  hash: string
  meta: {
    mime: string
    size: number
    width?: number
    height?: number
    duration?: number
    name?: string
    extra?: string
  }
}
declare type MessageSticker = {
  url: string
  previewUrl?: string
  emoji?: string[]
}
declare type DynVar = string | number | boolean
interface TranslateFn {
  (key: string, args?: TranslateArgs): string
  (key: string | undefined, args?: TranslateArgs): string | undefined
  (key: string | null, args?: TranslateArgs): string | null
  (key: TranslationKey, args?: DynamicTranslateArgs): string
  (key: TranslationKey | undefined, args?: DynamicTranslateArgs): string | undefined
  (key: TranslationKey | null, args?: DynamicTranslateArgs): string | null
  (key: TranslationKey | string, args?: TranslateArgs): string
  <T extends null | undefined>(key: null | undefined, args?: TranslateArgs): T
}
declare type TranslationKey<T extends string = string> = [T, StaticTranslateArgs | undefined]
declare type TranslateArgs = {
  [key: string]: DynVar | InCodeSelector | bigint
} & {
  $ns?: string
}
declare type StaticTranslateArgs = {
  [key: string]: StaticInCodeSelector | string
} & {
  $ns?: string
}
declare type DynamicTranslateArgs = {
  [key: string]: DynVar
}
declare type InCodeSelector = {
  $val?: DynVar
} & StaticInCodeSelector
declare type StaticInCodeSelector = {
  $pluralType?: Intl.PluralRulesOptions['type']
  $other?: string | number
} & Record<string | number, DynVar>
interface LocaleCtx extends LangCtx {
  t: TranslateFn
  tt: TranslateFn
  timeZone: string
  formatNumber: (value: number, options?: ImprovedNumberFormatOptions) => string
}
declare type Lang = string
interface LangCtx {
  lang: Lang
}
interface ImprovedNumberFormatOptions extends Intl.NumberFormatOptions {
  style?: 'decimal' | 'currency' | 'percent'
  currencyDisplay?: 'symbol' | 'code' | 'name'
}
declare function serializeHeapSchema(schema: hs.HeapSchema): serializeHeapSchema.HsSerialized
declare namespace serializeHeapSchema {
  interface HssArray extends HsSerializedBase, hs.HsArrayOptions<hs.HeapSchema> {
    kind: 'ArrayKind'
    type: 'array'
    items: HsSerialized
  }
  interface HssEnum extends HsSerializedBase, hs.HsOptionsWithDefault<string | number> {
    kind: 'EnumKind'
    anyOf: tb.TEnumKey<string | number>[]
  }
  interface HssGenericLink extends HsSerializedBase, hs.HsLinkOptions {
    kind: 'GenericLinkKind'
    type: 'array'
  }
  interface HssFunctionRouteRef extends Omit<HssTuple, 'kind'> {
    kind: 'FunctionRouteRefKind'
    body: HsSerialized
    result: HsSerialized
  }
  interface HssIntersect extends HsSerializedBase, hs.HsIntersectOptions<hs.HeapSchema[]> {
    kind: 'IntersectKind'
    type: 'object'
    allOf: HsSerialized[]
  }
  interface HssJobRouteRef extends Omit<HssTuple, 'kind'> {
    kind: 'JobRouteRefKind'
    body: HsSerialized
  }
  interface HssMoney extends Omit<HssTuple, 'kind'> {
    kind: 'MoneyKind'
  }
  interface HssNumber extends HsSerializedBase, hs.HsNumberOptions {
    kind: 'NumberKind'
    type: 'number'
  }
  interface HssObject extends HsSerializedBase, hs.HsObjectOptions<hs.HsProperties> {
    kind: 'ObjectKind'
    type: 'object'
    properties: Record<string, HsSerialized>
    required?: string[]
  }
  interface HssRecord
    extends HsSerializedBase,
      hs.HsOptionsWithDefault<tb.StaticRecord<hs.HsRecordKey, hs.HeapSchema>> {
    kind: 'RecordKind'
    patternProperties: Record<string, HsSerialized>
  }
  interface HssRefLink extends HsSerializedBase, hs.HsLinkOptions {
    kind: 'RefLinkKind'
    type: 'string'
    targetTableName: string
    isSystemTarget: boolean
  }
  interface HssString extends HsSerializedBase, hs.HsStringOptions {
    kind: 'StringKind'
    type: 'string'
  }
  interface HssTuple extends HsSerializedBase, hs.HsOptionsWithDefault<tb.StaticTuple<hs.HeapSchema[]>> {
    kind: 'TupleKind'
    items?: HsSerialized[]
    additionalItems?: boolean
    minItems: number
    maxItems: number
  }
  interface HssUnion extends HsSerializedBase, hs.HsOptionsWithDefault<tb.StaticUnion<hs.HeapSchema[]>> {
    kind: 'UnionKind'
    anyOf: HsSerialized[]
  }
  type HssSerializedSimple = HsSerializedBase
  interface HsSerializedBase {
    kind: string
    modifier?: string
  }
  type HsSerialized =
    | HssArray
    | HssEnum
    | HssGenericLink
    | HssFunctionRouteRef
    | HssIntersect
    | HssJobRouteRef
    | HssMoney
    | HssNumber
    | HssObject
    | HssRecord
    | HssRefLink
    | HssString
    | HssTuple
    | HssUnion
    | HssSerializedSimple
}
declare type HssObject = serializeHeapSchema.HssObject
interface LocationCtx {
  location: Location | undefined
}
interface Location {
  country: string
  region: string
  timeZone: string
  city: string
  coordinates: Coordinates
}
interface Coordinates {
  latitude: number
  longitude: number
}
declare type TypedJobPath<P, R> = string & {
  p: P
  r: R
}
interface HsPropertiesWithOptions {
  [key: string]: hs.HeapSchema & hs.HsOptionsWithDefault<unknown>
}
declare type SessionId = string
declare type BS = hs.HeapSchema
declare type PS = hs.HsObject<hs.HsStringFriendlyProperties> | hs.HsRecord<hs.HsString, hs.HsString | hs.HsNumber>
declare type QS = hs.HsObject<HsPropertiesWithOptions> | hs.HsRecord<hs.HsString, hs.HeapSchema>
declare type RS = hs.HeapSchema
declare type RouteRefGetSchemaFn = (
  codeAccountId: number,
  routerUrlPath: string,
  routePattern: string,
  routeType: UgcRouteType,
) => Promise<RouteRefSchema>
declare type RouteRefSchema = {
  meta?: AnyObject
  bs?: BS
  ps?: PS
  qs?: QS
  rs?: RS
}
export declare type PartialEmbeddings = {
  [K in EmbeddingType]?: Array<number[]>
}
export declare type EmbeddingType = 'openai-text-embedding3-large' | 'openai-text-embedding3-small'
declare type TsVectorLangKey = 'ru' | 'en'
declare enum Currency {
  USD = 'USD',
  RUB = 'RUB',
  EUR = 'EUR',
}
interface Money {
  amount: number
  currency: Currency
}
declare type AppPermissionRequirements = tb.Static<typeof appPermissionRequirementsSchema>
declare const appPermissionRequirementsSchema: tb.TObject<{
  accountApps: tb.TOptional<
    tb.TUnion<
      [
        ...(
          | tb.TLiteral<'read'>
          | tb.TLiteral<'read-optional'>
          | tb.TLiteral<'write'>
          | tb.TLiteral<'write-or-read'>
          | tb.TLiteral<'write-optional'>
        )[],
        tb.TObject<
          {
            install: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
            uninstall: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
          } & {
            all: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
          }
        >,
      ]
    >
  >
  globalApps: tb.TOptional<
    tb.TUnion<
      [
        ...(
          | tb.TLiteral<'read'>
          | tb.TLiteral<'read-optional'>
          | tb.TLiteral<'write'>
          | tb.TLiteral<'write-or-read'>
          | tb.TLiteral<'write-optional'>
        )[],
        tb.TObject<
          {
            syncPermissions: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
          } & {
            all: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
          }
        >,
      ]
    >
  >
  accountDomains: tb.TOptional<
    tb.TUnion<
      (
        | tb.TLiteral<'read'>
        | tb.TLiteral<'read-optional'>
        | tb.TLiteral<'write'>
        | tb.TLiteral<'write-or-read'>
        | tb.TLiteral<'write-optional'>
      )[]
    >
  >
  accountHeap: tb.TOptional<
    tb.TUnion<
      [
        ...(
          | tb.TLiteral<'read'>
          | tb.TLiteral<'read-optional'>
          | tb.TLiteral<'write'>
          | tb.TLiteral<'write-or-read'>
          | tb.TLiteral<'write-optional'>
        )[],
        tb.TObject<
          {
            tablesList: tb.TOptional<tb.TUnion<(tb.TLiteral<'read'> | tb.TLiteral<'read-optional'>)[]>>
            tableByName: tb.TOptional<tb.TUnion<(tb.TLiteral<'read'> | tb.TLiteral<'read-optional'>)[]>>
            tableRows: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
            tableFile: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
          } & {
            all: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
          }
        >,
      ]
    >
  >
  accountJobs: tb.TOptional<
    tb.TUnion<
      [
        ...(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[],
        tb.TObject<
          {
            asap: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
            scheduled: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
          } & {
            all: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
          }
        >,
      ]
    >
  >
  accountSettings: tb.TOptional<
    tb.TUnion<
      [
        ...(
          | tb.TLiteral<'read'>
          | tb.TLiteral<'read-optional'>
          | tb.TLiteral<'write'>
          | tb.TLiteral<'write-or-read'>
          | tb.TLiteral<'write-optional'>
        )[],
        tb.TObject<
          {
            title: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
            image: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
            lang: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
            createdAt: tb.TOptional<tb.TUnion<(tb.TLiteral<'read'> | tb.TLiteral<'read-optional'>)[]>>
          } & {
            all: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
          }
        >,
      ]
    >
  >
  authenticate: tb.TOptional<
    tb.TUnion<
      [
        ...(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[],
        tb.TObject<
          {
            Phone: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
            Email: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
            TelegramId: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
            bySystemProvider: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
          } & {
            all: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
          }
        >,
      ]
    >
  >
  childAccounts: tb.TOptional<
    tb.TUnion<
      [
        ...(
          | tb.TLiteral<'read'>
          | tb.TLiteral<'read-optional'>
          | tb.TLiteral<'write'>
          | tb.TLiteral<'write-or-read'>
          | tb.TLiteral<'write-optional'>
        )[],
        tb.TObject<
          {
            accounts: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
            apps: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
            domains: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
            owners: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
          } & {
            all: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
          }
        >,
      ]
    >
  >
  feed: tb.TOptional<
    tb.TUnion<
      (
        | tb.TLiteral<'read'>
        | tb.TLiteral<'read-optional'>
        | tb.TLiteral<'write'>
        | tb.TLiteral<'write-or-read'>
        | tb.TLiteral<'write-optional'>
      )[]
    >
  >
  hook: tb.TOptional<
    tb.TUnion<
      [
        ...(tb.TLiteral<'read'> | tb.TLiteral<'read-optional'>)[],
        tb.TObject<
          {
            handlerInfo: tb.TOptional<tb.TUnion<(tb.TLiteral<'read'> | tb.TLiteral<'read-optional'>)[]>>
          } & {
            all: tb.TOptional<tb.TUnion<(tb.TLiteral<'read'> | tb.TLiteral<'read-optional'>)[]>>
          }
        >,
      ]
    >
  >
  i18n: tb.TOptional<
    tb.TUnion<
      [
        ...(tb.TLiteral<'read'> | tb.TLiteral<'read-optional'>)[],
        tb.TObject<
          {
            getSupportedTranslationLangs: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'read'> | tb.TLiteral<'read-optional'>)[]>
            >
          } & {
            all: tb.TOptional<tb.TUnion<(tb.TLiteral<'read'> | tb.TLiteral<'read-optional'>)[]>>
          }
        >,
      ]
    >
  >
  user: tb.TOptional<
    tb.TUnion<
      [
        ...(
          | tb.TLiteral<'read'>
          | tb.TLiteral<'read-optional'>
          | tb.TLiteral<'write'>
          | tb.TLiteral<'write-or-read'>
          | tb.TLiteral<'write-optional'>
        )[],
        tb.TObject<
          {
            createBotUser: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
            accountRole: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
            username: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
            lang: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
            identities: tb.TOptional<
              tb.TUnion<
                [
                  ...(
                    | tb.TLiteral<'read'>
                    | tb.TLiteral<'read-optional'>
                    | tb.TLiteral<'write'>
                    | tb.TLiteral<'write-or-read'>
                    | tb.TLiteral<'write-optional'>
                  )[],
                  tb.TObject<
                    {
                      Phone: tb.TOptional<
                        tb.TUnion<
                          (
                            | tb.TLiteral<'read'>
                            | tb.TLiteral<'read-optional'>
                            | tb.TLiteral<'write'>
                            | tb.TLiteral<'write-or-read'>
                            | tb.TLiteral<'write-optional'>
                          )[]
                        >
                      >
                      Email: tb.TOptional<
                        tb.TUnion<
                          (
                            | tb.TLiteral<'read'>
                            | tb.TLiteral<'read-optional'>
                            | tb.TLiteral<'write'>
                            | tb.TLiteral<'write-or-read'>
                            | tb.TLiteral<'write-optional'>
                          )[]
                        >
                      >
                      TelegramId: tb.TOptional<
                        tb.TUnion<
                          (
                            | tb.TLiteral<'read'>
                            | tb.TLiteral<'read-optional'>
                            | tb.TLiteral<'write'>
                            | tb.TLiteral<'write-or-read'>
                            | tb.TLiteral<'write-optional'>
                          )[]
                        >
                      >
                    } & {
                      all: tb.TOptional<
                        tb.TUnion<
                          (
                            | tb.TLiteral<'read'>
                            | tb.TLiteral<'read-optional'>
                            | tb.TLiteral<'write'>
                            | tb.TLiteral<'write-or-read'>
                            | tb.TLiteral<'write-optional'>
                          )[]
                        >
                      >
                    }
                  >,
                ]
              >
            >
            name: tb.TOptional<
              tb.TUnion<
                [
                  ...(
                    | tb.TLiteral<'read'>
                    | tb.TLiteral<'read-optional'>
                    | tb.TLiteral<'write'>
                    | tb.TLiteral<'write-or-read'>
                    | tb.TLiteral<'write-optional'>
                  )[],
                  tb.TObject<
                    {
                      firstName: tb.TOptional<
                        tb.TUnion<
                          (
                            | tb.TLiteral<'read'>
                            | tb.TLiteral<'read-optional'>
                            | tb.TLiteral<'write'>
                            | tb.TLiteral<'write-or-read'>
                            | tb.TLiteral<'write-optional'>
                          )[]
                        >
                      >
                      middleName: tb.TOptional<
                        tb.TUnion<
                          (
                            | tb.TLiteral<'read'>
                            | tb.TLiteral<'read-optional'>
                            | tb.TLiteral<'write'>
                            | tb.TLiteral<'write-or-read'>
                            | tb.TLiteral<'write-optional'>
                          )[]
                        >
                      >
                      lastName: tb.TOptional<
                        tb.TUnion<
                          (
                            | tb.TLiteral<'read'>
                            | tb.TLiteral<'read-optional'>
                            | tb.TLiteral<'write'>
                            | tb.TLiteral<'write-or-read'>
                            | tb.TLiteral<'write-optional'>
                          )[]
                        >
                      >
                    } & {
                      all: tb.TOptional<
                        tb.TUnion<
                          (
                            | tb.TLiteral<'read'>
                            | tb.TLiteral<'read-optional'>
                            | tb.TLiteral<'write'>
                            | tb.TLiteral<'write-or-read'>
                            | tb.TLiteral<'write-optional'>
                          )[]
                        >
                      >
                    }
                  >,
                ]
              >
            >
            gender: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
            birthday: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
            image: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
          } & {
            all: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
          }
        >,
      ]
    >
  >
  metric: tb.TOptional<
    tb.TUnion<
      [
        ...(
          | tb.TLiteral<'read'>
          | tb.TLiteral<'read-optional'>
          | tb.TLiteral<'write'>
          | tb.TLiteral<'write-or-read'>
          | tb.TLiteral<'write-optional'>
        )[],
        tb.TObject<
          {
            event: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
            eventSubscription: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
          } & {
            all: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
          }
        >,
      ]
    >
  >
  storage: tb.TOptional<
    tb.TObject<{
      fullAccountAccess: tb.TOptional<tb.TUnion<(tb.TLiteral<'read'> | tb.TLiteral<'read-optional'>)[]>>
      upload: tb.TOptional<
        tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
      >
    }>
  >
  system: tb.TOptional<
    tb.TUnion<
      [
        ...(
          | tb.TLiteral<'read'>
          | tb.TLiteral<'read-optional'>
          | tb.TLiteral<'write'>
          | tb.TLiteral<'write-or-read'>
          | tb.TLiteral<'write-optional'>
        )[],
        tb.TObject<
          {
            sendEmail: tb.TOptional<
              tb.TUnion<(tb.TLiteral<'write'> | tb.TLiteral<'write-or-read'> | tb.TLiteral<'write-optional'>)[]>
            >
          } & {
            all: tb.TOptional<
              tb.TUnion<
                (
                  | tb.TLiteral<'read'>
                  | tb.TLiteral<'read-optional'>
                  | tb.TLiteral<'write'>
                  | tb.TLiteral<'write-or-read'>
                  | tb.TLiteral<'write-optional'>
                )[]
              >
            >
          }
        >,
      ]
    >
  >
}>
declare enum UserRole {
  Admin = 'Admin',
  Staff = 'Staff',
  Support = 'Support',
  ActiveSupport = 'ActiveSupport',
  Developer = 'Developer',
  BetaTester = 'BetaTester',
  User = 'User',
}
declare enum UserStatus {
  Imported = 'Imported',
  Joined = 'Joined',
  AsSupport = 'AsSupport',
  Left = 'Left',
}
declare const systemOnlyIdentityTypes: readonly ['Password', 'ApiKey', 'DeviceId', 'TechSupport', 'GetcourseId']
declare type Identity = PublicFieldsOfClass<IdentityHelperClass>
declare class IdentityHelperClass {
  id: string
  account_id: number
  user_id: string
  type: IdentityType
  key: string
  secret: string | null
  last_confirmed_at: Date | null
  is_primary: boolean
  is_blocked: boolean
  created_at: Date
  updated_at: Date
  confirmed_by: AuthProvider[]
  constructor(
    id: string,
    account_id: number,
    user_id: string,
    type: IdentityType,
    key: string,
    secret: string | null,
    last_confirmed_at: Date | null,
    is_primary: boolean,
    is_blocked: boolean,
    created_at: Date,
    updated_at: Date,
    confirmed_by: AuthProvider[],
  )
}
declare type IdentityType = CustomProvidableIdentityType | SystemOnlyIdentityType
declare type CustomProvidableIdentityType = 'Phone' | 'Email' | 'TelegramId' | 'ParentAccountUser' | string
declare type SystemOnlyIdentityType = typeof systemOnlyIdentityTypes[number]
declare type AuthProvider =
  | 'Device'
  | 'Sms'
  | 'Email'
  | 'Password'
  | 'AnotherSession'
  | 'ParentAccount'
  | 'Getcourse'
  | 'MobileAppPhone'
  | 'MobileAppEmail'
  | 'Github'
  | 'Google'
  | 'Telegram'
  | 'Chatium'
  | string
declare type AuthProviderProps = {
  provider: AuthProvider
  /** additional provider-specific data provided by the provider and stored in the auth log */
  providerData?: Record<string, unknown>
}
declare type PrimaryIdentitiesByUser = Record<HeapId, PrimaryIdentities>
declare type PrimaryIdentities = {
  phone?: string
  email?: string
  hasPassword?: boolean
}
declare abstract class SmartUser<Ctx> {
  private ctx
  private coreUser
  private extendedInfo?
  private primaryIdentities?
  protected abstract userApi: SmartUserApi<Ctx>
  protected abstract fileServiceDirectHost: string
  protected abstract fileServiceCdnHost: string
  constructor(
    ctx: LocationCtx,
    coreUser: UgcCtxUser2,
    extendedInfo?: ExtendedUserInfo | undefined,
    primaryIdentities?: PrimaryIdentities | undefined,
  )
  get id(): HeapId
  get type(): User2['type']
  get displayName(): string
  get confirmedPhone(): string | undefined
  get confirmedEmail(): string | undefined
  get accountRole(): AccountRole
  get username(): string | undefined
  get firstName(): string | undefined
  get middleName(): string | undefined
  get lastName(): string | undefined
  get fullName(): string
  get gender(): UserGender | undefined
  get birthdayDate(): Date | undefined
  get birthday(): string | undefined
  get passwordSalt(): string
  get hasPassword(): boolean
  updateAccountRole(ctx: Ctx, newRole: AccountRole): Promise<void>
  updateUsername(ctx: Ctx, username: string): Promise<void>
  updatePassword(ctx: Ctx, password: string): Promise<void>
  updateLang(ctx: Ctx, lang: Lang | null): Promise<void>
  updateExtendedInfo(ctx: Ctx, info: UpdateExtendedUserInfoRaw): Promise<void>
  get smartIconProps(): {
    url?: string
    name?: PlainIconName
    text?: string
  }
  get hasImage(): boolean
  get imageUrl(): string | undefined
  /**
   * Effective image hash XOR url
   * Mainly for copying image data from one user to another
   */
  get rawImageInfo(): {
    imageHash?: string
    imageUrl?: string
  }
  getImageThumbnailUrl(size?: number): string | undefined
  is(role: Exclude<AccountRole, 'None'>): boolean
  get lang(): Lang | undefined
  toJSON(): JSONInputObject
  serialize(): SerializedSmartUser | UgcCtxUser1
  getProfile<T extends JSONInputObject>(): T | undefined
  private get fsHost()
}
declare type SerializedSmartUser = [UgcCtxUser2, ExtendedUserInfo | undefined, PrimaryIdentities | undefined]
interface SmartUserApi<Ctx> {
  updateAccountRole(ctx: Ctx, userId: HeapId, newRole: AccountRole): Promise<AccountRole>
  updateUsername(ctx: Ctx, userId: HeapId, username: string): Promise<string>
  updateExtendedInfo(
    ctx: Ctx,
    userId: HeapId,
    info: UpdateExtendedUserInfo,
  ): Promise<[UgcCtxUser2, ExtendedUserInfo | undefined]>
  updatePassword(ctx: Ctx, userId: HeapId, password: string): Promise<void>
  updateLang(ctx: Ctx, userId: HeapId, lang: Lang | null): Promise<string | undefined>
}
declare type ExtendedUserInfo = ExtendedUserFields & {
  displayName?: string
  profile?: JSONInputObject
}
declare type UpdateExtendedUserInfo = {
  firstName?: string | null
  lastName?: string | null
  middleName?: string | null
  gender?: UserGender | null
  birthday?: string | null
  imageHash?: string | null
  imageUrl?: string | null
}
declare type UpdateExtendedUserInfoRaw = Pick<
  UpdateExtendedUserInfo,
  'firstName' | 'middleName' | 'lastName' | 'gender' | 'imageHash' | 'imageUrl'
> & {
  birthday?: string | Date | null
}
declare type UserGender = 'male' | 'female' | 'other'
declare type HashMediaType = 'file' | 'video' | 'image' | 'audio'
declare abstract class BaseRefLink<T extends object, ReadCtx = unknown> {
  /**
   * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
   *
   * This is technical type, like written to heap-table "type" field,
   *  don't mix up with developer-defined table name provided to Heap.Table.
   * For system ref-links this also contains heap-type ('core.User' instead of 'users').
   */
  readonly type: HeapObjectType
  readonly id: HeapId
  /** Repository (table) that owns the row of this RefLink instance */
  readonly myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>
  /**
   * Repository (table) that owns the row of the target record.
   * Can be passed as table name or as repository instance.
   * When available, used in 'get' method implementation.
   */
  protected targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<hs.HsProperties, unknown, unknown> | undefined
  constructor(
    /**
     * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
     *
     * This is technical type, like written to heap-table "type" field,
     *  don't mix up with developer-defined table name provided to Heap.Table.
     * For system ref-links this also contains heap-type ('core.User' instead of 'users').
     */
    type: HeapObjectType,
    id: HeapId,
    /** Repository (table) that owns the row of this RefLink instance */
    myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>,
    /**
     * Repository (table) that owns the row of the target record.
     * Can be passed as table name or as repository instance.
     * When available, used in 'get' method implementation.
     */
    targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<hs.HsProperties, unknown, unknown> | undefined,
  )
  toJSON(): string
  toString(): string
  get<R = T>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  abstract getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface RefLinkClass {
  new (
    type: HeapObjectType,
    id: HeapId,
    myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>,
    targetRepoOrTableName?: ReadOnlyHeapTableRepo<hs.HsProperties, unknown> | string,
  ): BaseRefLink<AnyObject>
}
declare abstract class BaseGenericLink<ReadCtx = unknown> {
  readonly type: HeapObjectType
  readonly id: HeapId
  readonly myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>;
  [index: number]: HeapObjectType | HeapId
  readonly length = 2
  constructor(type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>)
  get<R = hs.HeapObjectBase>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  /** simulates the serialized format for compatibility */
  [Symbol.iterator](): IterableIterator<HeapObjectType | HeapId>
  toJSON(): GenericLinkJson
  toString(): string
  abstract getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface GenericLinkClass {
  new (type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>): BaseGenericLink
}
declare type GenericLinkJson = [HeapObjectType, HeapId]
declare type User2 = hs.HeapObjectBase & {
  type: 'Anonymous' | 'Real' | 'Bot'
  username?: string
  lang?: Lang
  timeZone?: string
  accountRole: AccountRole
  isBlocked: boolean
  knownChildAccounts?: number[]
} & ExtendedUserFields
declare type ExtendedUserFields = {
  firstName?: string
  lastName?: string
  middleName?: string
  gender?: UserGender
  birthday?: string
  imageHash?: string
  imageUrl?: string
}
declare type AccountRole = typeof validAccountRoles[number]
declare const validAccountRoles: readonly ['None', 'Staff', 'Admin', 'Developer', 'Owner']
interface HeapLink<_HD extends HeapData> {
  type: HeapObjectType
  id: HeapId
}
declare type HeapObjectBaseV1 = HeapObjectBaseRaw & {
  idx: number
  createdBy: HeapLink<UserData> | null
  updatedBy: HeapLink<UserData> | null
}
declare type HeapData = {
  '~~heap~data~tag~~': never
}
declare type EraseHD<HD extends HeapData> = Omit<HD, keyof HeapData>
declare type RefLink<HD extends HeapData> = HD & {
  '~~ref~link~tag~~': never
}
declare type GenericLink = {
  '~~generic~link~tag~~': never
}
declare type HeapObjectV1<HD extends HeapData> = HeapObjectBaseV1 & MapHeapLinks<HD>
declare type MapHeapLinks<HD extends HeapData> = {
  [K in keyof EraseHD<HD>]: LinksMap<HD[K]>
}
declare type LinksMap<T> = T extends null
  ? null
  : T extends GenericLink
  ? HeapId
  : T extends RefLink<HeapData>
  ? HeapLink<T>
  : T
interface PurchasedProducts {
  [productName: string]: string | true | undefined
}
interface UserData extends HeapData {
  authId: number
  roles: UserRole[]
  status: UserStatus
  expiresAt: string | null
  avatar: Icon
  firstName: string | null
  lastName: string | null
  phone: string | null
  email: string | null
  platforms: EnvPlatform[]
  purchasedProducts: PurchasedProducts
}
declare type User1 = HeapObjectV1<UserData>
declare type AuthSession = PublicFieldsOfClass<AuthSessionHelperClass>
declare class AuthSessionHelperClass {
  id: string
  account_id: number
  user_id: string
  auth_log: AuthLogItem[]
  device_name: string
  is_mobile: boolean
  os_name: string
  last_ip: string
  last_active_approx_at: Date
  created_at: Date
  /**
   * matching session token from the external auth provider or device ID for the anonymous user sessions
   * helps to avoid creating a new session duing upstream provider session revalidation
   * @see getOrCreateExternalAuthSession
   */
  external_token: string | null
  constructor(
    id: string,
    account_id: number,
    user_id: string,
    auth_log: AuthLogItem[],
    device_name: string,
    is_mobile: boolean,
    os_name: string,
    last_ip: string,
    last_active_approx_at: Date,
    created_at: Date,
    /**
     * matching session token from the external auth provider or device ID for the anonymous user sessions
     * helps to avoid creating a new session duing upstream provider session revalidation
     * @see getOrCreateExternalAuthSession
     */
    external_token: string | null,
  )
}
interface AuthLogItem {
  provider: AuthProvider
  /**
   * Provider-specific additional data provided by the provider that can be used for later system call to the provider.
   */
  providerData?: AnyObject
  /**
   * 'AuthSession' means that this session has been authenticated by another active session with the session ID as a key
   */
  type: IdentityType | 'AuthSession'
  key: string
  authAt: number
}
declare class ParticipantHelperClass {
  id: string
  account_id: number
  feed_id: number
  user_id: HeapId
  read_at: Date | null
  read_message_id: string | null
  role: string
  muted: boolean
  inbox_disabled: boolean
  data: JSONInputObject | null
  created_at: Date
  updated_at: Date
  created_by: string
  updated_by: string
  is_deleted: boolean
  hooks: ParticipantHooks | null
  inbox_extra_data: JSONObject | null
  constructor(
    id: string,
    account_id: number,
    feed_id: number,
    user_id: HeapId,
    read_at: Date | null,
    read_message_id: string | null,
    role: string,
    muted: boolean,
    inbox_disabled: boolean,
    data: JSONInputObject | null,
    created_at: Date,
    updated_at: Date,
    created_by: string,
    updated_by: string,
    is_deleted: boolean,
    hooks: ParticipantHooks | null,
    inbox_extra_data: JSONObject | null,
  )
}
declare type Participant = PublicFieldsOfClass<ParticipantHelperClass>
interface ParticipantHooks {}
declare type UgcParticipant = Pick<Participant, 'id' | 'muted'> & {
  userId: Participant['user_id']
  createdAt: string
  updatedAt: string
  inboxDisabled: Participant['inbox_disabled']
  inboxExtraData: Participant['inbox_extra_data']
}
declare class FeedHelperClass {
  id: number
  uid: string
  account_id: number
  db_shard_id: string
  db_shard_move_state: DbShardMoveState | null
  model_type: string
  /**
   * For old entity-linked feeds - ID of the Heap object matching the entity
   * For new decoupled feeds this field should be renamed to inbox_subject_id -
   *  unique string which helps to detect which inbox item should be updated when the feed is updated
   */
  model_id: string
  title: string | null
  icon: Icon | null
  url: string | null
  status: string | null
  status_icon: StatusIcon | null
  is_actual: boolean
  pinned_message_id: string | null
  last_message_id: string | null
  owner_user_id: string | null
  created_at: Date
  updated_at: Date
  data: JSONObject | null
  hooks: FeedHooks | null
  inbox_extra_data: JSONObject | null
  constructor(
    id: number, // Идентификатор для связи
    uid: string, // Идентификатор для пользователя
    account_id: number,
    db_shard_id: string,
    db_shard_move_state: DbShardMoveState | null,
    model_type: string, // Тим подели кому принадлежит сообщение
    /**
     * For old entity-linked feeds - ID of the Heap object matching the entity
     * For new decoupled feeds this field should be renamed to inbox_subject_id -
     *  unique string which helps to detect which inbox item should be updated when the feed is updated
     */
    model_id: string,
    title: string | null,
    icon: Icon | null,
    url: string | null,
    status: string | null,
    status_icon: StatusIcon | null,
    is_actual: boolean,
    pinned_message_id: string | null, // Прикрепленное сообщение
    last_message_id: string | null, // Последнее сообщение
    owner_user_id: string | null, // Сделано для поиска фида по модели, принадлежащего конкретному юзеру
    created_at: Date,
    updated_at: Date,
    data: JSONObject | null,
    hooks: FeedHooks | null,
    inbox_extra_data: JSONObject | null,
  )
}
declare type Feed = PublicFieldsOfClass<FeedHelperClass>
interface FeedHooks {
  getInboxInfo?: TypedJobPath<GetInboxInfoHookParams, InboxInfo>
  getParticipantInboxInfo?: TypedJobPath<GetParticipantInboxInfoHookParams, InboxInfo>
}
declare type GetInboxInfoHookParams = {
  feed: InboxInfoHookFeedInfo
  lastMessage: InboxInfoHookMessageInfo | null
  event: 'messagePosted' | 'participantAdded' | 'participantRemove' | 'markAsRead'
}
declare type GetParticipantInboxInfoHookParams = GetInboxInfoHookParams & {
  participant: UgcParticipant
}
declare type InboxInfoHookFeedInfo = Pick<UgcFeed, 'id' | 'inboxExtraData'>
declare type InboxInfoHookMessageInfo = Pick<
  Message,
  'id' | 'type' | 'text' | 'as_feed' | 'reply_to' | 'files' | 'data' | 'created_by'
>
interface InboxInfo {
  title?: string
  description?: string
  icon?: Icon
  badge?: number
  subjectId?: HeapId
  url?: string
  updatedAt?: Date
  status?: StatusIcon
  data?: JSONObject | null
}
interface DbShardMoveState {
  status: 'PrimaryCopy' | 'Switch' | 'SecondaryCopy' | 'CleanSrcData'
  srcShardId: string
  dstShardId: string
  startTimestamp: number
}
declare type UgcFeed = Pick<Feed, 'title' | 'hooks'> & {
  id: Feed['uid']
  pinnedMessageId: Feed['pinned_message_id']
  lastMessageId: Feed['last_message_id']
  createdAt: Feed['created_at']
  updatedAt: Feed['updated_at']
  inboxSubjectId: Feed['model_id']
  inboxUrl: Feed['url']
  inboxExtraData: Feed['inbox_extra_data']
}
declare type UgcFileStorage = 'cgs' | 'db'
declare type CgsRepoVersion = string
declare class AccountHelperClass {
  id: number
  meta_hash: string
  name: string
  title: string
  domain: string | null
  is_domain_ready: boolean
  owner_id: number
  owners: HeapId[]
  logo: Icon | null
  created_at: Date
  lang: Lang | null
  auth_type: AccountAuthType
  type: AccountType
  external_id: string | null
  external_host: string | null
  expires_at: Date | null
  applications: number[]
  start_app: string | null
  published_version: CgsRepoVersion | null
  main_mobile_app_id: number | null
  parent_account_id: number
  path_prefix: string
  /**
   * if not empty, this is not a separate account, but code version container (brunch) for the given account ID
   */
  branch_of_account_id: number | null
  heap_shard_id: string
  heap_shard_move_state: DbShardMoveState | null
  /** ID/name of the cluster, key from federationConf.peerClusters */
  origin_cluster: string | null
  origin_account_id: number | null
  /** Is this account allowed to be exported to a peer cluster via federation machinery? */
  allow_federation: boolean
  /** Auto-sync from the origin cluster when new versions are published */
  auto_sync_from_origin: boolean
  constructor(
    id: number,
    meta_hash: string, // hash of account meta information for synchronization invalidation
    name: string, // <name>.chatium.com
    title: string, // human-readable
    domain: string | null,
    is_domain_ready: boolean, // use custom domain name or use <name>.chatium.com
    owner_id: number, // auth ID
    owners: HeapId[], // user-v2 IDs
    logo: Icon | null,
    created_at: Date,
    lang: Lang | null,
    auth_type: AccountAuthType,
    type: AccountType,
    external_id: string | null,
    external_host: string | null,
    expires_at: Date | null,
    applications: number[],
    start_app: string | null,
    published_version: CgsRepoVersion | null,
    main_mobile_app_id: number | null,
    parent_account_id: number,
    path_prefix: string, //usefull for url buiding, e.g. https://<domain_name>/<path_prefix>
    /**
     * if not empty, this is not a separate account, but code version container (brunch) for the given account ID
     */
    branch_of_account_id: number | null,
    heap_shard_id: string,
    heap_shard_move_state: DbShardMoveState | null,
    /** ID/name of the cluster, key from federationConf.peerClusters */
    origin_cluster: string | null,
    origin_account_id: number | null,
    /** Is this account allowed to be exported to a peer cluster via federation machinery? */
    allow_federation: boolean,
    /** Auto-sync from the origin cluster when new versions are published */
    auto_sync_from_origin: boolean,
  )
}
declare type AccountAuthType = 'Email' | 'Phone' | 'Multi'
declare type Account = PublicFieldsOfClass<AccountHelperClass>
declare enum AccountType {
  Chatium = 'Chatium',
  Getcourse = 'Getcourse',
  FollowersClub = 'FollowersClub',
  Playground = 'Playground',
  Reserved = 'Reserved',
}
declare type UgcCodeVersion = CgsRepoVersion
declare type UgcCtxUser1 = Pick<
  User1,
  'id' | 'firstName' | 'lastName' | 'roles' | 'avatar' | 'purchasedProducts' | 'phone' | 'email'
>
declare type UgcCtxUser2 = Pick<
  User2,
  | 'id'
  | 'type'
  | 'accountRole'
  | 'username'
  | 'firstName'
  | 'lastName'
  | 'middleName'
  | 'gender'
  | 'birthday'
  | 'imageHash'
  | 'imageUrl'
  | 'lang'
>
declare type UgcAuthSession = Pick<AuthSession, 'id' | 'auth_log'> & {
  deviceName: string
}
interface UgcCtxAccount {
  id: number
  name: string
  host: string
  authType: AccountAuthType
  /** @deprecated use host instead */
  externalHost: string | null
  publishedVersion: string | null
  metaHash: string
  pathPrefix: string
}
interface Layout {
  leftMenu?: {
    items?: LayoutMenuItem
  }
  bottomTabs?: LayoutBottomTabs
}
interface LayoutBottomTabs {
  tabs?: LayoutMenuItem[]
  activeTintColor?: string
  inactiveTintColor?: string
}
interface LayoutMenuItem {
  id?: string
  type: 'tab' | 'button'
  title?: string
  url?: string
  onClick?: ChatiumActions
  icon: IconProps
  key?: string
}
interface EnvAvc {
  id: string
  signature: string
  accMap: Record<
    /** base account ID */
    number,
    [
      /** branch account ID */
      number,
      UgcFileStorage,
      UgcCodeVersion | null,
      /** expiration timestamp in seconds */
      number,
    ]
  >
}
interface EnvCtx {
  env: Env
}
interface OptionalEnvCtx {
  env: Env | null
}
interface Env {
  development: boolean
  production: boolean
  platform: EnvPlatform
  version: number
  appBuildNumber?: number
  ios: boolean
  android: boolean
  web: boolean
  job: boolean
  debugSocketId: string | null
  usePreviewMode: boolean
  useScopedPreviewMode: null | Record<string, boolean | null | undefined>
  viewportWidth: number | null
  viewportHeight: number | null
  devicePixelRatio: number
  alwaysHeader: boolean
  clientScope?: 'modal' | 'desktop' | 'ide'
  desktopLayout?: DesktopLayout
  acceptChatiumJson: boolean
  client?: ClientInfo
  avc?: EnvAvc
}
declare const EnvPlatform: {
  readonly iOS: 'iOS'
  readonly Android: 'Android'
  readonly Web: 'Web'
  readonly Job: 'Job'
}
declare type EnvPlatform = keyof typeof EnvPlatform
interface ClientInfo {
  ip: string
  deviceName: string
  osName: string
}
declare type HsSelectOptions<HSP extends hs.HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  limit?: number | null | undefined
  offset?: number | null | undefined
  order?: HsOrderBy<HSP> | null | undefined
}
declare type HsOrderBy<HSP extends hs.HsProperties> = HsSingleOrderBy<HSP> | Array<HsSingleOrderBy<HSP>>
declare type HsSingleOrderBy<HSP extends hs.HsProperties> = (keyof HSP & string) | hs.HsOrderInputObject<HSP>
declare type HsTableSelectOptions<HSP extends hs.HsProperties> = Pick<
  HsSelectOptions<HSP & hs.HeapObjectFilterableSchema>,
  'where' | 'limit' | 'offset'
> & {
  order?: HeapOrderBy<HSP> | null | undefined
}
declare type HsTableSearchByOptions<HSP extends hs.HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  query: string
  embeddingsQuery?: string
  limit?: number
}
declare type HsFilter<HSP extends hs.HsProperties> =
  | hs.HsFilterInputObject<HSP>
  | HsTopAndOperator<HSP>
  | HsTopOrOperator<HSP>
  | HsTopNotOperator<HSP>
  | HsNoopOperator
declare type HsTableFilter<HSP extends hs.HsProperties> = HsFilter<HSP & hs.HeapObjectFilterableSchema>
declare type HsTopAndOperator<HSP extends hs.HsProperties> = {
  $and: Array<HsFilter<HSP>>
}
declare type HsTopOrOperator<HSP extends hs.HsProperties> = {
  $or: Array<HsFilter<HSP>>
}
declare type HsTopNotOperator<HSP extends hs.HsProperties> = {
  $not: HsFilter<HSP>
}
declare type HsFilterRighthand<HS extends hs.HeapSchema> = null | HsFilterRighthandNonNull<HS>
declare type HsFilterRighthandNonNull<HS extends hs.HeapSchema> = hs.HsFilterInput<HS> | CommonOperator<HS>
declare type CommonOperator<HS extends hs.HeapSchema> =
  | HsAndOperator<HS>
  | HsNoopOperator
  | HsNotOperator<HS>
  | HsOrOperator<HS>
declare type HsNoopOperator = {
  $noop: true | 1 | '1' | 'true' | 'yes'
}
declare type HsNotOperator<HS extends hs.HeapSchema> = {
  $not: HsFilterRighthand<HS>
}
declare type HsAndOperator<HS extends hs.HeapSchema> = {
  $and: Array<HsFilterRighthand<HS>>
}
declare type HsOrOperator<HS extends hs.HeapSchema> = {
  $or: Array<HsFilterRighthand<HS>>
}
declare type HsCompareOperators<V> = HsGtOperator<V> | HsGteOperator<V> | HsLtOperator<V> | HsLteOperator<V>
declare type HsGtOperator<V> = {
  $gt: V
}
declare type HsGteOperator<V> = {
  $gte: V
}
declare type HsLtOperator<V> = {
  $lt: V
}
declare type HsLteOperator<V> = {
  $lte: V
}
declare type HsIlikeOperator<V> = V extends string
  ? {
      $ilike: string
    }
  : never
declare type HsHasOperator<V> = V extends null | unknown[] | object
  ? never
  : [
      {
        $has: V
      },
    ]
declare type HsIncludesOperator<V> = {
  $includes:
    | V
    | {
        $any: V[]
      }
    | {
        $all: V[]
      }
}
declare type UgcSystemHeapTableName = 'users'
interface HqlSelectQuery {
  from: HqlFrom
  select: HqlSelect
  distinct?: boolean
  where?: CqlWhere
  group?: CqlSelectAlias[]
  having?: CqlHaving
  order?: HqlOrder
  limit?: number
  offset?: number
  resPlainJson?: boolean
  resTakeFirst?: boolean
}
declare type HqlFrom = HqlTable | HqlSubQuery
declare type HqlTable = {
  kind: 'table'
  heapType: HeapObjectType
}
declare type HqlSubQuery = {
  kind: 'sub'
  query: HqlSelectQuery
}
declare type HqlExpr = HqlField | HqlExprFn | HqlExprAgg | CqlDynParam
declare type HqlField = HqlTableField | HqlSubQueryField
declare type HqlTableField = HqlSystemColumn | HqlDataField
declare type HqlSubQueryField = HqlSubPlainField | HqlSubJsonField
declare type HqlSystemColumn = {
  kind: 'sys'
  name: HqlSystemColumnName
}
declare type HqlSystemColumnName = typeof allowedHqlSystemColumns[number]
declare const allowedHqlSystemColumns: readonly ['id', 'createdAt', 'updatedAt', 'createdBy', 'updatedBy']
declare type HqlDataField = {
  kind: 'data'
  path: string | CqlDeepPath
  type: CqlFieldType
}
declare type HqlSubPlainField = {
  kind: 'subPlain'
  name: string
}
declare type HqlSubJsonField = {
  kind: 'subJson'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type HqlExprFn = {
  kind: 'fn'
  fn: string
  args: Array<HqlExpr>
}
declare type HqlExprAgg = {
  kind: 'agg'
  fn: string
  args: [CqlAsterisk] | Array<CqlDynParam | HqlField | HqlExprFnNoAgg>
  distinct?: boolean
}
declare type HqlExprFnNoAgg = {
  kind: 'fn'
  fn: string
  args: Array<HqlField | HqlExprFnNoAgg | CqlDynParam>
}
declare type HqlSelect = Record<string, HqlExpr>
declare type HqlOrder = HqlSimpleOrderBy | Array<HqlSingleOrderBy>
declare type HqlSingleOrderBy = HqlSimpleOrderBy | [HqlSimpleOrderBy, SortDirection]
declare type HqlSimpleOrderBy =
  | HqlSystemColumnName
  | string
  | HqlDataField
  | HqlSubJsonField
  | HqlOrderAliasField
  | HqlExprFn
declare type HqlOrderAliasField = {
  kind: 'aliasJson'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type RequestDomainControlType = typeof validRequestDomainControlTypes[number]
declare const validRequestDomainControlTypes: readonly ['ZoneAndCert', 'OnlyCert', 'ProxiedCert']
declare class DomainHelperClass {
  id: number
  account_id: number
  name: string
  created_at: Date
  is_ready: boolean
  control_type: DomainControlType
  dns_records: DnsRecord[]
  lang: Lang | null
  path_prefix: string
  checked_at: Date
  constructor(
    id: number,
    account_id: number,
    name: string,
    created_at: Date,
    is_ready: boolean,
    control_type: DomainControlType,
    dns_records: DnsRecord[],
    lang: Lang | null,
    path_prefix: string,
    checked_at: Date,
  )
}
declare type DomainControlType = RequestDomainControlType | 'External'
declare type DnsRecordType = 'A' | 'AAAA' | 'CNAME' | 'TXT' | 'NS' | 'MX' | 'PTR' | 'SRV' | 'CERT'
interface DnsRecord {
  id: string
  type: DnsRecordType
  name: string
  value: string
  ttl: number
}
declare type Domain = PublicFieldsOfClass<DomainHelperClass>
declare type AccountAuthProvider = PublicFieldsOfClass<AccountAuthProviderHelperClass>
declare class AccountAuthProviderHelperClass {
  id: string
  account_id: number
  provider: AuthProvider
  enabled: boolean
  priority: number
  settings: AnyObject
  created_at: Date
  updated_at: Date
  constructor(
    id: string,
    account_id: number,
    provider: AuthProvider,
    enabled: boolean,
    priority: number,
    settings: AnyObject,
    created_at: Date,
    updated_at: Date,
  )
}
declare type EntityPermissionSubjectType = 'user'
interface Change {
  id: string
  prevId?: string
  operation: ChangeOperation
  messageId: string
  message?: ChatMessage
}
declare type ChangeOperation = 'create' | 'update' | 'delete'
interface IosIapReceipt {
  cancellation_date?: string
  cancellation_date_ms?: string
  cancellation_date_pst?: string
  cancellation_reason?: '0' | '1'
  expires_date?: string
  expires_date_ms?: string
  expires_date_pst?: string
  in_app_ownership_type?: 'FAMILY_SHARED' | 'PURCHASED'
  is_in_intro_offer_period: 'true' | 'false'
  is_trial_period: 'true' | 'false'
  is_upgraded?: 'true'
  offer_code_ref_name?: string
  original_purchase_date: string
  original_purchase_date_ms: string
  original_purchase_date_pst: string
  original_transaction_id: string
  product_id: string
  promotional_offer_id?: string
  purchase_date: string
  purchase_date_ms: string
  purchase_date_pst: string
  quantity: '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10'
  subscription_group_identifier: string
  transaction_id: string
  web_order_line_item_id: string
}
interface AndroidVerifyResult {
  isSuccessful: boolean
  errorMessage?: string
  /**
   * @see https://developers.google.com/android-publisher/api-ref/rest/v3/purchases.products
   * @see https://developers.google.com/android-publisher/api-ref/rest/v3/purchases.subscriptions
   */
  payload?: {
    acknowledgementState: 0 | 1
    developerPayload?: string
    kind: string
    obfuscatedExternalAccountId?: string
    obfuscatedExternalProfileId?: string
    orderId: string
    priceAmountMicros: string
    priceCurrencyCode: string
    purchaseType?: 0 | 1 | 2
    autoRenewing?: boolean
    autoResumeTimeMillis?: string
    cancelSurveyResult?: {
      cancelSurveyReason: 0 | 1 | 2 | 3 | 4
      userInputCancelReason: string
    }
    cancelReason?: 0 | 1 | 2 | 3
    countryCode?: string
    expiryTimeMillis?: string
    externalAccountId?: string
    introductoryPriceInfo?: {
      introductoryPriceCurrencyCode: string
      introductoryPriceAmountMicros: string
      introductoryPricePeriod: string
      introductoryPriceCycles: number
    }
    linkedPurchaseToken?: string
    paymentState?: 0 | 1 | 2 | 3
    priceChange?: {
      newPrice: {
        priceMicros: string
        currency: string
      }
      state: 0 | 1
    }
    profileName?: string
    emailAddress?: string
    givenName?: string
    familyName?: string
    profileId?: string
    promotionCode?: string
    promotionType?: 0 | 1
    startTimeMillis?: string
    userCancellationTimeMillis?: string
    consumptionState?: 0 | 1
    productId?: string
    purchaseState?: 0 | 1 | 2
    purchaseTimeMillis?: string
    purchaseToken?: string
    quantity?: number
    regionCode?: string
  }
}
declare class IapPurchaseHelperClass {
  id: number
  account_id: number
  user_id: HeapId | null
  session_id: string | null
  email_auth_id: number | null
  phone_auth_id: number | null
  session_auth_id: number | null
  original_transaction_id: string
  transaction_id: string | null
  created_at: Date
  updated_at: Date
  product_id: string
  purchased_at: Date
  expire_at: Date | null
  environment: IosTransactionEnvironment | null
  platform: 'iOS' | 'Android' | 'unknown'
  raw_info: IosIapReceipt | AndroidVerifyResult | null
  latest_update_type: IapUpdateType
  previous_user_id: HeapId | null
  constructor(
    id: number,
    account_id: number,
    user_id: HeapId | null,
    session_id: string | null,
    email_auth_id: number | null,
    phone_auth_id: number | null,
    session_auth_id: number | null,
    original_transaction_id: string,
    transaction_id: string | null,
    created_at: Date,
    updated_at: Date,
    product_id: string,
    purchased_at: Date,
    expire_at: Date | null,
    environment: IosTransactionEnvironment | null,
    platform: 'iOS' | 'Android' | 'unknown',
    raw_info: IosIapReceipt | AndroidVerifyResult | null,
    latest_update_type: IapUpdateType,
    previous_user_id: HeapId | null,
  )
}
declare type IapPurchase = PublicFieldsOfClass<IapPurchaseHelperClass>
declare type IapUpdateType = 'Purchased' | 'Renewed' | 'Refund' | 'OwnershipChanged' | 'Unknown'
declare enum IosTransactionEnvironment {
  Sandbox = 'Sandbox',
  Production = 'Production',
}
interface UgcInboxIcon {
  name?: PlainIconName
  url?: string
  text?: string | number
  color?: string
  bgColor?: string
}
interface MetricEventData {
  ts?: Date
  ts64?: number
  sign?: number
  title?: string
  account: Pick<Account, 'id' | 'type' | 'external_id'>
  user:
    | undefined
    | {
        id: string
        type: 'Anonymous' | 'Real' | 'Bot'
        firstName?: string | undefined
        lastName?: string | undefined
        accountRole?: string | undefined
        image?: string | undefined
        phone?: string | undefined
        email?: string | undefined
      }
  session:
    | undefined
    | {
        id: string | undefined
        phone?: string | undefined
        email?: string | undefined
      }
  uid: string | undefined
  sid: string | undefined
  inferredUid: boolean | undefined
  inferredSid: boolean | undefined
  gcVisitId: number | undefined
  gcVisitorId: number | undefined
  gcSessionId: number | undefined
  url: string
  hostname: string
  ip: string | undefined
  client?: {
    title: string | undefined
    referrer?: string | undefined
    userAgent?: string | undefined
    screenWidth?: number | undefined
    screenHeight?: number | undefined
    screenPixelRatio?: number | undefined
  }
  location?: {
    country?: string | undefined
    region?: string | undefined
    timeZone?: string | undefined
    city?: string | undefined
    latitude?: number | undefined
    longitude?: number | undefined
  }
  fcmToken?: string | undefined
  query?: {
    utm_funnel?: string | undefined
    utm_node?: string | undefined
    utm_node_from?: string | undefined
    utm_action?: string | undefined
    utm_action_params?: string | undefined
    utm_action_param1?: string | undefined
    utm_action_param2?: string | undefined
    utm_action_param3?: string | undefined
    utm_action_param1_float?: number | undefined
    utm_action_param2_float?: number | undefined
    utm_action_param3_float?: number | undefined
    utm_action_param4_float?: number | undefined
    utm_action_param1_int?: number | undefined
    utm_action_param2_int?: number | undefined
    utm_action_param3_int?: number | undefined
  }
  funnel?: string | undefined
  funnel_node?: string | undefined
  funnel_node_from?: string | undefined
  action?: string | undefined
  action_params?: string | undefined
  action_param1?: string | undefined
  action_param2?: string | undefined
  action_param3?: string | undefined
  action_param1_float?: number | undefined
  action_param2_float?: number | undefined
  action_param3_float?: number | undefined
  action_param4_float?: number | undefined
  action_param1_int?: number | undefined
  action_param2_int?: number | undefined
  action_param3_int?: number | undefined
  action_param1_arrstr?: string[] | undefined
  action_param2_arrstr?: string[] | undefined
  action_param3_arrstr?: string[] | undefined
  action_param1_uint32arr?: number[] | undefined
  action_param1_mapstrstr?: Record<string, string> | undefined
  action_param2_mapstrstr?: Record<string, string> | undefined
  utm_source?: string | undefined
  utm_medium?: string | undefined
  utm_content?: string | undefined
  utm_campaign?: string | undefined
  utm_term?: string | undefined
  keys?: string[]
  values?: string[]
  param_clrt?: string
  clrt_type?: string
  clrt_campaign_id?: string
  clrt_ad_id?: string
  clrt_run_id?: number
}
declare type UgcHeapRegistryLocalTable =
  | Record<'tableName' | 'modulePath' | 'exportName', string>
  | {
      tableName: string
      modulePath: string
      exportName: string
    }
declare type PerAccountKeyLangs = Record<number, Lang>
declare type CreateBotUserInfo = Pick<ExtendedUserFields, typeof botUserExtendedFields[number]>
declare const botUserExtendedFields: readonly ['firstName', 'middleName', 'lastName', 'imageHash', 'imageUrl']
interface UgcOutAccount {
  host: string
  externalHost: string | null
}
interface UgcOutCtx {
  traceId: string
  timeoutId?: number
  userId?: HeapId
  env: Env
  account?: UgcOutAccount
}
declare type UgcTraceCtx = Pick<UgcOutCtx, 'traceId'>
declare type UgcOutUserCtx = Pick<UgcOutCtx, 'traceId' | 'userId'>
declare type UgcOutEnvCtx = Required<Pick<UgcOutCtx, 'traceId' | 'env'>>
declare type UgcHeapTransactionType = 'batch' | 'serializable'
interface ChatiumHttpResponse<T = unknown> {
  body: T
  statusCode: number
  headers: IncomingHttpHeaders
}
declare type Method =
  | 'GET'
  | 'POST'
  | 'PUT'
  | 'PATCH'
  | 'HEAD'
  | 'DELETE'
  | 'OPTIONS'
  | 'TRACE'
  | 'get'
  | 'post'
  | 'put'
  | 'patch'
  | 'head'
  | 'delete'
  | 'options'
  | 'trace'
declare type FormDataValue = {
  value: any
  options?: FormDataAppendOptions
}
interface FormDataAppendOptions {
  filename?: string
}
export interface UgcInboxData {
  items: Array<UgcInboxOld>
  socketIds: Array<string>
}
export interface UgcInboxOld {
  id: number | string
  auth_id: number
  account_id: number
  title: string
  description: string | null
  icon: UgcInboxIcon | null
  status: UgcInboxIcon | null
  badge: number
  subject_id: string | null
  url: string
  updated_at: Date
  archived_at: Date | null
  pinned_at: Date | null
  data: JSONObject | null
}
interface UgcCodeVersionInfo {
  codeAccountId: number
  loadFrom: UgcFileStorage
  version: CgsRepoVersion | null
}
export interface UgcModuleSpecifier {
  hash: string
  origin: string
  specifier: string
  path: string
  /** used for inlined route refs */
  accId: number
}
export interface CtxOutsideFns {
  log?: Reference<(level: 'debug' | 'log' | 'info' | 'warn' | 'error', ...args: unknown[]) => void>
}
export interface UgcOutHttpRequestOptions {
  url: string
  method?: Method
  body?: string | UgcOutHttpRequestFormData
  json?: Record<string, unknown> | unknown[]
  form?: Record<string, unknown>
  headers?: Record<string, string | string[] | undefined>
  searchParams?: string | Record<string, string | number | boolean | null | undefined>
  responseType?: 'json' | 'text'
  encoding?: 'utf8' | 'base64'
  resolveBodyOnly?: boolean
  username?: string
  password?: string
  throwHttpErrors?: boolean
}
export declare type UgcOutHttpRequestFormData = {
  $$$type: 'FormData'
  _data: Record<string, FormDataValue>
}
export declare type UgcHttpRequestFn = <T = unknown>(
  outCtx: UgcTraceCtx,
  options: UgcOutHttpRequestOptions,
  ctx?: UgcTraceCtx,
) => Promise<ChatiumHttpResponse<T>>
export declare type UgcRouteType = 'get' | 'html' | 'screen' | 'apiCall' | 'post' | 'job' | 'function'
export interface GetSupportedTranslationLangsOptions {
  forceWithoutExternals?: true
  forceWithoutApps?: true
}
export declare type TranslationLangInfo = Record<
  Lang,
  {
    lang: Lang
    /** does the account's own code have translations for this lang? */
    account: boolean
    /** Percentage of deep external dependencies which have tranlations for this lang, false if they weren't scanned */
    externals: false | number
    /** Percentage of installed plugin apps which have translations for this lang, false if they weren't scanned */
    apps: false | number
  }
>
export interface UgcIapPurchase {
  productId: string
  purchasedAt: Date
  expireAt: Date | null
  sessionId: string
  userId: HeapId | null
  originalTransactionId: string
  lastTransactionId: string | null
  environment: IosTransactionEnvironment | null
  platform: IapPurchase['platform']
  rawInfo?: IosIapReceipt | AndroidVerifyResult
  lastUpdateType: IapUpdateType
  previousUserId: HeapId | null
}
/**
 * Points from which account the heap table code should be loaded:
 *  - `current` means the code of the currently running account
 *    (the data-owner account, the account on which domain the current request is running)
 *    even if the table is requested from the plugin application code (another account)
 *
 *  - `code` means the account whose code is currently running
 *    if it's a plugin app code, then the table will be loaded from the plugin app's account source
 */
export declare type HeapTableSourceAccountType = 'current' | 'code'
/** [ [Lang, [ModuleHash, accountId][]][], accountId -> keyLang ] */
export declare type UgcLangBundlesLoadInfo = [Array<readonly [Lang, Array<[string, number]>]>, PerAccountKeyLangs]
export interface UgcAuthServiceApi {
  createAnonymousUser(sessionId: SessionId, clientInfo: ClientInfo): Promise<[UgcCtxUser2, string, UgcAuthSession]>
  createRealUser(
    reqCtx: {
      userId?: HeapId
    },
    userInfo: CreateRealUserInfo,
  ): Promise<UgcCtxUser2>
  createOrUpdateBotUser(
    reqCtx: {
      userId?: HeapId
    },
    username: string,
    userInfo?: CreateBotUserInfo,
  ): Promise<UgcCtxUser2>
  authenticateUserInChildAccount(
    childAccountId: number,
    parentUserId: HeapId,
    parentAuthSessionId: string,
    clientInfo: ClientInfo,
  ): Promise<string>
  createAuthSessionTokenByAnotherSession(
    reqCtx: {
      userId: HeapId
    },
    sourceSessionId: string,
    targetDomain: string,
  ): Promise<string>
  getPrimaryIdentitiesForUsers(userIds: HeapId[]): Promise<PrimaryIdentitiesByUser>
  findUserIdsByFuzzyIdentityKeys(types: IdentityType[], word: string): Promise<HeapId[]>
  findUserIdsByFuzzyCoreFields(word: string): Promise<HeapId[]>
  findUserIdsByCoreFields(options: FindCoreUsersOptions): Promise<HeapId[]>
  findCoreUsersByIds(allIds: HeapId[]): Promise<UgcCtxUser2[]>
  findCoreUserById(id: HeapId): Promise<UgcCtxUser2 | null>
  updateUserAccountRole(userId: HeapId, newRole: AccountRole, currentUserId?: HeapId): Promise<AccountRole>
  updateUserUsername(userId: HeapId, username: string, currentUserId?: HeapId): Promise<string>
  updateUserPassword(userId: HeapId, password: string, currentUserId?: HeapId): Promise<void>
  updateUserLang(userId: HeapId, lang: Lang | null, currentUserId?: HeapId): Promise<Lang | undefined>
  updateUserExtendedFields(userId: HeapId, fields: UpdateExtendedUserInfo, currentUserId?: HeapId): Promise<UgcCtxUser2>
  findIdentities(options: FindIdentitiesOptions): Promise<UgcIdentity[]>
  getSignInEnabledAuthProviders(): Promise<SignInEnabledAuthProviders>
  getAuthProvidersSettings(): Promise<UgcAuthProviderSettings[]>
  updateAuthProviderSettings(
    provider: AuthProvider,
    patch: {
      enabled?: boolean
      priority?: number
      settings?: AnyObject
    },
  ): Promise<UgcAuthProviderSettings>
  deleteAuthProviderSettings(provider: AuthProvider): Promise<void>
  createOrUpdateAuthSessionByConfirmedIdentity(
    requestCtx: AuthRequestCtx,
    identityType: CustomProvidableIdentityType,
    identityKey: string,
    provider: AuthProviderProps,
  ): Promise<CreateAuthSessionResult>
  createUserWithConfirmedIdentity(
    outCtx: UgcTraceCtx,
    identityType: CustomProvidableIdentityType,
    identityKey: string,
    provider: AuthProviderProps,
  ): Promise<CreateUserWithIdentityResult>
  acquireAuthSessionForDevice(authSessionId: string, deviceId: string): Promise<string>
  calcTgHash(ctx: UgcTraceCtx, botToken: string, checkString: string): Promise<string>
  hasUgcFilePermissions(ctx: UgcTraceCtx, entityIds: string[], userId: string): Promise<boolean>
  hasUgcFilePermissionsAndSeat(ctx: UgcTraceCtx, entityIds: string[], userId: string): Promise<boolean>
}
export declare type CreateUserWithIdentityResult = {
  userId: HeapId
  identityId: string
}
export declare type SignInEnabledAuthProviders = Record<
  AuthProvider,
  {
    priority: number
    settings: AnyObject
  }
>
export interface CreateIdentityParams {
  userId: HeapId
  type: 'Email' | 'Phone'
  key: Identity['key']
  isBlocked?: boolean
}
export declare type CreateRealUserInfo = ExtendedUserFields & CreateRealUserCoreInfo
export declare type CreateRealUserCoreInfo = {
  username?: string
  accountRole?: Exclude<AccountRole, 'Owner'>
  unconfirmedIdentities?: {
    Phone?: string
    Email?: string
  }
}
export interface FindCoreUsersOptions {
  where?: {
    type?: User2['type']
    accountRole?: AccountRole | AccountRole[]
    username?: string
  }
  limit?: number
}
export declare type FindIdentitiesOptions = FindAllOptions<UgcIdentity>
export interface UgcIdentity {
  id: Identity['id']
  userId: Identity['user_id']
  type: Identity['type']
  key: Identity['key']
  isPrimary: Identity['is_primary']
  isBlocked: Identity['is_blocked']
  confirmedBy: Identity['confirmed_by']
  createdAt: Identity['created_at']
  updatedAt: Identity['updated_at']
}
export declare type CreateAuthSessionResult =
  | (CreateAuthSessionResultCreated & {
      token: string
    })
  | CreateAuthSessionResultRedirect
export declare type CreateAuthSessionResultCreated = {
  type: 'created'
  authSessionId: string
  userId: HeapId
  identityId: string
}
export declare type CreateAuthSessionResultRedirect = {
  type: 'redirect'
  userId: string
  identityId: string
  redirect: {
    type: 'gcWeb'
    url: string
    token: string
  }
}
export interface AuthRequestCtx {
  authSessionId: string | undefined
  deviceId: string
  env: Env
  lang: string
  timeZone: string
}
export declare type UgcAuthProviderSettings = Pick<
  AccountAuthProvider,
  'provider' | 'enabled' | 'settings' | 'priority'
>
export declare type FeedChangesJson = {
  success: true
  changes: Change[]
}
export declare type FeedMessagesJson = {
  success: true
  data: {
    messages: ChatMessage[]
    lastChangeId?: string | undefined | null
  }
}
export interface CreateFeedMessageOptions {
  sendPush?: boolean
}
export declare type MessageData =
  | string
  | NormalMessageData
  | SystemMessageData
  | BlocksMessageData
  | HistoryMessageData
declare type NormalMessageData = {
  type?: 'Message'
  text: string
  files?: Message['files']
  data?: JSONObject
} & MessageDataCommon
declare type SystemMessageData = {
  type: 'System'
  text: string
  data?: JSONObject
} & MessageDataCommon
declare type BlocksMessageData = {
  type: 'Blocks'
  data: {
    blocks: unknown[]
  } & JSONObject
} & MessageDataCommon
declare type HistoryMessageData = {
  type: 'Change'
  data: ChangeMessageData
  text?: string | null
} & MessageDataCommon
declare type MessageDataCommon = Partial<
  Pick<Message, 'as_feed' | 'reply_to' | 'external_id' | 'origin_id' | 'origin_type'>
>
export interface UgcHeapApiV2 extends UgcHeapTransactionApi {
  findHeapRecordByTypeAndId(
    outCtx: UgcTraceCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    id: HeapId,
    transactionId?: string,
  ): Promise<HeapRecord | null>
  findHeapRecordsByTypeAndIds(
    outCtx: UgcTraceCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    ids: HeapId[],
    transactionId?: string,
  ): Promise<HeapRecord[]>
  queryHeapRecords<HSP extends hs.HsProperties>(
    outCtx: UgcTraceCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    options: HeapRecordSelectOptions<HSP> | undefined,
    transactionId?: string,
  ): Promise<HeapRecord[]>
  queryHeapRecordIds<HSP extends hs.HsProperties>(
    outCtx: UgcTraceCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    options: HeapRecordSelectOptions<HSP> | undefined,
    transactionId?: string,
  ): Promise<HeapId[]>
  queryHeapRecordsBySearch<HSP extends hs.HsProperties>(
    outCtx: UgcTraceCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    options: HeapRecordSearchByOptions<HSP>,
    transactionId?: string,
  ): Promise<HeapRecord[]>
  countHeapRecords<HSP extends hs.HsProperties>(
    outCtx: UgcTraceCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    filter?: HeapRecordFilter<HSP> | null,
    transactionId?: string,
  ): Promise<number>
  runHeapSelectQuery<T extends AnyObject = AnyObject>(
    outCtx: UgcTraceCtx,
    tableNsType: HeapTableNsType,
    hql: HqlSelectQuery,
    transactionId?: string,
  ): Promise<T[]>
  createHeapRecord<T extends hs.HsProperties>(
    outCtx: UgcOutUserCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    tableInfo: OptionalHeapTableInfo,
    linkInfo: HeapLinkInfo[],
    data: tb.Static<hs.HsObject<T>> & {
      id?: HeapId
    },
    transactionId?: string,
  ): Promise<HeapRecord>
  updateHeapRecordMaybe<T extends hs.HsProperties>(
    outCtx: UgcOutUserCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    tableInfo: OptionalHeapTableInfo,
    linkInfo: HeapLinkInfo[],
    patch: Partial<tb.Static<hs.HsObject<T>>> & {
      id: HeapId
    },
    optionalFieldsToClear?: Array<keyof T>,
    transactionId?: string,
  ): Promise<HeapRecord | null>
  updateHeapRecords<T extends hs.HsProperties>(
    outCtx: UgcOutUserCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    tableInfo: OptionalHeapTableInfo,
    filter: HeapRecordFilter<T> | null | undefined,
    limit: number | null,
    linkInfo: HeapLinkInfo[],
    patch: Partial<tb.Static<hs.HsObject<T>>>,
    optionalFieldsToClear?: Array<keyof T>,
    transactionId?: string,
  ): Promise<number>
  createOrUpdateHeapRecordBy<T extends hs.HsProperties>(
    outCtx: UgcOutUserCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    tableInfo: OptionalHeapTableInfo,
    linkInfo: HeapLinkInfo[],
    uniqKey: hs.HsProperty<T>,
    patch: tb.Static<hs.HsObject<T>>,
    transactionId?: string,
  ): Promise<HeapRecord>
  deleteHeapRecord(
    outCtx: UgcOutUserCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    tableInfo: OptionalHeapTableInfo,
    id: HeapId,
    ugcInfo: UgcCodeVersionInfo,
    hardDelete: boolean,
    transactionId?: string,
  ): Promise<HeapRecord | null>
  deleteHeapRecords<T extends hs.HsProperties>(
    outCtx: UgcOutUserCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    tableInfo: OptionalHeapTableInfo,
    filter: HeapRecordFilter<T> | null | undefined,
    limit: number | null,
    ugcInfo: UgcCodeVersionInfo,
    hardDelete: boolean,
    transactionId?: string,
  ): Promise<number>
  createOrUpdateSingleton<T extends hs.HsProperties>(
    outCtx: UgcOutUserCtx,
    type: HeapObjectType,
    tableNsType: HeapTableNsType,
    tableInfo: OptionalHeapTableInfo,
    createLinkInfo: HeapLinkInfo[],
    createData: tb.Static<hs.HsObject<T>>,
    updateLinkInfo: HeapLinkInfo[],
    updatePatch: Partial<tb.Static<hs.HsObject<T>>>,
    optionalFieldsToClear: Array<keyof T> | undefined,
    transactionId?: string,
  ): Promise<HeapRecord>
  getFeedById(outCtx: UgcTraceCtx, feedId?: Feed['uid'], transactionId?: string): Promise<UgcFeed>
  createFeed(outCtx: UgcTraceCtx, feedProps?: UgcCreateFeedProps, transactionId?: string): Promise<UgcFeed>
  updateFeed(outCtx: UgcTraceCtx, feedProps: UgcUpdateFeedProps, transactionId?: string): Promise<UgcFeed>
  deleteFeed(
    outCtx: UgcTraceCtx,
    reqCtx: EnvCtx & Pick<LocaleCtx, 'lang' | 'timeZone'>,
    feedId?: Feed['uid'],
    transactionId?: string,
  ): Promise<UgcFeed | null>
  getAccountCgsTablesInfo(outCtx: UgcTraceCtx, codeVersion: CgsRepoVersion): Promise<UgcHeapRegistryLocalTable[]>
  getAccountDbVersionTablesInfo(outCtx: UgcTraceCtx): Promise<UgcHeapRegistryLocalTable[]>
  createOrUpdateAccountTableFile(
    outCtx: UgcOutUserCtx & UgcOutEnvCtx,
    filePath: string,
    props: CreateTableFileProps,
  ): Promise<void>
}
export interface CreateTableFileProps {
  tableName: string
  schema: HssObject
  customMeta?: AnyObject & {
    title?: string
  }
}
/**
 * How to convert plain `:<tableName>:<accId>` to heap type field for plugin applications:
 *  - `default` - add `app:<appId>` prefix for plugin app code calls
 *  - `account` - don't add app prefix - access data account-owned tables (only with relevant app permissions)
 *  - `core` - map given name using special hardcoded map to the core table type (currently, only users -> core.User)
 */
export declare type HeapTableNsType = 'default' | 'account' | 'core'
export declare type UgcCreateFeedProps = Partial<
  Pick<UgcFeed, 'title' | 'hooks' | 'inboxSubjectId' | 'inboxUrl' | 'inboxExtraData'>
>
export declare type UgcUpdateFeedProps = {
  id: UgcFeed['id']
} & UgcCreateFeedProps
export interface UgcHeapTransactionApi {
  beginTransaction(outCtx: UgcTraceCtx, txnType: UgcHeapTransactionType): Promise<string>
  commitTransaction(outCtx: UgcTraceCtx, transactionId: string): Promise<void>
  rollbackTransaction(outCtx: UgcTraceCtx, transactionId: string): Promise<void>
}
export declare type FindAsapJobsOptions = FindAllOptions<Omit<UgcAsapJob, 'nextRetryAt'>>
export declare type FindScheduledJobsOptions = FindAllOptions<UgcScheduledJob>
export interface UgcAsapJob {
  id: number
  path: string
  status: 'Pending' | 'PendingRetry' | 'Failure'
  createdAt: Date
  originStack: null | string
  appId: number | null
  scheduledJobId: null | number
  retryCount: number
  lastRetryAt: Date | null
  nextRetryAt: Date | null
  lastError: string | null
  params: any
  scheduleParams: any
  ctx: any
}
export interface UgcScheduledJob {
  id: number
  path: string
  runAt: Date
  createdAt: Date
  name: string | null
  originStack: null | string
  appId: number | null
  params: any
  scheduleParams: any
  ctx: any
}
export declare type UgcUgcFilePermissionSubjectType = EntityPermissionSubjectType
export interface UgcUgcFilePermission {
  id: string
  path: string
  subjectType: UgcUgcFilePermissionSubjectType
  subjectId: string | null
  createdAt: Date
  createdBy: string
  updatedAt: Date
  updatedBy: string
  canRead: boolean
}
export interface UgcUgcFileListItem {
  id: string
  path: string
  name: string
  type: string
  createdAt: Date
  createdBy: string | null
  updatedAt: Date
  updatedBy: string | null
  description?: string | null
  imageHash?: string | null
  params?: Record<string, unknown> | null
  buildError?: string
}
export interface UgcListUgcFilesOptions {
  pathRegexps?: string[]
  paths?: string[]
  ids?: string[]
  sourceTextRegexps?: string[]
  includeSource?: boolean
}
export interface UgcUgcFileFull extends UgcUgcFileListItem {
  source: string
}
export interface UgcSyncLockInfo {
  lockValidationId: string
  wasWaiting: boolean
}
export interface UgcSyncLockOptions {
  timeoutMs?: number
  maxDurationMs?: number
}
export interface UgcUpdateInboxParams {
  url: string
  subjectId?: string | null
  title: string
  description: string | null
  icon?: UgcInboxIcon | null
  badge?: number
  data?: JSONObject | null
  sendPush?: boolean
  withSound?: boolean
  pushImageUrl?: string | null
}
export declare type AppPermissionRequirementsSchema = typeof appPermissionRequirementsSchema
export declare type FindAppsOptions = FindAllOptions<UgcApp>
export declare type UgcAppPatch = Partial<Omit<UgcApp, 'id' | 'accountId'>> & Pick<UgcApp, 'id'>
export interface UgcApp {
  id: number
  slug: string
  name: string | null
  description: string | null
  icon: string | null
  image: string | null
  cover: string | null
  accountId: number
  isPublic: boolean
  allowedAccounts: number[]
  permissionRequirements: AppPermissionRequirements
  dependencies: number[]
}
export interface AppApiCallResult {
  error?: any
  response?: Record<string, unknown>
}
declare type UgcFormStorageAvailableValueType_Plain = string | boolean | number | null
export declare type UgcFormStorageAvailableValueType =
  | Record<string, UgcFormStorageAvailableValueType_Plain>
  | UgcFormStorageAvailableValueType_Plain
export declare type UgcAccountSeat = {
  userId: string
}
export interface UgcDomain {
  id: Domain['id']
  name: Domain['name']
  pathPrefix: Domain['path_prefix']
  isReady: Domain['is_ready']
  controlType: DomainControlType
  dnsRecords: Domain['dns_records']
  lang: Domain['lang']
  createdAt: Domain['created_at']
}
export interface UgcAccount extends UgcCtxAccount {
  title?: string
  image?: string | null
  lang?: Lang | null
  createdAt?: Date
}
export interface UgcCreateAccountOptions {
  title?: string
  image?: string
  type?: 'Chatium' | 'Playground'
  lang?: Lang | null
}
export interface UgcUpdateAccountSettings {
  title?: string
  image?: string | null
  lang?: Lang | null
}
export interface UgcAppServiceApiAccount {
  url: string
  title: string
  logo: Icon
}
export declare type UgcAppServiceApiLayout = Layout | undefined | string
export interface UgcAppServiceApiModule {
  id: string
  name: string | null
  icon: string | null
  title: string | null
  items: Array<any>
}
export interface UgcAppServiceApiApp {
  id: number
  name: string | null
  icon: string | null
  image: string | null
  cover: string | null
  description: string | null
  owner_id: number | null
  installed: boolean
  slug: string
  weight: number
  price: Money | undefined
  is_public: boolean
  is_active: boolean
}
export declare type IsolatedVmTransferable<T> = T extends Date
  ? string
  : T extends JSONValue | undefined
  ? T
  : T extends object
  ? {
      [K in keyof T]: IsolatedVmTransferable<T[K]>
    }
  : T extends Array<infer ArrayItem>
  ? Array<IsolatedVmTransferable<ArrayItem>>
  : never
export interface UgcAppMetricServiceCtx {
  req: {
    cookie: string | undefined
    userAgent: string | undefined
    url: string | undefined
    ip: string | undefined
    referrer: string | undefined
    fcmToken: string | undefined
    uid: string | undefined
    sid: string | undefined
    inferredUid: boolean
    inferredSid: boolean
  }
  account: {
    id: number
    type: string
  }
  user:
    | undefined
    | {
        id: string
        type: 'Anonymous' | 'Real' | 'Bot'
        firstName: string | undefined
        lastName: string | undefined
        accountRole: string | undefined
        image: string | undefined
        phone: string | undefined
        email: string | undefined
      }
  session:
    | undefined
    | {
        id: string | undefined
        phone: string | undefined
        email: string | undefined
      }
  auth:
    | undefined
    | {
        id: string
        phone: string | undefined
        email: string | undefined
      }
}
export declare type UgcAppMetricServiceEventData = Partial<Omit<MetricEventData, 'account'>>
export interface UgcAppMetricServiceModel {
  id: string
  heapType: string
}

export {}
