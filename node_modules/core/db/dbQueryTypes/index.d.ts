import { HeapObjectType } from 'core/heap/heapTypes'
import { AnyObject } from 'utils/types'

interface CqlSelectQuery {
  from: CqlFrom
  select: CqlSelect
  distinct?: boolean
  where?: CqlWhere
  having?: CqlHaving
  order?: CqlOrder
  group?: CqlGroup
  limit?: number
  offset?: number
}
declare type CqlFrom = CqlTable | CqlSubQuery
declare type CqlTable = {
  kind: 'table'
  schema: string
  name: string
}
declare type CqlSubQuery = {
  kind: 'sub'
  query: CqlSelectQuery
}
declare type CqlSelect = Record<string, CqlExpr> | undefined
declare type CqlExpr = CqlPlainColumn | CqlExprFn | CqlDynParam | CqlJsonPath | CqlAsterisk
declare type CqlPlainColumn = {
  kind: 'col'
  name: string
  type?: CqlFieldType
}
declare type CqlExprFn = {
  kind: 'fn'
  fn: string
  args: CqlExpr[]
  distinct?: boolean
  type?: CqlFieldType
}
declare type CqlDynParam = {
  kind: 'dyn'
  value: unknown
  type?: CqlFieldType
}
declare type CqlJsonPath = {
  kind: 'json'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type CqlAsterisk = {
  kind: '*'
  type?: undefined
}
declare type CqlFieldType = 'string' | 'number' | 'boolean' | 'date' | 'json'
declare type CqlDeepPath = [string, ...(string | number)[]]
declare type CqlGroup = CqlSelectAlias[]
declare type CqlSelectAlias = string
declare type CqlWhere = Filter<any>
declare type CqlHaving = Filter<any>
declare type CqlOrder = OrderByDefinition<any>
interface HqlSelectQuery {
  from: HqlFrom
  select: HqlSelect
  distinct?: boolean
  where?: CqlWhere
  group?: CqlSelectAlias[]
  having?: CqlHaving
  order?: HqlOrder
  limit?: number
  offset?: number
  resPlainJson?: boolean
  resTakeFirst?: boolean
}
declare type HqlFrom = HqlTable | HqlSubQuery
declare type HqlTable = {
  kind: 'table'
  heapType: HeapObjectType
}
declare type HqlSubQuery = {
  kind: 'sub'
  query: HqlSelectQuery
}
declare type HqlExpr = HqlField | HqlExprFn | HqlExprAgg | CqlDynParam
declare type HqlField = HqlTableField | HqlSubQueryField
declare type HqlTableField = HqlSystemColumn | HqlDataField
declare type HqlSubQueryField = HqlSubPlainField | HqlSubJsonField
declare type HqlSystemColumn = {
  kind: 'sys'
  name: HqlSystemColumnName
}
declare type HqlSystemColumnName = typeof allowedHqlSystemColumns[number]
declare const allowedHqlSystemColumns: readonly ['id', 'createdAt', 'updatedAt', 'createdBy', 'updatedBy']
declare type HqlDataField = {
  kind: 'data'
  path: string | CqlDeepPath
  type: CqlFieldType
}
declare type HqlSubPlainField = {
  kind: 'subPlain'
  name: string
}
declare type HqlSubJsonField = {
  kind: 'subJson'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type HqlExprFn = {
  kind: 'fn'
  fn: string
  args: Array<HqlExpr>
}
declare type HqlExprAgg = {
  kind: 'agg'
  fn: string
  args: [CqlAsterisk] | Array<CqlDynParam | HqlField | HqlExprFnNoAgg>
  distinct?: boolean
}
declare type HqlExprFnNoAgg = {
  kind: 'fn'
  fn: string
  args: Array<HqlField | HqlExprFnNoAgg | CqlDynParam>
}
declare type HqlSelect = Record<string, HqlExpr>
declare type HqlOrder = HqlSimpleOrderBy | Array<HqlSingleOrderBy>
declare type HqlSingleOrderBy = HqlSimpleOrderBy | [HqlSimpleOrderBy, SortDirection]
declare type HqlSimpleOrderBy =
  | HqlSystemColumnName
  | string
  | HqlDataField
  | HqlSubJsonField
  | HqlOrderAliasField
  | HqlExprFn
declare type HqlOrderAliasField = {
  kind: 'aliasJson'
  path: CqlDeepPath
  type: CqlFieldType
}
export interface FindAllOptions<T extends WithId> {
  where?: Filter<T> | null | undefined
  limit?: number | null | undefined
  offset?: number | null | undefined
  order?: OrderByDefinition<T> | null | undefined
}
export declare type Filter<T extends WithId> = FilterObject<T>
export interface WithId {
  id: number | string
}
export declare type FilterObject<T> =
  | FilterSingleObject<T>
  | TopAndOperator<T>
  | TopOrOperator<T>
  | TopNotOperator<T>
  | NoopOperator
export declare type FilterSingleObject<T> = {
  [K in keyof T]?: FilterRighthand<T[K]>
}
export declare type TopAndOperator<T> = {
  $and: Array<FilterObject<T>>
}
export declare type TopOrOperator<T> = {
  $or: Array<FilterObject<T>>
}
export declare type TopNotOperator<T> = {
  $not: FilterObject<T>
}
export declare type NoopOperator = {
  $noop: unknown
}
/**
 * Helps to build filters with complex expression on the left side.
 * Used only internally by the hql2cql transformation. Shouldn't be used by the end user yet.
 * @internal
 */
export declare type BinaryFilter = {
  $op: [CqlExpr, string, unknown]
}
export declare type FilterRighthand<V> = SimpleRighthand<V> | Operator<V> | FilterSingleObject<V>
declare type SimpleRighthand<V> = null | V | Array<V> | (V extends Date ? DateHint : never)
/** Way to send Date filter through serilization */
export declare type DateHint = {
  $date: string
}
declare type Operator<V> = SimpleOperator<V> | NotOperator<V> | AndOperator<V> | OrOperator<V>
declare type SimpleOperator<V> =
  | GtOperator<V>
  | GteOperator<V>
  | LtOperator<V>
  | LteOperator<V>
  | HasOperator<V>
  | IncludesOperator<V>
  | IlikeOperator<V>
  | InOperator<V>
  | NotInOperator<V>
  | NoopOperator
declare type GtOperator<V> = {
  $gt: V
}
declare type GteOperator<V> = {
  $gte: V
}
declare type LtOperator<V> = {
  $lt: V
}
declare type LteOperator<V> = {
  $lte: V
}
declare type IlikeOperator<V> = V extends string
  ? {
      $ilike: V
    }
  : never
declare type HasOperator<V> = {
  $has: V extends AnyObject ? keyof V : never
}
declare type IncludesOperator<V> = {
  $includes:
    | ArrayElement<V>
    | {
        $any: ArrayElement<V>[]
      }
    | {
        $all: ArrayElement<V>[]
      }
}
declare type NotOperator<V> = {
  $not: FilterRighthand<V>
}
declare type AndOperator<V> = {
  $and: Array<FilterRighthand<V>>
}
declare type OrOperator<V> = {
  $or: Array<FilterRighthand<V>>
}
declare type InOperator<V> = {
  $in: CqlSelectQuery | HqlSelectQuery | Array<V>
}
declare type NotInOperator<V> = {
  $notIn: CqlSelectQuery | HqlSelectQuery | Array<V>
}
declare type ArrayElement<V> = V extends unknown[] ? V[number] : never
export declare type OrderByDefinition<T> = SingleOrderBy<T> | Array<SingleOrderBy<T>>
export declare type SingleOrderBy<T> = (keyof T & string) | ObjectOrderVariant<T>
export declare type ObjectOrderVariant<T> = {
  [Field in keyof T & string]?: SingleOrderByValue<T[Field]>
}
export declare type SingleOrderByValue<V> = V extends object
  ? ObjectOrderVariant<V>
  : SortDirection | ValueTypeHint | [ValueTypeHint, SortDirection]
export declare type SortDirection = typeof validSortDirections[number]
export declare const validSortDirections: readonly [
  'asc',
  'desc',
  'asc nulls first',
  'asc nulls last',
  'desc nulls first',
  'desc nulls last',
]
export declare type ValueTypeHint = '$string' | '$number' | '$date' | '$boolean' | '$json'
export declare const validPgOperatorFns: {
  readonly add: '+'
  readonly sub: '-'
  readonly neg: '-'
  readonly mul: '*'
  readonly div: '/'
  readonly mod: '%'
  readonly exp: '^'
}
export declare type ValidPgOperatorFnName = keyof typeof validPgOperatorFns
export declare const validPgOperatorFnNames: readonly ('sub' | 'add' | 'neg' | 'mul' | 'div' | 'mod' | 'exp')[]

export {}
