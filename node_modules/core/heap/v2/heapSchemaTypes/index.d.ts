import * as tb from '@sinclair/typebox'
import { Filter, ObjectOrderVariant, OrderByDefinition, SortDirection } from 'core/db/dbQueryTypes'
import { HeapId, HeapObjectBaseRaw, HeapObjectCoord, HeapObjectType, HeapOrderBy } from 'core/heap/heapTypes'
import { HeapSelectQueryBuilder, HeapView } from 'core/heap/hqb/HeapSelectQueryBuilder'
import * as hs from 'core/heap/v2/heapSchemaTypes'
import { ReadOnlyHeapTableRepo } from 'core/heap/v2/HeapTableRepo'
import { Currency, Money } from 'core/heap/v2/Money'
import { Icon } from 'lib/chatium-json/v1'
import { DesktopLayout, PlainIconName } from 'lib/chatium-json/v2'
import { StorageAudioFile, StorageFile, StorageImageFile, StorageVideoFile } from 'modules/storage/StorageFile'
import { UgcRouteType } from 'services/ugc-runner/runtime/runtimeTypes'
import { UgcSmartUser } from 'services/ugc-runner/runtime/user/UgcSmartUser'
import { AnyObject, IsAny, JSONInputObject } from 'utils/types'

interface CqlSelectQuery {
  from: CqlFrom
  select: CqlSelect
  distinct?: boolean
  where?: CqlWhere
  having?: CqlHaving
  order?: CqlOrder
  group?: CqlGroup
  limit?: number
  offset?: number
}
declare type CqlFrom = CqlTable | CqlSubQuery
declare type CqlTable = {
  kind: 'table'
  schema: string
  name: string
}
declare type CqlSubQuery = {
  kind: 'sub'
  query: CqlSelectQuery
}
declare type CqlSelect = Record<string, CqlExpr> | undefined
declare type CqlExpr = CqlPlainColumn | CqlExprFn | CqlDynParam | CqlJsonPath | CqlAsterisk
declare type CqlPlainColumn = {
  kind: 'col'
  name: string
  type?: CqlFieldType
}
declare type CqlExprFn = {
  kind: 'fn'
  fn: string
  args: CqlExpr[]
  distinct?: boolean
  type?: CqlFieldType
}
declare type CqlDynParam = {
  kind: 'dyn'
  value: unknown
  type?: CqlFieldType
}
declare type CqlJsonPath = {
  kind: 'json'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type CqlAsterisk = {
  kind: '*'
  type?: undefined
}
declare type CqlFieldType = 'string' | 'number' | 'boolean' | 'date' | 'json'
declare type CqlDeepPath = [string, ...(string | number)[]]
declare type CqlGroup = CqlSelectAlias[]
declare type CqlSelectAlias = string
declare type CqlWhere = Filter<any>
declare type CqlHaving = Filter<any>
declare type CqlOrder = OrderByDefinition<any>
declare type Lang = string
interface LangCtx {
  lang: Lang
}
declare type TimeUnit =
  | 'milliseconds'
  | 'seconds'
  | 'minutes'
  | 'hours'
  | 'days'
  | 'weeks'
  | 'months'
  | 'quarters'
  | 'years'
interface LocationCtx {
  location: Location | undefined
}
interface Location {
  country: string
  region: string
  timeZone: string
  city: string
  coordinates: Coordinates
}
interface Coordinates {
  latitude: number
  longitude: number
}
interface UgcJobScheduleParams {
  allowRetry?: boolean
}
interface HsPropertiesWithOptions {
  [key: string]: hs.HeapSchema & hs.HsOptionsWithDefault<unknown>
}
declare type BS = hs.HeapSchema
declare type PS = hs.HsObject<hs.HsStringFriendlyProperties> | hs.HsRecord<hs.HsString, hs.HsString | hs.HsNumber>
declare type QS = hs.HsObject<HsPropertiesWithOptions> | hs.HsRecord<hs.HsString, hs.HeapSchema>
declare type RS = hs.HeapSchema
declare type IsOptionalBody<T> = unknown extends T ? true : undefined extends T ? true : false
interface FunctionRouteRef<B, R> {
  readonly pattern: string
  run: IsOptionalBody<B> extends true
    ? (ctx: RichUgcCtx, params?: B) => Promise<R>
    : (ctx: RichUgcCtx, params: B) => Promise<R>
  path(ctx: RichUgcCtx): Promise<string>
  meta(ctx: RichUgcCtx): Promise<AnyObject>
  bodySchema(ctx: RichUgcCtx): Promise<BS>
  resultSchema(ctx: RichUgcCtx): Promise<RS>
  schema(ctx: RichUgcCtx): Promise<{
    meta: AnyObject
    body: BS
    result: RS
  }>
}
interface JobRouteRef<B> {
  readonly pattern: string
  scheduleJobAt: IsOptionalBody<B> extends true
    ? (ctx: RichUgcCtx, startAt: Date, params?: B, scheduleParams?: UgcJobScheduleParams) => Promise<number>
    : (ctx: RichUgcCtx, startAt: Date, params: B, scheduleParams?: UgcJobScheduleParams) => Promise<number>
  scheduleJobAfter: IsOptionalBody<B> extends true
    ? (
        ctx: RichUgcCtx,
        amount: number,
        unit: TimeUnit,
        params?: B,
        scheduleParams?: UgcJobScheduleParams,
      ) => Promise<number>
    : (
        ctx: RichUgcCtx,
        amount: number,
        unit: TimeUnit,
        params: B,
        scheduleParams?: UgcJobScheduleParams,
      ) => Promise<number>
  scheduleJobAsap: IsOptionalBody<B> extends true
    ? (ctx: RichUgcCtx, params?: B, scheduleParams?: UgcJobScheduleParams) => Promise<number>
    : (ctx: RichUgcCtx, params: B, scheduleParams?: UgcJobScheduleParams) => Promise<number>
  path(): string
  meta(ctx: RichUgcCtx): Promise<AnyObject>
  bodySchema(ctx: RichUgcCtx): Promise<BS>
  schema(ctx: RichUgcCtx): Promise<{
    body: BS
  }>
}
declare type RouteRefGetSchemaFn = (
  codeAccountId: number,
  routerUrlPath: string,
  routePattern: string,
  routeType: UgcRouteType,
) => Promise<RouteRefSchema>
declare type RouteRefSchema = {
  meta?: AnyObject
  bs?: BS
  ps?: PS
  qs?: QS
  rs?: RS
}
declare type TsVectorLangKey = 'ru' | 'en'
declare enum UserRole {
  Admin = 'Admin',
  Staff = 'Staff',
  Support = 'Support',
  ActiveSupport = 'ActiveSupport',
  Developer = 'Developer',
  BetaTester = 'BetaTester',
  User = 'User',
}
declare enum UserStatus {
  Imported = 'Imported',
  Joined = 'Joined',
  AsSupport = 'AsSupport',
  Left = 'Left',
}
declare type PrimaryIdentities = {
  phone?: string
  email?: string
  hasPassword?: boolean
}
declare abstract class SmartUser<Ctx> {
  private ctx
  private coreUser
  private extendedInfo?
  private primaryIdentities?
  protected abstract userApi: SmartUserApi<Ctx>
  protected abstract fileServiceDirectHost: string
  protected abstract fileServiceCdnHost: string
  constructor(
    ctx: LocationCtx,
    coreUser: UgcCtxUser2,
    extendedInfo?: ExtendedUserInfo | undefined,
    primaryIdentities?: PrimaryIdentities | undefined,
  )
  get id(): HeapId
  get type(): User2['type']
  get displayName(): string
  get confirmedPhone(): string | undefined
  get confirmedEmail(): string | undefined
  get accountRole(): AccountRole
  get username(): string | undefined
  get firstName(): string | undefined
  get middleName(): string | undefined
  get lastName(): string | undefined
  get fullName(): string
  get gender(): UserGender | undefined
  get birthdayDate(): Date | undefined
  get birthday(): string | undefined
  get passwordSalt(): string
  get hasPassword(): boolean
  updateAccountRole(ctx: Ctx, newRole: AccountRole): Promise<void>
  updateUsername(ctx: Ctx, username: string): Promise<void>
  updatePassword(ctx: Ctx, password: string): Promise<void>
  updateLang(ctx: Ctx, lang: Lang | null): Promise<void>
  updateExtendedInfo(ctx: Ctx, info: UpdateExtendedUserInfoRaw): Promise<void>
  get smartIconProps(): {
    url?: string
    name?: PlainIconName
    text?: string
  }
  get hasImage(): boolean
  get imageUrl(): string | undefined
  /**
   * Effective image hash XOR url
   * Mainly for copying image data from one user to another
   */
  get rawImageInfo(): {
    imageHash?: string
    imageUrl?: string
  }
  getImageThumbnailUrl(size?: number): string | undefined
  is(role: Exclude<AccountRole, 'None'>): boolean
  get lang(): Lang | undefined
  toJSON(): JSONInputObject
  serialize(): SerializedSmartUser | UgcCtxUser1
  getProfile<T extends JSONInputObject>(): T | undefined
  private get fsHost()
}
declare type SerializedSmartUser = [UgcCtxUser2, ExtendedUserInfo | undefined, PrimaryIdentities | undefined]
interface SmartUserApi<Ctx> {
  updateAccountRole(ctx: Ctx, userId: HeapId, newRole: AccountRole): Promise<AccountRole>
  updateUsername(ctx: Ctx, userId: HeapId, username: string): Promise<string>
  updateExtendedInfo(
    ctx: Ctx,
    userId: HeapId,
    info: UpdateExtendedUserInfo,
  ): Promise<[UgcCtxUser2, ExtendedUserInfo | undefined]>
  updatePassword(ctx: Ctx, userId: HeapId, password: string): Promise<void>
  updateLang(ctx: Ctx, userId: HeapId, lang: Lang | null): Promise<string | undefined>
}
declare type ExtendedUserInfo = ExtendedUserFields & {
  displayName?: string
  profile?: JSONInputObject
}
declare type UpdateExtendedUserInfo = {
  firstName?: string | null
  lastName?: string | null
  middleName?: string | null
  gender?: UserGender | null
  birthday?: string | null
  imageHash?: string | null
  imageUrl?: string | null
}
declare type UpdateExtendedUserInfoRaw = Pick<
  UpdateExtendedUserInfo,
  'firstName' | 'middleName' | 'lastName' | 'gender' | 'imageHash' | 'imageUrl'
> & {
  birthday?: string | Date | null
}
declare type UserGender = 'male' | 'female' | 'other'
declare type HashMediaType = 'file' | 'video' | 'image' | 'audio'
declare abstract class BaseRefLink<T extends object, ReadCtx = unknown> {
  /**
   * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
   *
   * This is technical type, like written to heap-table "type" field,
   *  don't mix up with developer-defined table name provided to Heap.Table.
   * For system ref-links this also contains heap-type ('core.User' instead of 'users').
   */
  readonly type: HeapObjectType
  readonly id: HeapId
  /** Repository (table) that owns the row of this RefLink instance */
  readonly myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>
  /**
   * Repository (table) that owns the row of the target record.
   * Can be passed as table name or as repository instance.
   * When available, used in 'get' method implementation.
   */
  protected targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<hs.HsProperties, unknown, unknown> | undefined
  constructor(
    /**
     * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
     *
     * This is technical type, like written to heap-table "type" field,
     *  don't mix up with developer-defined table name provided to Heap.Table.
     * For system ref-links this also contains heap-type ('core.User' instead of 'users').
     */
    type: HeapObjectType,
    id: HeapId,
    /** Repository (table) that owns the row of this RefLink instance */
    myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>,
    /**
     * Repository (table) that owns the row of the target record.
     * Can be passed as table name or as repository instance.
     * When available, used in 'get' method implementation.
     */
    targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<hs.HsProperties, unknown, unknown> | undefined,
  )
  toJSON(): string
  toString(): string
  get<R = T>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  abstract getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface RefLinkClass {
  new (
    type: HeapObjectType,
    id: HeapId,
    myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>,
    targetRepoOrTableName?: ReadOnlyHeapTableRepo<hs.HsProperties, unknown> | string,
  ): BaseRefLink<AnyObject>
}
declare abstract class BaseGenericLink<ReadCtx = unknown> {
  readonly type: HeapObjectType
  readonly id: HeapId
  readonly myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>;
  [index: number]: HeapObjectType | HeapId
  readonly length = 2
  constructor(type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>)
  get<R = hs.HeapObjectBase>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  /** simulates the serialized format for compatibility */
  [Symbol.iterator](): IterableIterator<HeapObjectType | HeapId>
  toJSON(): GenericLinkJson
  toString(): string
  abstract getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface GenericLinkClass {
  new (type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>): BaseGenericLink
}
declare type GenericLinkJson = [HeapObjectType, HeapId]
declare type User2 = hs.HeapObjectBase & {
  type: 'Anonymous' | 'Real' | 'Bot'
  username?: string
  lang?: Lang
  timeZone?: string
  accountRole: AccountRole
  isBlocked: boolean
  knownChildAccounts?: number[]
} & ExtendedUserFields
declare type ExtendedUserFields = {
  firstName?: string
  lastName?: string
  middleName?: string
  gender?: UserGender
  birthday?: string
  imageHash?: string
  imageUrl?: string
}
declare type AccountRole = typeof validAccountRoles[number]
declare const validAccountRoles: readonly ['None', 'Staff', 'Admin', 'Developer', 'Owner']
interface HeapLink<_HD extends HeapData> {
  type: HeapObjectType
  id: HeapId
}
declare type HeapObjectBaseV1 = HeapObjectBaseRaw & {
  idx: number
  createdBy: HeapLink<UserData> | null
  updatedBy: HeapLink<UserData> | null
}
declare type HeapData = {
  '~~heap~data~tag~~': never
}
declare type EraseHD<HD extends HeapData> = Omit<HD, keyof HeapData>
declare type RefLink<HD extends HeapData> = HD & {
  '~~ref~link~tag~~': never
}
declare type GenericLink = {
  '~~generic~link~tag~~': never
}
declare type HeapObjectV1<HD extends HeapData> = HeapObjectBaseV1 & MapHeapLinks<HD>
declare type MapHeapLinks<HD extends HeapData> = {
  [K in keyof EraseHD<HD>]: LinksMap<HD[K]>
}
declare type LinksMap<T> = T extends null
  ? null
  : T extends GenericLink
  ? HeapId
  : T extends RefLink<HeapData>
  ? HeapLink<T>
  : T
interface PurchasedProducts {
  [productName: string]: string | true | undefined
}
interface UserData extends HeapData {
  authId: number
  roles: UserRole[]
  status: UserStatus
  expiresAt: string | null
  avatar: Icon
  firstName: string | null
  lastName: string | null
  phone: string | null
  email: string | null
  platforms: EnvPlatform[]
  purchasedProducts: PurchasedProducts
}
declare type User1 = HeapObjectV1<UserData>
declare type UgcFileStorage = 'cgs' | 'db'
declare type CgsRepoVersion = string
declare type UgcCodeVersion = CgsRepoVersion
declare type UgcCtxUser1 = Pick<
  User1,
  'id' | 'firstName' | 'lastName' | 'roles' | 'avatar' | 'purchasedProducts' | 'phone' | 'email'
>
declare type UgcCtxUser2 = Pick<
  User2,
  | 'id'
  | 'type'
  | 'accountRole'
  | 'username'
  | 'firstName'
  | 'lastName'
  | 'middleName'
  | 'gender'
  | 'birthday'
  | 'imageHash'
  | 'imageUrl'
  | 'lang'
>
interface EnvAvc {
  id: string
  signature: string
  accMap: Record<
    /** base account ID */
    number,
    [
      /** branch account ID */
      number,
      UgcFileStorage,
      UgcCodeVersion | null,
      /** expiration timestamp in seconds */
      number,
    ]
  >
}
interface OptionalEnvCtx {
  env: Env | null
}
interface Env {
  development: boolean
  production: boolean
  platform: EnvPlatform
  version: number
  appBuildNumber?: number
  ios: boolean
  android: boolean
  web: boolean
  job: boolean
  debugSocketId: string | null
  usePreviewMode: boolean
  useScopedPreviewMode: null | Record<string, boolean | null | undefined>
  viewportWidth: number | null
  viewportHeight: number | null
  devicePixelRatio: number
  alwaysHeader: boolean
  clientScope?: 'modal' | 'desktop' | 'ide'
  desktopLayout?: DesktopLayout
  acceptChatiumJson: boolean
  client?: ClientInfo
  avc?: EnvAvc
}
declare const EnvPlatform: {
  readonly iOS: 'iOS'
  readonly Android: 'Android'
  readonly Web: 'Web'
  readonly Job: 'Job'
}
declare type EnvPlatform = keyof typeof EnvPlatform
interface ClientInfo {
  ip: string
  deviceName: string
  osName: string
}
declare type HsSelectOptions<HSP extends hs.HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  limit?: number | null | undefined
  offset?: number | null | undefined
  order?: HsOrderBy<HSP> | null | undefined
}
declare type HsOrderBy<HSP extends hs.HsProperties> = HsSingleOrderBy<HSP> | Array<HsSingleOrderBy<HSP>>
declare type HsSingleOrderBy<HSP extends hs.HsProperties> = (keyof HSP & string) | hs.HsOrderInputObject<HSP>
declare type HsTableSelectOptions<HSP extends hs.HsProperties> = Pick<
  HsSelectOptions<HSP & hs.HeapObjectFilterableSchema>,
  'where' | 'limit' | 'offset'
> & {
  order?: HeapOrderBy<HSP> | null | undefined
}
declare type HsTableSearchByOptions<HSP extends hs.HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  query: string
  embeddingsQuery?: string
  limit?: number
}
declare type HsFilter<HSP extends hs.HsProperties> =
  | hs.HsFilterInputObject<HSP>
  | HsTopAndOperator<HSP>
  | HsTopOrOperator<HSP>
  | HsTopNotOperator<HSP>
  | HsNoopOperator
declare type HsTableFilter<HSP extends hs.HsProperties> = HsFilter<HSP & hs.HeapObjectFilterableSchema>
declare type HsTopAndOperator<HSP extends hs.HsProperties> = {
  $and: Array<HsFilter<HSP>>
}
declare type HsTopOrOperator<HSP extends hs.HsProperties> = {
  $or: Array<HsFilter<HSP>>
}
declare type HsTopNotOperator<HSP extends hs.HsProperties> = {
  $not: HsFilter<HSP>
}
declare type HsFilterRighthand<HS extends hs.HeapSchema> = null | HsFilterRighthandNonNull<HS>
declare type HsFilterRighthandNonNull<HS extends hs.HeapSchema> = hs.HsFilterInput<HS> | CommonOperator<HS>
declare type CommonOperator<HS extends hs.HeapSchema> =
  | HsAndOperator<HS>
  | HsNoopOperator
  | HsNotOperator<HS>
  | HsOrOperator<HS>
declare type HsNoopOperator = {
  $noop: true | 1 | '1' | 'true' | 'yes'
}
declare type HsNotOperator<HS extends hs.HeapSchema> = {
  $not: HsFilterRighthand<HS>
}
declare type HsAndOperator<HS extends hs.HeapSchema> = {
  $and: Array<HsFilterRighthand<HS>>
}
declare type HsOrOperator<HS extends hs.HeapSchema> = {
  $or: Array<HsFilterRighthand<HS>>
}
declare type HsCompareOperators<V> = HsGtOperator<V> | HsGteOperator<V> | HsLtOperator<V> | HsLteOperator<V>
declare type HsGtOperator<V> = {
  $gt: V
}
declare type HsGteOperator<V> = {
  $gte: V
}
declare type HsLtOperator<V> = {
  $lt: V
}
declare type HsLteOperator<V> = {
  $lte: V
}
declare type HsIlikeOperator<V> = V extends string
  ? {
      $ilike: string
    }
  : never
declare type HsHasOperator<V> = V extends null | unknown[] | object
  ? never
  : [
      {
        $has: V
      },
    ]
declare type HsIncludesOperator<V> = {
  $includes:
    | V
    | {
        $any: V[]
      }
    | {
        $all: V[]
      }
}
declare type UgcSystemHeapTableName = 'users'
/**
 * Extends typebox's base schema interface with advanced heap capabilities
 */
export interface HeapSchema extends tb.TSchema {
  /**
   * Type of runtime heap object representation of the value
   *  which may not the same as plain JSON-able value for some types
   */
  $hsRuntime: unknown
  /**
   * Type of input value supported by the heapTableRepo.create() method.
   * Usualy this is a union of JSON type ($static) and runtime type ($heapObject).
   * Also, all NonRequired-modified object fields are typed optional (?:) - deeply.
   */
  $hsCreateInput: unknown
  /**
   * Same as $heapCreateInput NonRequired-modifier has no effect here,
   *  because defalt-value autofilling is not performed at all during update operations.
   */
  $hsUpdateInput: unknown
  /**
   * Type of possible filter value of this field type in findAll where option
   * @see HeapTableRepo.findAll
   */
  $hsFilterInput: unknown
  /**
   * Type of possible order value of this field type in findAll order option
   * @see HeapTableRepo.findAll
   */
  $hsOrderInput: unknown
  kind: symbol
}
export declare function isHeapSchema(schema: any): schema is HeapSchema
export declare type HsRuntime<T extends HeapSchema> = T['$hsRuntime']
export declare type HsCreateInput<T extends HeapSchema> = T['$hsCreateInput']
export declare type HsUpdateInput<T extends HeapSchema> = T['$hsUpdateInput']
export declare type HsFilterInput<T extends HeapSchema> = T['$hsFilterInput']
export declare type HsOrderInput<T extends HeapSchema> = T['$hsOrderInput']
export interface HsOptionsWithDefault<DT> extends HsSearchableOptions {
  defaultValue?: DT
}
export interface HsSearchableOptions extends HsCommonOptions, HsSearchable {}
export interface HsSearchable {
  searchable?: {
    langs: Array<TsVectorLangKey>
    embeddings?: boolean
  }
}
export interface HsCommonOptions extends HsCustomMetaOption {
  title?: string
  description?: string
  examples?: unknown[]
  deprecated?: boolean
}
export interface HsCustomMetaOption {
  /** Developer-defined meta-information than can be read by generic heap introspection tools */
  customMeta?: Record<string, any> & {
    title?: string
  }
}
export interface HsUnionable extends HeapSchema {
  $unionable: typeof Unionable
  type: 'array' | 'boolean' | 'integer' | 'null' | 'number' | 'object' | 'string' | 'undefined'
}
export declare const Unionable: unique symbol
export interface HsIntersectable extends HeapSchema {
  $intersectable: typeof Itersectable
  type: 'object'
}
export declare const Itersectable: unique symbol
export interface HsAny<T = any> extends HeapSchema, HsOptionsWithDefault<T> {
  $static: T
  $hsRuntime: T
  $hsCreateInput: T
  $hsUpdateInput: T
  $hsFilterInput: ComparableFilter<T> | HsIlikeOperator<string>
  $hsOrderInput: IsAny<T> extends true ? AnyPathOrderInput : T extends object ? ObjectOrderVariant<T> : SortDirection
  kind: typeof tb.AnyKind
}
export interface HsArray<T extends HeapSchema> extends HsUnionable, HsArrayOptions<T> {
  $static: tb.StaticArray<T>
  $hsRuntime: Array<HsRuntime<T>>
  $hsCreateInput: Array<HsCreateInput<T>>
  $hsUpdateInput: Array<HsUpdateInput<T>>
  $hsFilterInput: HsIncludesOperator<Exclude<HsFilterInput<T>, unknown[] | AnyObject>>
  $hsOrderInput: SortDirection | Record<number, HsFilterInput<T>>
  kind: typeof tb.ArrayKind
  type: 'array'
  items: T
}
export declare type HsArrayOptions<T extends HeapSchema> = Pick<
  tb.ArrayOptions,
  'uniqueItems' | 'minItems' | 'maxItems'
> &
  HsOptionsWithDefault<tb.StaticArray<T>> & {
    skipInvalidItems?: boolean
  }
export interface HsBoolean extends HsUnionable, HsOptionsWithDefault<boolean> {
  $static: boolean
  $hsRuntime: boolean
  $hsCreateInput: boolean
  $hsUpdateInput: boolean
  $hsFilterInput: boolean | boolean[] | SubQueryFilter<boolean>
  $hsOrderInput: SortDirection
  kind: typeof tb.BooleanKind
  type: 'boolean'
}
export interface HsDateTime extends HsUnionable, HsDateTimeOptions {
  $static: string
  $hsRuntime: Date
  $hsCreateInput: string | Date | 'now'
  $hsUpdateInput: string | Date | 'now'
  $hsFilterInput: ComparableFilter<string | Date> | SubQueryFilter<string>
  $hsOrderInput: SortDirection
  type: 'string'
  kind: typeof DateTimeKind
  format: 'date-time'
}
export declare const DateTimeKind: unique symbol
export interface HsDateTimeOptions extends HsOptionsWithDefault<'now' | string> {}
export interface HsEnum<T extends tb.TEnumKey[]> extends HeapSchema, HsOptionsWithDefault<tb.StaticEnum<T>> {
  $static: tb.StaticEnum<T>
  $hsRuntime: tb.StaticEnum<T>
  $hsCreateInput: tb.StaticEnum<T>
  $hsUpdateInput: tb.StaticEnum<T>
  $hsFilterInput:
    | ComparableFilter<tb.StaticEnum<T>>
    | HsIlikeOperator<tb.StaticEnum<T>>
    | SubQueryFilter<tb.StaticEnum<T>>
  $hsOrderInput: SortDirection
  kind: typeof tb.EnumKind
  anyOf: T
}
export interface HsFile extends HsUnionable, HsCommonOptions {
  $static: string
  $hsRuntime: StorageFile
  $hsCreateInput: FileInput
  $hsUpdateInput: FileInput
  $hsFilterInput: FileInput | FileInput[] | SubQueryFilter<string>
  $hsOrderInput: SortDirection
  type: 'string'
  kind: typeof FileKind
}
export declare const FileKind: unique symbol
declare type FileInput = string | StorageFile
export interface HsImageFile extends HsUnionable, HsCommonOptions {
  $static: string
  $hsRuntime: StorageImageFile
  $hsCreateInput: ImageFileInput
  $hsUpdateInput: ImageFileInput
  $hsFilterInput: ImageFileInput | ImageFileInput[] | SubQueryFilter<string>
  $hsOrderInput: SortDirection
  type: 'string'
  kind: typeof ImageFileKind
}
export declare const ImageFileKind: unique symbol
declare type ImageFileInput = string | StorageImageFile
export interface HsVideoFile extends HsUnionable, HsCommonOptions {
  $static: string
  $hsRuntime: StorageVideoFile
  $hsCreateInput: VideoFileInput
  $hsUpdateInput: VideoFileInput
  $hsFilterInput: VideoFileInput | VideoFileInput[] | SubQueryFilter<string>
  $hsOrderInput: SortDirection
  type: 'string'
  kind: typeof VideoFileKind
}
export declare const VideoFileKind: unique symbol
declare type VideoFileInput = string | StorageVideoFile
export interface HsAudioFile extends HsUnionable, HsCommonOptions {
  $static: string
  $hsRuntime: StorageAudioFile
  $hsCreateInput: AudioFileInput
  $hsUpdateInput: AudioFileInput
  $hsFilterInput: AudioFileInput | AudioFileInput[] | SubQueryFilter<string>
  $hsOrderInput: SortDirection
  type: 'string'
  kind: typeof AudioFileKind
}
export declare const AudioFileKind: unique symbol
declare type AudioFileInput = string | StorageAudioFile
export interface HsGenericLink extends HsUnionable, HsLinkOptions {
  $static: [HeapObjectType, HeapId]
  $hsRuntime: BaseGenericLink
  $hsCreateInput: GenericLinkInput
  $hsUpdateInput: GenericLinkInput
  $hsFilterInput: GenericLinkFilterInput | GenericLinkFilterInput[] | GenericLinkTypeFilter | SubQueryFilter<string>
  $hsOrderInput:
    | SortDirection
    | {
        type: SortDirection
      }
    | {
        0: SortDirection
      }
    | {
        id: SortDirection
      }
    | {
        1: SortDirection
      }
  type: 'array'
  kind: typeof GenericLinkKind
}
export declare const GenericLinkKind: unique symbol
declare type GenericLinkInput = BaseGenericLink | GenericLinkInputJson
export declare type GenericLinkInputJson = HeapObjectCoord | GenericLinkJson
declare type GenericLinkFilterInput = string | GenericLinkInput
export declare type GenericLinkTypeFilter = {
  type: HeapObjectType | HeapObjectType[] | CommonOperator<HsString> | SubQueryFilter<string>
}
export interface HsLinkOptions extends HsCommonOptions {
  /**
   * Defines behaviour of link consistency checking when the record is deleted
   *  - restrict - doesn't allow to delete a record if there are existing links pointing to that record
   *  - none     - always allow deleting, ignore existing links
   * Default is `restrict`
   * `set-null` and `cascade` options are quite complicated and not yet supported
   */
  readonly onDelete: 'restrict' | 'none'
}
export interface HsInteger extends HsUnionable, HsNumberOptions {
  $static: number
  $hsRuntime: number
  $hsCreateInput: number
  $hsUpdateInput: number
  $hsFilterInput: ComparableFilter<number> | SubQueryFilter<number>
  kind: typeof tb.IntegerKind
  type: 'integer'
}
export interface HsFunctionRouteRef<B, R>
  extends HsUnionable,
    Omit<tb.TTuple<[HsNumber, HsString, HsString]>, 'kind' | 'default'>,
    HsCommonOptions {
  $static: [number, string, string]
  $hsRuntime: FunctionRouteRef<B, R>
  $hsCreateInput: FunctionRouteRef<B, R>
  $hsUpdateInput: FunctionRouteRef<B, R>
  $hsFilterInput: FunctionRouteRef<B, R>
  $hsOrderInput: SortDirection
  kind: typeof FunctionRouteRefKind
  body: HeapSchema
  result: HeapSchema
}
export declare const FunctionRouteRefKind: unique symbol
export interface HsIntersect<T extends readonly HeapSchema[]>
  extends HsUnionable,
    HsIntersectable,
    HsIntersectOptions<T> {
  $static: tb.StaticIntersect<T>
  $hsRuntime: HsRuntimeIntersect<T>
  $hsCreateInput: HsCreateInputIntersect<T>
  $hsUpdateInput: HsUpdateInputIntersect<T>
  $hsFilterInput: HsFilterInputIntersect<T> | HsHasOperator<string>
  $hsOrderInput: HsOrderInputIntersect<T>
  kind: typeof tb.IntersectKind
  type: 'object'
  allOf: T
}
export interface HsJobRouteRef<B>
  extends HsUnionable,
    Omit<tb.TTuple<[HsNumber, HsString, HsString]>, 'kind' | 'default'>,
    HsCommonOptions {
  $static: [number, string, string]
  $hsRuntime: JobRouteRef<B>
  $hsCreateInput: JobRouteRef<B>
  $hsUpdateInput: JobRouteRef<B>
  $hsFilterInput: JobRouteRef<B>
  $hsOrderInput: SortDirection
  kind: typeof JobRouteRefKind
  body: HeapSchema
}
export declare const JobRouteRefKind: unique symbol
export declare type HsIntersectOptions<T extends readonly HeapSchema[]> = HsOptionsWithDefault<tb.StaticIntersect<T>>
export declare type HsRuntimeIntersect<T extends readonly HeapSchema[]> = tb.StaticIntersectReduce<
  unknown,
  HsRuntimeIntersectEvaluate<T>
>
export declare type HsRuntimeIntersectEvaluate<T extends readonly HeapSchema[]> = {
  [K in keyof T]: T[K] extends HeapSchema ? HsRuntime<T[K]> : never
}
export declare type HsCreateInputIntersect<T extends readonly HeapSchema[]> = tb.StaticIntersectReduce<
  unknown,
  HsCreateInputIntersectEvaluate<T>
>
export declare type HsCreateInputIntersectEvaluate<T extends readonly HeapSchema[]> = {
  [K in keyof T]: T[K] extends HeapSchema ? HsCreateInput<T[K]> : never
}
export declare type HsUpdateInputIntersect<T extends readonly HeapSchema[]> = tb.StaticIntersectReduce<
  unknown,
  HsUpdateInputIntersectEvaluate<T>
>
export declare type HsUpdateInputIntersectEvaluate<T extends readonly HeapSchema[]> = {
  [K in keyof T]: T[K] extends HeapSchema ? HsUpdateInput<T[K]> : never
}
export declare type HsFilterInputIntersect<T extends readonly HeapSchema[]> = tb.StaticIntersectReduce<
  unknown,
  HsFilterInputIntersectEvaluate<T>
>
export declare type HsFilterInputIntersectEvaluate<T extends readonly HeapSchema[]> = {
  [K in keyof T]?: T[K] extends HeapSchema ? HsFilterRighthand<T[K]> : never
}
export declare type HsOrderInputIntersect<T extends readonly HeapSchema[]> = tb.StaticIntersectReduce<
  unknown,
  HsOrderInputIntersectEvaluate<T>
>
export declare type HsOrderInputIntersectEvaluate<T extends readonly HeapSchema[]> = {
  [K in keyof T]?: HsOrderInput<T[K]>
}
export interface HsKeyOf<T extends tb.TKey[]> extends HsUnionable, HsOptionsWithDefault<tb.StaticKeyOf<T>> {
  $static: tb.StaticKeyOf<T>
  $hsRuntime: tb.StaticKeyOf<T>
  $hsCreateInput: tb.StaticKeyOf<T>
  $hsUpdateInput: tb.StaticKeyOf<T>
  $hsFilterInput: ComparableFilter<tb.StaticKeyOf<T>> | HsIlikeOperator<tb.StaticKeyOf<T>> | SubQueryFilter<string>
  $hsOrderInput: SortDirection
  kind: typeof tb.KeyOfKind
  type: 'string'
  enum: T
}
export declare type SelectablePropertyKeys<T extends Selectable> = T extends HsObject<infer U> ? keyof U : never
export declare type SelectableProperties<T extends Selectable> = T extends HsObject<infer U> ? U : never
export declare type Selectable = HsObject<HsProperties>
export interface HsLiteral<T extends tb.TValue> extends HsUnionable, HsSearchableOptions {
  $static: tb.StaticLiteral<T>
  $hsRuntime: tb.StaticLiteral<T>
  $hsCreateInput: tb.StaticLiteral<T>
  $hsUpdateInput: tb.StaticLiteral<T>
  $hsFilterInput: ComparableFilter<tb.StaticLiteral<T>> | SubQueryFilter<T>
  $hsOrderInput: SortDirection
  kind: typeof tb.LiteralKind
  const: T
  type: 'string' | 'number' | 'boolean'
}
export interface HsMoney
  extends HsUnionable,
    Omit<tb.TTuple<[HsNumber, HsString]>, 'kind' | 'default'>,
    HsMoneyOptions {
  $static: [number, Currency]
  $hsRuntime: Money
  $hsCreateInput: [number, Currency] | Money
  $hsUpdateInput: [number, Currency] | Money
  $hsFilterInput:
    | [number, Currency]
    | Money
    | 0
    | HsCompareOperators<[number, Currency] | Money | 0>
    | SubQueryFilter<[number, Currency]>
    | {
        amount: ComparableFilter<number> | CommonOperator<HsNumber> | SubQueryFilter<number>
        currency?:
          | Currency
          | Currency[]
          | CommonOperator<HsLiteral<Currency>>
          | CommonOperator<HsArray<HsLiteral<Currency>>>
          | SubQueryFilter<string>
      }
    | {
        amount?: ComparableFilter<number> | CommonOperator<HsNumber> | SubQueryFilter<number>
        currency:
          | Currency
          | Currency[]
          | CommonOperator<HsLiteral<Currency>>
          | CommonOperator<HsArray<HsLiteral<Currency>>>
          | SubQueryFilter<string>
      }
  $hsOrderInput:
    | SortDirection
    | {
        amount: SortDirection
      }
    | {
        0: SortDirection
      }
    | {
        currency: SortDirection
      }
    | {
        1: SortDirection
      }
  kind: typeof MoneyKind
}
export declare const MoneyKind: unique symbol
export interface HsMoneyOptions extends HsOptionsWithDefault<[number, Currency]> {}
export interface HsNull extends HsUnionable, HsCommonOptions {
  $static: null
  $hsRuntime: null
  $hsCreateInput: null
  $hsUpdateInput: null
  $hsFilterInput: null
  $hsOrderInput: never
  kind: typeof tb.NullKind
  type: 'null'
}
/**
 * Modifies the given non-optional field schema so that it's allowed to be omitted during object creation
 *  by providing the default value.
 */
export declare type HsNonRequired<T extends HeapSchema> = T & {
  readonly modifier: typeof NonRequiredModifier
  readonly default: NoUndefined<tb.Static<T>>
}
export declare const NonRequiredModifier: unique symbol
export declare type NoUndefined<T> = T extends undefined ? never : T
export interface HsNumber extends HsUnionable, HsNumberOptions {
  $static: number
  $hsRuntime: number
  $hsCreateInput: number
  $hsUpdateInput: number
  $hsFilterInput: ComparableFilter<number> | SubQueryFilter<number>
  $hsOrderInput: SortDirection
  kind: typeof tb.NumberKind
  type: 'number'
}
export declare type HsNumberOptions = Pick<
  tb.NumberOptions,
  'exclusiveMinimum' | 'exclusiveMaximum' | 'minimum' | 'maximum' | 'multipleOf'
> &
  HsOptionsWithDefault<number>
export interface HsObject<T extends HsProperties> extends HsUnionable, HsIntersectable, HsObjectOptions<T> {
  $static: tb.StaticObject<T>
  $hsRuntime: HsRuntimeObject<T>
  $hsCreateInput: HsCreateInputObject<T>
  $hsUpdateInput: HsUpdateInputObject<T>
  $hsFilterInput: HsFilterInputObject<T>
  $hsOrderInput: HsOrderInputObject<T>
  kind: typeof tb.ObjectKind
  type: 'object'
  properties: T
  required?: string[]
}
export interface HsObjectOptions<T extends HsProperties> extends HsOptionsWithDefault<tb.StaticObject<T>> {
  additionalProperties?: boolean
}
export declare type HsProperties = Record<Exclude<string, keyof HeapObjectBaseSchema>, HeapSchema>
/** Record restricted to value types that can be properly serialized to simple string (not meaning JSON.stringify) */
export declare type HsStringFriendlyProperties = Record<Exclude<string, keyof HeapObjectBaseSchema>, HsStringFriendly>
export declare type HsStringFriendly =
  | HsString
  | HsNumber
  | HsInteger
  | HsBoolean
  | HsFile
  | HsAudioFile
  | HsImageFile
  | HsVideoFile
  | HsDateTime
  | HsUnion<HsLiteral<string | number | boolean>[]>
  | HsEnum<tb.TEnumKey[]>
export declare type HsProperty<T extends HsProperties> = keyof T & string
/**
 * Type-level restriction to start field names with '$' symbol
 */
export declare type HsPropertiesNo$<T extends HsProperties> = {
  [K in keyof T]: K extends `$${string}` ? never : T[K]
}
export declare type HsRuntimeObject<T extends HsProperties> = HsRuntimeProperties<T> extends infer I
  ? {
      [K in keyof I]: I[K]
    }
  : never
export declare type HsRuntimeProperties<T extends HsProperties> = {
  readonly [K in tb.StaticReadonlyOptionalPropertyKeys<T>]?: HsRuntime<T[K]>
} & {
  readonly [K in tb.StaticReadonlyPropertyKeys<T>]: HsRuntime<T[K]>
} & {
  [K in tb.StaticOptionalPropertyKeys<T>]?: HsRuntime<T[K]>
} & {
  [K in tb.StaticRequiredPropertyKeys<T>]: HsRuntime<T[K]>
}
export declare type HsCreateInputObject<T extends HsProperties> = HsCreateInputRuntimeProperties<T> extends infer I
  ? {
      [K in keyof I]: I[K]
    }
  : never
declare type HsCreateInputRuntimeProperties<T extends HsProperties> = {
  [K in tb.StaticOptionalPropertyKeys<T>]?: HsCreateInput<T[K]> | null
} & {
  [K in StaticNonRequiredPropertyKeys<T>]?: HsCreateInput<T[K]>
} & {
  [K in CreateStaticRequiredPropertyKeys<T>]: HsCreateInput<T[K]>
}
declare type CreateStaticRequiredPropertyKeys<T extends HsProperties> = keyof Omit<
  T,
  tb.StaticOptionalPropertyKeys<T> | StaticNonRequiredPropertyKeys<T>
>
declare type StaticNonRequiredPropertyKeys<T extends HsProperties> = {
  [K in keyof T]: T[K] extends HsNonRequired<HeapSchema> ? K : never
}[keyof T]
/**
 * Similar to create input but doesn't allow omitting NonRequired modified fields
 */
export declare type HsUpdateInputObject<T extends HsProperties> = HsUpdateInputRuntimeProperties<T> extends infer I
  ? {
      [K in keyof I]: I[K]
    }
  : never
declare type HsUpdateInputRuntimeProperties<T extends HsProperties> = {
  [K in tb.StaticOptionalPropertyKeys<T>]?: HsUpdateInput<T[K]> | null
} & {
  [K in tb.StaticRequiredPropertyKeys<T>]: HsUpdateInput<T[K]>
}
export declare type HsOptional<T extends HeapSchema> = T & {
  modifier: typeof tb.OptionalModifier
}
export declare type StaticPartial<T extends HsProperties> = {
  [K in keyof T]: T[K] extends HsOptional<infer U> ? HsOptional<U> : HsOptional<T[K]>
}
export declare type StaticRequired<T extends HsProperties> = {
  [K in keyof T]: T[K] extends HsOptional<infer U> ? U : T[K]
}
export declare type HsFilterInputObject<T extends HsProperties> = {
  [K in keyof T]?: HsFilterRighthand<T[K]>
}
export declare type HsOrderInputObject<T extends HsProperties> = {
  [K in keyof T]?: HsOrderInput<T[K]>
}
export interface HsRecord<K extends HsRecordKey, T extends HeapSchema>
  extends HsUnionable,
    HsIntersectable,
    HsOptionsWithDefault<tb.StaticRecord<K, T>> {
  $static: tb.StaticRecord<K, T>
  $hsRuntime: HsRuntimeRecord<K, T>
  $hsCreateInput: HsCreateInputRecord<K, T>
  $hsUpdateInput: HsUpdateInputRecord<K, T>
  $hsFilterInput: HsFilterInputRecord<K, T> | HsHasOperator<K['$static']>
  $hsOrderInput: HsOrderInputRecord<K, T>
  kind: typeof tb.RecordKind
  type: 'object'
  patternProperties: {
    [pattern: string]: T
  }
}
export declare type HsRecordKey = HsString | HsNumber | HsKeyOf<any> | HsUnion<any>
export declare type HsRuntimeRecord<K extends HsRecordKey, T extends HeapSchema> = K extends HsString
  ? Record<string, HsRuntime<T>>
  : K extends HsNumber
  ? Record<number, HsRuntime<T>>
  : K extends HsKeyOf<tb.TKey[]>
  ? Record<K['$static'], HsRuntime<T>>
  : K extends HsUnion<HsUnionable[]>
  ? Record<K['$static'], HsRuntime<T>>
  : never
export declare type HsCreateInputRecord<K extends HsRecordKey, T extends HeapSchema> = K extends HsString
  ? Record<string, HsCreateInput<T>>
  : K extends HsNumber
  ? Record<number, HsCreateInput<T>>
  : K extends HsKeyOf<tb.TKey[]>
  ? Record<K['$static'], HsCreateInput<T>>
  : K extends HsUnion<HsUnionable[]>
  ? Record<K['$static'], HsCreateInput<T>>
  : never
export declare type HsUpdateInputRecord<K extends HsRecordKey, T extends HeapSchema> = K extends HsString
  ? Record<string, HsUpdateInput<T>>
  : K extends HsNumber
  ? Record<number, HsUpdateInput<T>>
  : K extends HsKeyOf<tb.TKey[]>
  ? Record<K['$static'], HsUpdateInput<T>>
  : K extends HsUnion<HsUnionable[]>
  ? Record<K['$static'], HsUpdateInput<T>>
  : never
export declare type HsFilterInputRecord<K extends HsRecordKey, T extends HeapSchema> = K extends HsString
  ? Record<string, HsFilterRighthand<T>>
  : K extends HsNumber
  ? Record<number, HsFilterRighthand<T>>
  : K extends HsKeyOf<tb.TKey[]>
  ? Partial<Record<K['$static'], HsFilterRighthand<T>>>
  : K extends HsUnion<HsUnionable[]>
  ? Partial<Record<K['$static'], HsFilterRighthand<T>>>
  : never
export declare type HsOrderInputRecord<K extends HsRecordKey, T extends HeapSchema> = K extends HsString
  ? Record<string, HsOrderInput<T>>
  : K extends HsNumber
  ? Record<number, HsOrderInput<T>>
  : K extends HsKeyOf<tb.TKey[]>
  ? Partial<Record<K['$static'], HsOrderInput<T>>>
  : K extends HsUnion<HsUnionable[]>
  ? Partial<Record<K['$static'], HsOrderInput<T>>>
  : never
export interface HsRefLink<T extends object> extends HsUnionable, HsLinkOptions {
  readonly $static: string
  readonly $hsRuntime: BaseRefLink<T>
  readonly $hsCreateInput: RefLinkInput<T>
  readonly $hsUpdateInput: RefLinkInput<T>
  readonly $hsFilterInput: RefLinkInput<T> | RefLinkInput<T>[] | SubQueryFilter<string>
  readonly $hsOrderInput: SortDirection
  readonly type: 'string'
  readonly kind: typeof RefLinkKind
  readonly targetType: HeapObjectType | UgcSystemHeapTableName
  readonly targetRepoOrTableName?: ReadOnlyHeapTableRepo<HsProperties, unknown, unknown> | string
  readonly isSystemTarget: boolean
}
export declare const RefLinkKind: unique symbol
declare type RefLinkInput<T extends object> = string | BaseRefLink<T> | HeapObjectBase | UgcSmartUser
export interface HsString<S extends string = string> extends HsUnionable, HsStringOptions {
  $static: S
  $hsRuntime: S
  $hsCreateInput: S
  $hsUpdateInput: S
  $hsFilterInput: ComparableFilter<S> | HsIlikeOperator<S> | SubQueryFilter<string>
  readonly $hsOrderInput: SortDirection
  kind: typeof tb.StringKind
  type: 'string'
}
export declare type HsStringOptions = Pick<
  tb.StringOptions<'date-time' | 'email'>,
  'format' | 'minLength' | 'maxLength' | 'pattern'
> &
  HsOptionsWithDefault<string>
export interface HsTuple<T extends HeapSchema[]> extends HsUnionable, HsOptionsWithDefault<tb.StaticTuple<T>> {
  $static: tb.StaticTuple<T>
  $hsRuntime: HsRuntimeTuple<T>
  $hsCreateInput: HsCreateInputTuple<T>
  $hsUpdateInput: HsUpdateInputTuple<T>
  $hsFilterInput: HsFilterInputTupleArray<T> | HsFilterInputTupleByKey<T> | SubQueryFilter<tb.StaticTuple<T>>
  $hsOrderInput: HsOrderInputTupleArray<T> | HsOrderInputTupleByKey<T>
  kind: typeof tb.TupleKind
  type: 'array'
  items?: T
  additionalItems?: false
  minItems: number
  maxItems: number
}
export declare type HsRuntimeTuple<T extends readonly HeapSchema[]> = {
  [K in keyof T]: T[K] extends HeapSchema ? HsRuntime<T[K]> : never
}
export declare type HsCreateInputTuple<T extends readonly HeapSchema[]> = {
  [K in keyof T]: T[K] extends HeapSchema ? HsCreateInput<T[K]> : never
}
export declare type HsUpdateInputTuple<T extends readonly HeapSchema[]> = {
  [K in keyof T]: T[K] extends HeapSchema ? HsUpdateInput<T[K]> : never
}
export declare type HsFilterInputTupleArray<T extends readonly HeapSchema[]> = {
  [K in keyof T]: T[K] extends HeapSchema ? HsFilterRighthand<T[K]> | undefined : never
}
export declare type HsFilterInputTupleByKey<T extends readonly HeapSchema[]> = {
  [key: number]: HsFilterInputUnion<T>
}
export declare type HsOrderInputTupleArray<T extends readonly HeapSchema[]> = {
  [K in keyof T]: HsOrderInput<T[K]>
}
export declare type HsOrderInputTupleByKey<T extends readonly HeapSchema[]> = {
  [key: number]: HsOrderInputUnion<T>
}
export interface HsUndefined extends HsUnionable, HsCommonOptions {
  $static: undefined
  $hsRuntime: undefined
  $hsCreateInput: undefined
  $hsUpdateInput: undefined
  $hsFilterInput: never
  $hsOrderInput: never
  kind: typeof tb.UndefinedKind
  type: 'undefined'
}
export interface HsUnknown extends HeapSchema, HsOptionsWithDefault<unknown> {
  $static: unknown
  $hsRuntime: unknown
  $hsCreateInput: unknown
  $hsUpdateInput: unknown
  $hsFilterInput: ComparableFilter<unknown> | HsIlikeOperator<string>
  $hsOrderInput: AnyPathOrderInput
  kind: typeof tb.UnknownKind
}
export declare type AnyPathOrderInput =
  | SortDirection
  | {
      [key: string | number]: AnyPathOrderInput
    }
export interface HsUnion<T extends readonly HeapSchema[]> extends HeapSchema, HsOptionsWithDefault<tb.StaticUnion<T>> {
  $static: tb.StaticUnion<T>
  $hsRuntime: HsRuntimeUnion<T>
  $hsCreateInput: HsCreateInputUnion<T>
  $hsUpdateInput: HsUpdateInputUnion<T>
  $hsFilterInput: ComparableFilter<HsFilterInputUnion<T>> | SubQueryFilter<string | number | boolean>
  $hsOrderInput: HsOrderInputUnion<T>
  kind: typeof tb.UnionKind
  anyOf: T
}
export declare type HsOnlyScalarStaticUnion<T extends readonly HeapSchema[]> = {
  [K in keyof T]: OnlyScalar<tb.Static<T[K]>>
}[number]
export declare type OnlyScalar<T> = T extends string | number | boolean | null ? T : never
export declare type HsRuntimeUnion<T extends readonly HeapSchema[]> = {
  [K in keyof T]: T[K] extends HeapSchema ? HsRuntime<T[K]> : never
}[number]
export declare type HsCreateInputUnion<T extends readonly HeapSchema[]> = {
  [K in keyof T]: T[K] extends HeapSchema ? HsCreateInput<T[K]> : never
}[number]
export declare type HsUpdateInputUnion<T extends readonly HeapSchema[]> = {
  [K in keyof T]: T[K] extends HeapSchema ? HsUpdateInput<T[K]> : never
}[number]
export declare type HsFilterInputUnion<T extends readonly HeapSchema[]> = {
  [K in keyof T]: T[K] extends HeapSchema ? HsFilterInput<T[K]> : never
}[number]
export declare type HsOrderInputUnion<T extends readonly HeapSchema[]> = {
  [K in keyof T]: HsOrderInput<T[K]>
}[number]
/**
 * DRY JSON representation of root heap-object described by Heap.Table()
 */
export declare type HsObjectStatic<HSP extends HsProperties> = tb.Static<HsFullObject<HSP>>
export declare type HsFilterbleObjectStatic<HSP extends HsProperties> = tb.Static<HsFullFilterableObject<HSP>>
export declare type HsPropertiesStatic<HSP extends HsProperties> = {
  [K in keyof HSP]: tb.Static<HSP[K]>
}
/**
 * DRY for heap-object full schema (including system heap table fields - id, heapType, createdAt, and so on
 */
export declare type HsFullObject<HSP extends HsProperties> = HsObject<HSP & HeapObjectBaseSchema>
export declare type HsFullObjectRuntime<HSP extends HsProperties> = HsRuntime<HsObject<HSP>> & HeapObjectBase
export declare type HsFullFilterableObject<HSP extends HsProperties> = HsObject<HSP & HeapObjectFilterableSchema>
export declare type HeapObjectBase = HeapObjectBaseRaw & {
  createdBy: BaseRefLink<User2> | null
  updatedBy: BaseRefLink<User2> | null
}
export declare type HeapObjectFilterableSchema = {
  id: HsString
  createdAt: HsDateTime
  updatedAt: HsDateTime
  createdBy: HsUnion<[HsRefLink<User2>, HsNull]>
  updatedBy: HsUnion<[HsRefLink<User2>, HsNull]>
}
export interface HeapObjectBaseSchema extends HeapObjectFilterableSchema {
  heapType: HsString
}
declare type ComparableFilter<T> = T | (T | undefined)[] | HsCompareOperators<T>
declare type SubQueryFilter<V> =
  | {
      $in:
        | Array<V>
        | HeapSelectQueryBuilder<HsProperties, HsProperties, [V | null], any, any>
        | HeapView<HsProperties, [V | null], any>
    }
  | {
      $notIn:
        | Array<V>
        | HeapSelectQueryBuilder<HsProperties, HsProperties, [V | null], any, any>
        | HeapView<HsProperties, [V | null], any>
    }
interface HqlSelectQuery {
  from: HqlFrom
  select: HqlSelect
  distinct?: boolean
  where?: CqlWhere
  group?: CqlSelectAlias[]
  having?: CqlHaving
  order?: HqlOrder
  limit?: number
  offset?: number
  resPlainJson?: boolean
  resTakeFirst?: boolean
}
declare type HqlFrom = HqlTable | HqlSubQuery
declare type HqlTable = {
  kind: 'table'
  heapType: HeapObjectType
}
declare type HqlSubQuery = {
  kind: 'sub'
  query: HqlSelectQuery
}
declare type HqlExpr = HqlField | HqlExprFn | HqlExprAgg | CqlDynParam
declare type HqlField = HqlTableField | HqlSubQueryField
declare type HqlTableField = HqlSystemColumn | HqlDataField
declare type HqlSubQueryField = HqlSubPlainField | HqlSubJsonField
declare type HqlSystemColumn = {
  kind: 'sys'
  name: HqlSystemColumnName
}
declare type HqlSystemColumnName = typeof allowedHqlSystemColumns[number]
declare const allowedHqlSystemColumns: readonly ['id', 'createdAt', 'updatedAt', 'createdBy', 'updatedBy']
declare type HqlDataField = {
  kind: 'data'
  path: string | CqlDeepPath
  type: CqlFieldType
}
declare type HqlSubPlainField = {
  kind: 'subPlain'
  name: string
}
declare type HqlSubJsonField = {
  kind: 'subJson'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type HqlExprFn = {
  kind: 'fn'
  fn: string
  args: Array<HqlExpr>
}
declare type HqlExprAgg = {
  kind: 'agg'
  fn: string
  args: [CqlAsterisk] | Array<CqlDynParam | HqlField | HqlExprFnNoAgg>
  distinct?: boolean
}
declare type HqlExprFnNoAgg = {
  kind: 'fn'
  fn: string
  args: Array<HqlField | HqlExprFnNoAgg | CqlDynParam>
}
declare type HqlSelect = Record<string, HqlExpr>
declare type HqlOrder = HqlSimpleOrderBy | Array<HqlSingleOrderBy>
declare type HqlSingleOrderBy = HqlSimpleOrderBy | [HqlSimpleOrderBy, SortDirection]
declare type HqlSimpleOrderBy =
  | HqlSystemColumnName
  | string
  | HqlDataField
  | HqlSubJsonField
  | HqlOrderAliasField
  | HqlExprFn
declare type HqlOrderAliasField = {
  kind: 'aliasJson'
  path: CqlDeepPath
  type: CqlFieldType
}

export {}
