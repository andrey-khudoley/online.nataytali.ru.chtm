import * as tb from '@sinclair/typebox'
import { Filter, OrderByDefinition, SortDirection } from 'core/db/dbQueryTypes'
import { HeapId, HeapObjectBaseRaw, HeapObjectType, HeapOrderBy } from 'core/heap/heapTypes'
import * as hs from 'core/heap/v2/heapSchemaTypes'
import { ReadOnlyHeapTableRepo } from 'core/heap/v2/HeapTableRepo'
import { Icon } from 'lib/chatium-json/v1'
import { DesktopLayout, PlainIconName } from 'lib/chatium-json/v2'
import { UgcRouteType } from 'services/ugc-runner/runtime/runtimeTypes'
import { AnyObject, FirstElement, JSONInputObject } from 'utils/types'

interface CqlSelectQuery {
  from: CqlFrom
  select: CqlSelect
  distinct?: boolean
  where?: CqlWhere
  having?: CqlHaving
  order?: CqlOrder
  group?: CqlGroup
  limit?: number
  offset?: number
}
declare type CqlFrom = CqlTable | CqlSubQuery
declare type CqlTable = {
  kind: 'table'
  schema: string
  name: string
}
declare type CqlSubQuery = {
  kind: 'sub'
  query: CqlSelectQuery
}
declare type CqlSelect = Record<string, CqlExpr> | undefined
declare type CqlExpr = CqlPlainColumn | CqlExprFn | CqlDynParam | CqlJsonPath | CqlAsterisk
declare type CqlPlainColumn = {
  kind: 'col'
  name: string
  type?: CqlFieldType
}
declare type CqlExprFn = {
  kind: 'fn'
  fn: string
  args: CqlExpr[]
  distinct?: boolean
  type?: CqlFieldType
}
declare type CqlDynParam = {
  kind: 'dyn'
  value: unknown
  type?: CqlFieldType
}
declare type CqlJsonPath = {
  kind: 'json'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type CqlAsterisk = {
  kind: '*'
  type?: undefined
}
declare type CqlFieldType = 'string' | 'number' | 'boolean' | 'date' | 'json'
declare type CqlDeepPath = [string, ...(string | number)[]]
declare type CqlGroup = CqlSelectAlias[]
declare type CqlSelectAlias = string
declare type CqlWhere = Filter<any>
declare type CqlHaving = Filter<any>
declare type CqlOrder = OrderByDefinition<any>
declare type Lang = string
interface LangCtx {
  lang: Lang
}
interface LocationCtx {
  location: Location | undefined
}
interface Location {
  country: string
  region: string
  timeZone: string
  city: string
  coordinates: Coordinates
}
interface Coordinates {
  latitude: number
  longitude: number
}
interface HsPropertiesWithOptions {
  [key: string]: hs.HeapSchema & hs.HsOptionsWithDefault<unknown>
}
declare type BS = hs.HeapSchema
declare type PS = hs.HsObject<hs.HsStringFriendlyProperties> | hs.HsRecord<hs.HsString, hs.HsString | hs.HsNumber>
declare type QS = hs.HsObject<HsPropertiesWithOptions> | hs.HsRecord<hs.HsString, hs.HeapSchema>
declare type RS = hs.HeapSchema
declare type RouteRefGetSchemaFn = (
  codeAccountId: number,
  routerUrlPath: string,
  routePattern: string,
  routeType: UgcRouteType,
) => Promise<RouteRefSchema>
declare type RouteRefSchema = {
  meta?: AnyObject
  bs?: BS
  ps?: PS
  qs?: QS
  rs?: RS
}
declare type TsVectorLangKey = 'ru' | 'en'
declare enum UserRole {
  Admin = 'Admin',
  Staff = 'Staff',
  Support = 'Support',
  ActiveSupport = 'ActiveSupport',
  Developer = 'Developer',
  BetaTester = 'BetaTester',
  User = 'User',
}
declare enum UserStatus {
  Imported = 'Imported',
  Joined = 'Joined',
  AsSupport = 'AsSupport',
  Left = 'Left',
}
declare type PrimaryIdentities = {
  phone?: string
  email?: string
  hasPassword?: boolean
}
declare abstract class SmartUser<Ctx> {
  private ctx
  private coreUser
  private extendedInfo?
  private primaryIdentities?
  protected abstract userApi: SmartUserApi<Ctx>
  protected abstract fileServiceDirectHost: string
  protected abstract fileServiceCdnHost: string
  constructor(
    ctx: LocationCtx,
    coreUser: UgcCtxUser2,
    extendedInfo?: ExtendedUserInfo | undefined,
    primaryIdentities?: PrimaryIdentities | undefined,
  )
  get id(): HeapId
  get type(): User2['type']
  get displayName(): string
  get confirmedPhone(): string | undefined
  get confirmedEmail(): string | undefined
  get accountRole(): AccountRole
  get username(): string | undefined
  get firstName(): string | undefined
  get middleName(): string | undefined
  get lastName(): string | undefined
  get fullName(): string
  get gender(): UserGender | undefined
  get birthdayDate(): Date | undefined
  get birthday(): string | undefined
  get passwordSalt(): string
  get hasPassword(): boolean
  updateAccountRole(ctx: Ctx, newRole: AccountRole): Promise<void>
  updateUsername(ctx: Ctx, username: string): Promise<void>
  updatePassword(ctx: Ctx, password: string): Promise<void>
  updateLang(ctx: Ctx, lang: Lang | null): Promise<void>
  updateExtendedInfo(ctx: Ctx, info: UpdateExtendedUserInfoRaw): Promise<void>
  get smartIconProps(): {
    url?: string
    name?: PlainIconName
    text?: string
  }
  get hasImage(): boolean
  get imageUrl(): string | undefined
  /**
   * Effective image hash XOR url
   * Mainly for copying image data from one user to another
   */
  get rawImageInfo(): {
    imageHash?: string
    imageUrl?: string
  }
  getImageThumbnailUrl(size?: number): string | undefined
  is(role: Exclude<AccountRole, 'None'>): boolean
  get lang(): Lang | undefined
  toJSON(): JSONInputObject
  serialize(): SerializedSmartUser | UgcCtxUser1
  getProfile<T extends JSONInputObject>(): T | undefined
  private get fsHost()
}
declare type SerializedSmartUser = [UgcCtxUser2, ExtendedUserInfo | undefined, PrimaryIdentities | undefined]
interface SmartUserApi<Ctx> {
  updateAccountRole(ctx: Ctx, userId: HeapId, newRole: AccountRole): Promise<AccountRole>
  updateUsername(ctx: Ctx, userId: HeapId, username: string): Promise<string>
  updateExtendedInfo(
    ctx: Ctx,
    userId: HeapId,
    info: UpdateExtendedUserInfo,
  ): Promise<[UgcCtxUser2, ExtendedUserInfo | undefined]>
  updatePassword(ctx: Ctx, userId: HeapId, password: string): Promise<void>
  updateLang(ctx: Ctx, userId: HeapId, lang: Lang | null): Promise<string | undefined>
}
declare type ExtendedUserInfo = ExtendedUserFields & {
  displayName?: string
  profile?: JSONInputObject
}
declare type UpdateExtendedUserInfo = {
  firstName?: string | null
  lastName?: string | null
  middleName?: string | null
  gender?: UserGender | null
  birthday?: string | null
  imageHash?: string | null
  imageUrl?: string | null
}
declare type UpdateExtendedUserInfoRaw = Pick<
  UpdateExtendedUserInfo,
  'firstName' | 'middleName' | 'lastName' | 'gender' | 'imageHash' | 'imageUrl'
> & {
  birthday?: string | Date | null
}
declare type UserGender = 'male' | 'female' | 'other'
declare type HashMediaType = 'file' | 'video' | 'image' | 'audio'
declare abstract class BaseRefLink<T extends object, ReadCtx = unknown> {
  /**
   * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
   *
   * This is technical type, like written to heap-table "type" field,
   *  don't mix up with developer-defined table name provided to Heap.Table.
   * For system ref-links this also contains heap-type ('core.User' instead of 'users').
   */
  readonly type: HeapObjectType
  readonly id: HeapId
  /** Repository (table) that owns the row of this RefLink instance */
  readonly myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>
  /**
   * Repository (table) that owns the row of the target record.
   * Can be passed as table name or as repository instance.
   * When available, used in 'get' method implementation.
   */
  protected targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<hs.HsProperties, unknown, unknown> | undefined
  constructor(
    /**
     * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
     *
     * This is technical type, like written to heap-table "type" field,
     *  don't mix up with developer-defined table name provided to Heap.Table.
     * For system ref-links this also contains heap-type ('core.User' instead of 'users').
     */
    type: HeapObjectType,
    id: HeapId,
    /** Repository (table) that owns the row of this RefLink instance */
    myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>,
    /**
     * Repository (table) that owns the row of the target record.
     * Can be passed as table name or as repository instance.
     * When available, used in 'get' method implementation.
     */
    targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<hs.HsProperties, unknown, unknown> | undefined,
  )
  toJSON(): string
  toString(): string
  get<R = T>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  abstract getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface RefLinkClass {
  new (
    type: HeapObjectType,
    id: HeapId,
    myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>,
    targetRepoOrTableName?: ReadOnlyHeapTableRepo<hs.HsProperties, unknown> | string,
  ): BaseRefLink<AnyObject>
}
declare abstract class BaseGenericLink<ReadCtx = unknown> {
  readonly type: HeapObjectType
  readonly id: HeapId
  readonly myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>;
  [index: number]: HeapObjectType | HeapId
  readonly length = 2
  constructor(type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>)
  get<R = hs.HeapObjectBase>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  /** simulates the serialized format for compatibility */
  [Symbol.iterator](): IterableIterator<HeapObjectType | HeapId>
  toJSON(): GenericLinkJson
  toString(): string
  abstract getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface GenericLinkClass {
  new (type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>): BaseGenericLink
}
declare type GenericLinkJson = [HeapObjectType, HeapId]
declare type User2 = hs.HeapObjectBase & {
  type: 'Anonymous' | 'Real' | 'Bot'
  username?: string
  lang?: Lang
  timeZone?: string
  accountRole: AccountRole
  isBlocked: boolean
  knownChildAccounts?: number[]
} & ExtendedUserFields
declare type ExtendedUserFields = {
  firstName?: string
  lastName?: string
  middleName?: string
  gender?: UserGender
  birthday?: string
  imageHash?: string
  imageUrl?: string
}
declare type AccountRole = typeof validAccountRoles[number]
declare const validAccountRoles: readonly ['None', 'Staff', 'Admin', 'Developer', 'Owner']
interface HeapLink<_HD extends HeapData> {
  type: HeapObjectType
  id: HeapId
}
declare type HeapObjectBaseV1 = HeapObjectBaseRaw & {
  idx: number
  createdBy: HeapLink<UserData> | null
  updatedBy: HeapLink<UserData> | null
}
declare type HeapData = {
  '~~heap~data~tag~~': never
}
declare type EraseHD<HD extends HeapData> = Omit<HD, keyof HeapData>
declare type RefLink<HD extends HeapData> = HD & {
  '~~ref~link~tag~~': never
}
declare type GenericLink = {
  '~~generic~link~tag~~': never
}
declare type HeapObjectV1<HD extends HeapData> = HeapObjectBaseV1 & MapHeapLinks<HD>
declare type MapHeapLinks<HD extends HeapData> = {
  [K in keyof EraseHD<HD>]: LinksMap<HD[K]>
}
declare type LinksMap<T> = T extends null
  ? null
  : T extends GenericLink
  ? HeapId
  : T extends RefLink<HeapData>
  ? HeapLink<T>
  : T
interface PurchasedProducts {
  [productName: string]: string | true | undefined
}
interface UserData extends HeapData {
  authId: number
  roles: UserRole[]
  status: UserStatus
  expiresAt: string | null
  avatar: Icon
  firstName: string | null
  lastName: string | null
  phone: string | null
  email: string | null
  platforms: EnvPlatform[]
  purchasedProducts: PurchasedProducts
}
declare type User1 = HeapObjectV1<UserData>
declare type UgcFileStorage = 'cgs' | 'db'
declare type CgsRepoVersion = string
declare type UgcCodeVersion = CgsRepoVersion
declare type UgcCtxUser1 = Pick<
  User1,
  'id' | 'firstName' | 'lastName' | 'roles' | 'avatar' | 'purchasedProducts' | 'phone' | 'email'
>
declare type UgcCtxUser2 = Pick<
  User2,
  | 'id'
  | 'type'
  | 'accountRole'
  | 'username'
  | 'firstName'
  | 'lastName'
  | 'middleName'
  | 'gender'
  | 'birthday'
  | 'imageHash'
  | 'imageUrl'
  | 'lang'
>
interface EnvAvc {
  id: string
  signature: string
  accMap: Record<
    /** base account ID */
    number,
    [
      /** branch account ID */
      number,
      UgcFileStorage,
      UgcCodeVersion | null,
      /** expiration timestamp in seconds */
      number,
    ]
  >
}
interface OptionalEnvCtx {
  env: Env | null
}
interface Env {
  development: boolean
  production: boolean
  platform: EnvPlatform
  version: number
  appBuildNumber?: number
  ios: boolean
  android: boolean
  web: boolean
  job: boolean
  debugSocketId: string | null
  usePreviewMode: boolean
  useScopedPreviewMode: null | Record<string, boolean | null | undefined>
  viewportWidth: number | null
  viewportHeight: number | null
  devicePixelRatio: number
  alwaysHeader: boolean
  clientScope?: 'modal' | 'desktop' | 'ide'
  desktopLayout?: DesktopLayout
  acceptChatiumJson: boolean
  client?: ClientInfo
  avc?: EnvAvc
}
declare const EnvPlatform: {
  readonly iOS: 'iOS'
  readonly Android: 'Android'
  readonly Web: 'Web'
  readonly Job: 'Job'
}
declare type EnvPlatform = keyof typeof EnvPlatform
interface ClientInfo {
  ip: string
  deviceName: string
  osName: string
}
declare type HsSelectOptions<HSP extends hs.HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  limit?: number | null | undefined
  offset?: number | null | undefined
  order?: HsOrderBy<HSP> | null | undefined
}
declare type HsOrderBy<HSP extends hs.HsProperties> = HsSingleOrderBy<HSP> | Array<HsSingleOrderBy<HSP>>
declare type HsSingleOrderBy<HSP extends hs.HsProperties> = (keyof HSP & string) | hs.HsOrderInputObject<HSP>
declare type HsTableSelectOptions<HSP extends hs.HsProperties> = Pick<
  HsSelectOptions<HSP & hs.HeapObjectFilterableSchema>,
  'where' | 'limit' | 'offset'
> & {
  order?: HeapOrderBy<HSP> | null | undefined
}
declare type HsTableSearchByOptions<HSP extends hs.HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  query: string
  embeddingsQuery?: string
  limit?: number
}
declare type HsFilter<HSP extends hs.HsProperties> =
  | hs.HsFilterInputObject<HSP>
  | HsTopAndOperator<HSP>
  | HsTopOrOperator<HSP>
  | HsTopNotOperator<HSP>
  | HsNoopOperator
declare type HsTableFilter<HSP extends hs.HsProperties> = HsFilter<HSP & hs.HeapObjectFilterableSchema>
declare type HsTopAndOperator<HSP extends hs.HsProperties> = {
  $and: Array<HsFilter<HSP>>
}
declare type HsTopOrOperator<HSP extends hs.HsProperties> = {
  $or: Array<HsFilter<HSP>>
}
declare type HsTopNotOperator<HSP extends hs.HsProperties> = {
  $not: HsFilter<HSP>
}
declare type HsFilterRighthand<HS extends hs.HeapSchema> = null | HsFilterRighthandNonNull<HS>
declare type HsFilterRighthandNonNull<HS extends hs.HeapSchema> = hs.HsFilterInput<HS> | CommonOperator<HS>
declare type CommonOperator<HS extends hs.HeapSchema> =
  | HsAndOperator<HS>
  | HsNoopOperator
  | HsNotOperator<HS>
  | HsOrOperator<HS>
declare type HsNoopOperator = {
  $noop: true | 1 | '1' | 'true' | 'yes'
}
declare type HsNotOperator<HS extends hs.HeapSchema> = {
  $not: HsFilterRighthand<HS>
}
declare type HsAndOperator<HS extends hs.HeapSchema> = {
  $and: Array<HsFilterRighthand<HS>>
}
declare type HsOrOperator<HS extends hs.HeapSchema> = {
  $or: Array<HsFilterRighthand<HS>>
}
declare type HsCompareOperators<V> = HsGtOperator<V> | HsGteOperator<V> | HsLtOperator<V> | HsLteOperator<V>
declare type HsGtOperator<V> = {
  $gt: V
}
declare type HsGteOperator<V> = {
  $gte: V
}
declare type HsLtOperator<V> = {
  $lt: V
}
declare type HsLteOperator<V> = {
  $lte: V
}
declare type HsIlikeOperator<V> = V extends string
  ? {
      $ilike: string
    }
  : never
declare type HsHasOperator<V> = V extends null | unknown[] | object
  ? never
  : [
      {
        $has: V
      },
    ]
declare type HsIncludesOperator<V> = {
  $includes:
    | V
    | {
        $any: V[]
      }
    | {
        $all: V[]
      }
}
/**
 * Heap's SELECT query builder interface
 * TB - source table (or view) schema type
 * O - output schema type, inferred from select clause
 * OT - output tuple type, needed for correct `IN SELECT` sub-query type checking,
 *      for example, if O is `{ id: HsNumber, name: HsString }` then OT is `[number, string]`
 * NAC - non-aggregate column aliases union, helps to type-check 'group by' arguments
 */
export interface HeapSelectQueryBuilder<TB extends hs.HsProperties, O extends hs.HsProperties, OT, NAC, ReadCtx> {
  readonly OT: OT
  distinct(distinct?: boolean): HeapSelectQueryBuilder<TB, O, OT, NAC, ReadCtx>
  where(filter: HsFilter<Omit<TB, keyof O> & O> | null | undefined): HeapSelectQueryBuilder<TB, O, OT, NAC, ReadCtx>
  group(...group: NAC[]): HeapSelectQueryBuilder<TB, O, OT, NAC, ReadCtx>
  group(group: NAC[] | null | undefined): HeapSelectQueryBuilder<TB, O, OT, NAC, ReadCtx>
  autoGroup(): HeapSelectQueryBuilder<TB, O, OT, NAC, ReadCtx>
  having(filter: HsFilter<O> | null | undefined): HeapSelectQueryBuilder<TB, O, OT, NAC, ReadCtx>
  order(order: HsOrderBy<Omit<TB, keyof O> & O> | null | undefined): HeapSelectQueryBuilder<TB, O, OT, NAC, ReadCtx>
  limit(limit: number | null): HeapSelectQueryBuilder<TB, O, OT, NAC, ReadCtx>
  offset(offset: number | null): HeapSelectQueryBuilder<TB, O, OT, NAC, ReadCtx>
  run(ctx: ReadCtx): Promise<hs.HsRuntime<hs.HsObject<O>>[]>
  runTakeFirst(ctx: ReadCtx): Promise<hs.HsRuntime<hs.HsObject<O>> | null>
  runTakeFirstOrThrow(ctx: ReadCtx): Promise<hs.HsRuntime<hs.HsObject<O>>>
  runFlatten(ctx: ReadCtx): Promise<FirstElement<HqRuntimeTupleForSchema<TB>>[]>
  runFlattenTakeFirstOrThrow(ctx: ReadCtx): Promise<FirstElement<HqRuntimeTupleForSchema<TB>>>
  runJson(ctx: ReadCtx): Promise<tb.Static<hs.HsObject<O>>[]>
  runTakeFirstJson(ctx: ReadCtx): Promise<tb.Static<hs.HsObject<O>> | null>
  runTakeFirstOrThrowJson(ctx: ReadCtx): Promise<tb.Static<hs.HsObject<O>>>
  runFlattenJson(ctx: ReadCtx): Promise<FirstElement<OT>[]>
  runFlattenTakeFirstOrThrowJson(ctx: ReadCtx): Promise<FirstElement<OT>>
  asView(): HeapView<O, OT, ReadCtx>
}
/**
 * Interface for "stored" heap query - VIEW.
 * HSP - heap-schema of the view.
 * OT - output tuple type, needed for correct `IN SELECT` sub-query type checking.
 */
export interface HeapView<HSP extends hs.HsProperties, OT, ReadCtx> {
  readonly schema: hs.HsObject<HSP>
  readonly T: hs.HsRuntime<hs.HsObject<HSP>>
  readonly OT: OT
  select<SE extends HqSelectClause<HSP>>(
    selections: Deny$StartingKeys<SE>,
  ): HeapSelectQueryBuilder<
    HSP,
    HqOutputSchemaProps<HSP, SE>,
    HqOutputTuple<HSP, SE>,
    HqNonAggregateColumnName<HSP, SE>,
    ReadCtx
  >
  select<ColNames extends Array<HqExprColumn<HSP, hs.HeapSchema>>>(
    ...colNames: ColNames
  ): HeapSelectQueryBuilder<
    HSP,
    HqOutputSchemaForColNames<HSP, ColNames>,
    HqOutputTupleForColNames<HSP, ColNames>,
    ColNames[number],
    ReadCtx
  >
  selectAll(): HeapSelectQueryBuilder<HSP, HSP, HqTupleForSchema<HSP>, Array<keyof HSP>, ReadCtx>
  findAll(ctx: ReadCtx, options?: HsSelectOptions<HSP>): Promise<this['T'][]>
  findBy(ctx: ReadCtx, filter?: HsFilter<HSP> | null): Promise<this['T'][]>
  findOneBy(ctx: ReadCtx, filter?: HsFilter<HSP> | null): Promise<this['T'] | null>
  countBy(ctx: ReadCtx, filter?: HsFilter<HSP> | null): Promise<number>
}
export declare type HqSelectClause<TB extends hs.HsProperties> = Record<string, HqExpr<TB, hs.HeapSchema>>
/**
 * Creates a select clause for all fields that the given schema has
 */
export declare type HqSelectAll<HSP extends hs.HsProperties> = {
  [K in keyof HSP]: K
}
export declare type Deny$StartingKeys<SE> = SE extends {
  [K in keyof SE]: K extends `$${string}` ? never : SE[K]
}
  ? SE
  : never
/**
 * All possible expression types for the given TB table schema and O output type of the expression.
 */
export declare type HqExpr<TB extends hs.HsProperties, O extends hs.HeapSchema> =
  | HqExprColumn<TB, O>
  | HqExprPath<TB, O>
  | HqExprFn<TB, O>
  | HqExprAgg<TB, O>
  | HqExprDyn<O>
/**
 * Tuple type for the given select clause on the given heap table.
 */
export declare type HqOutputTuple<TB extends hs.HsProperties, SE extends HqSelectClause<TB>> = HqTupleForSchema<
  HqOutputSchemaProps<TB, SE>
>
export declare type HqOutputTupleForColNames<
  HSP extends hs.HsProperties,
  ColNames extends ReadonlyArray<HqExprColumn<HSP, hs.HeapSchema>>,
> = {
  [K in keyof ColNames]: tb.Static<HsOptionalToNullable<HSP[ColNames[K]]>>
}
/**
 * Tuple type for the given heap table schema
 */
export declare type HqTupleForSchema<HSP extends hs.HsProperties> = HqTupleForSchema0<HSP> extends infer I
  ? {
      [K in keyof I]: I[K]
    }
  : never
declare type HqTupleForSchema0<HSP extends hs.HsProperties> = [ObjValuesUnion<hs.HsPropertiesStatic<HSP>>]
declare type ObjValuesUnion<T> = {
  [K in keyof T]: T[K]
}[keyof T]
export declare type HqRuntimeTupleForSchema<HSP extends hs.HsProperties> = HqRuntimeTupleForSchema0<HSP> extends infer I
  ? {
      [K in keyof I]: I[K]
    }
  : never
declare type HqRuntimeTupleForSchema0<HSP extends hs.HsProperties> = ObjValueTuple<hs.HsRuntimeObject<HSP>>
declare type ObjValueTuple<T, KS extends any[] = TuplifyUnion<keyof T>, R extends any[] = []> = KS extends [
  infer K,
  ...infer KT
]
  ? ObjValueTuple<T, KT, [...R, T[K & keyof T]]>
  : R
declare type TuplifyUnion<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N
  ? []
  : Push<TuplifyUnion<Exclude<T, L>>, L>
declare type LastOf<T> = UnionToIntersection<T extends any ? () => T : never> extends () => infer R ? R : never
declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never
declare type Push<T extends any[], V> = [...T, V]
export declare type HqNonAggregateColumnName<HSP extends hs.HsProperties, SE extends HqSelectClause<HSP>> = {
  [K in keyof SE]: SE[K] extends HqExprAgg<HSP, hs.HeapSchema> ? never : K
}[keyof SE]
/**
 * Properties schema of the output object for the SELECT query to the TB table schema with SE select clause.
 * This two-step trick with infer I helps to simplify resulting type representation in IDEs.
 */
export declare type HqOutputSchemaProps<
  TB extends hs.HsProperties,
  SE extends HqSelectClause<TB>,
> = HqOutputSchemaProps0<TB, SE> extends infer I
  ? {
      [K in keyof I]: I[K]
    }
  : never
/**
 * Also fail the whole result if any $-starting field is present
 */
export declare type HqOutputSchemaProps0<
  TB extends hs.HsProperties,
  SE extends HqSelectClause<TB>,
> = Deny$StartingKeys<{
  [A in keyof SE]: HsOfHqExpr<TB, SE[A]>
}>
export declare type HqOutputSchemaForColNames<
  HSP extends hs.HsProperties,
  ColNames extends ReadonlyArray<HqExprColumn<HSP, hs.HeapSchema>>,
> = {
  [K in ColNames[number]]: HsOptionalToNullable<HSP[K]>
}
/**
 * Infer HeapSchema type of the expression E.
 */
export declare type HsOfHqExpr<TB extends hs.HsProperties, E extends HqExpr<TB, hs.HeapSchema>> = E extends keyof TB
  ? HsOptionalToNullable<TB[E]>
  : E extends HqExprPath<TB, hs.HeapSchema>
  ? HsOfHqExprPath<TB, E>
  : E extends
      | HqExprFnAbs<TB>
      | HqExprFnCeil<TB>
      | HqExprFnFloor<TB>
      | HqExprFnRound<TB>
      | HqExprFnLength<TB>
      | HqExprAggAvg<TB>
      | HqExprAggCount<TB>
      | HqExprAggSum<TB>
      | HqExprAggMax<TB>
      | HqExprAggMin<TB>
      | HqExprOpAdd<TB>
      | HqExprOpSub<TB>
      | HqExprOpNeg<TB>
      | HqExprOpMul<TB>
      | HqExprOpDiv<TB>
      | HqExprOpMod<TB>
      | HqExprOpPow<TB>
  ? hs.HsNumber
  : E extends HqExprFnConcat<TB> | HqExprAggStringAgg<TB> | HqExprFnLower<TB> | HqExprFnUpper<TB>
  ? hs.HsString
  : E extends HqExprAggBoolAnd<TB> | HqExprAggBoolOr<TB>
  ? hs.HsBoolean
  : E extends HqExprFnNow
  ? hs.HsDateTime
  : E extends HqExprDyn<hs.HeapSchema>
  ? HsOfHqExprDyn<E>
  : never
/**
 * Union of tables schema (TB) field names whose schema types match the given HS type.
 */
export declare type HqExprColumn<TB extends hs.HsProperties, HS extends hs.HeapSchema> = {
  [K in keyof TB]: TB[K] extends HS ? K : never
}[keyof TB] &
  string
/**
 * Path expression for nested fields. Path is an array of field names from root to leaf.
 * Only paths to fields matching the given O type are included.
 */
export declare type HqExprPath<TB extends hs.HsProperties, O extends hs.HeapSchema> = {
  [K in keyof TB]: FilteredPath<TB[K], O, K, HqExprPathForSchema<TB[K], O>>
}[keyof TB]
declare type HqExprPathForSchema<HS extends hs.HeapSchema, O extends hs.HeapSchema> = HS extends hs.HsObject<
  infer Nested
>
  ? HqExprPath<Nested, O>
  : HS extends hs.HsArray<infer Item>
  ? FilteredPath<HS, O, number, HqExprPathForSchema<Item, O>>
  : HS extends hs.HsTuple<infer Items>
  ? HqExprPathTuple<Items, O>
  : HS extends hs.HsRecord<infer Key, infer Value>
  ? FilteredPath<HS, O, Key['$static'], HqExprPathForSchema<Value, O>>
  : HS extends hs.HsUnion<infer Options>
  ? HqExprPathUnion<Options, O>
  : HS extends hs.HsIntersect<infer Options>
  ? HqExprPathUnion<Options, O>
  : HS extends hs.HsMoney
  ? HqExprPathMoney<O>
  : HS extends hs.HsGenericLink
  ? HqExprPathGenericLink<O>
  : HS extends hs.HsAny | hs.HsUnknown
  ? string[]
  : never
declare type FilteredPath<T, O, K, Rest extends unknown[]> =
  | (T extends O ? [K] : never)
  | (Rest extends never ? never : [K, ...Rest])
/**
 * Tuple contributes to a path all its indexes 0..n both in string and numeric forms.
 */
export declare type HqExprPathTuple<T extends readonly hs.HeapSchema[], O extends hs.HeapSchema> = {
  [K in keyof T]: FilteredPath<T[K], O, K | ToNumber<K>, HqExprPathForSchema<T[K], O>>
}[number]
export declare type HqExprPathUnion<T extends readonly hs.HeapSchema[], O extends hs.HeapSchema> = {
  [K in keyof T]: HqExprPathForSchema<T[K], O>
}[number]
export declare type HqExprPathMoney<O extends hs.HeapSchema> =
  | (HsNumeric extends O ? [0 | '0' | 'amount'] : never)
  | (hs.HsString extends O ? [1 | '1' | 'currency'] : never)
export declare type HqExprPathGenericLink<O extends hs.HeapSchema> = hs.HsString extends O
  ? [0 | '0' | 'type' | 1 | '1' | 'id']
  : never
declare type ToNumber<T extends keyof StringToNumberMap | string | number> = T extends number
  ? T
  : T extends keyof StringToNumberMap
  ? StringToNumberMap[T]
  : never
declare type StringToNumberMap = {
  '0': 0
  '1': 1
  '2': 2
  '3': 3
  '4': 4
  '5': 5
  '6': 6
  '7': 7
  '8': 8
  '9': 9
  '10': 10
  '11': 11
  '12': 12
  '13': 13
  '14': 14
  '15': 15
  '16': 16
  '17': 17
  '18': 18
  '19': 19
  '20': 20
}
/**
 * Given a TB - heap table fields schema and a path expression E (array of form ['topLevelField', 'nestedField', ...]),
 *  returns the type of the field at the end of the path.
 */
export declare type HsOfHqExprPath<TB extends hs.HsProperties, E extends unknown[]> = E extends [infer K, ...infer Rest]
  ? K extends keyof TB
    ? HsOptionalToNullable<HsOfHqExprPathForSchema<TB[K], Rest>>
    : never
  : never
declare type HsOfHqExprPathForSchema<HS extends hs.HeapSchema, Path extends unknown[]> = Path extends []
  ? HS
  : Path extends [infer K, ...infer Rest]
  ? HsNullableIfCondOptional<
      HS,
      HS extends hs.HsObject<infer Nested>
        ? HsOfHqExprPath<Nested, Path>
        : HS extends hs.HsArray<infer Item>
        ? HsOfHqExprPathArray<Item, K, Rest>
        : HS extends hs.HsTuple<infer Items>
        ? HsOfHqExprPathTuple<Items, K, Rest>
        : HS extends hs.HsRecord<infer Key, infer Value>
        ? HsOfHqExprPathRecord<Key, Value, K, Rest>
        : HS extends hs.HsUnion<infer Options>
        ? HsOfHqExprPathUnion<Options, Path>
        : HS extends hs.HsIntersect<infer Options>
        ? HsOfHqExprPathUnion<Options, Path>
        : HS extends hs.HsMoney
        ? HsOfHqExprPathMoney<Path>
        : HS extends hs.HsGenericLink
        ? HsOfHqExprPathGenericLink<Path>
        : HS extends hs.HsAny | hs.HsUnknown
        ? HS
        : never
    >
  : never
declare type HsNullableIfCondOptional<
  Cond extends hs.HeapSchema,
  O extends hs.HeapSchema,
> = Cond extends hs.HsOptional<hs.HeapSchema> ? HqNullable<O> : O
declare type HsOptionalToNullable<HS extends hs.HeapSchema> = HS extends hs.HsOptional<infer Required>
  ? hs.HsUnion<[Required, hs.HsNull]>
  : HS
declare type HqNullable<HS extends hs.HeapSchema> = HS extends never ? never : hs.HsUnion<[HS, hs.HsNull]>
declare type HsOfHqExprPathArray<Item extends hs.HeapSchema, K, Path extends unknown[]> = K extends number
  ? HqNullable<HsOfHqExprPathForSchema<Item, Path>>
  : never
declare type HsOfHqExprPathTuple<
  Items extends readonly hs.HeapSchema[],
  K,
  Path extends unknown[],
> = K extends keyof Items
  ? K extends number
    ? HsOfHqExprPathForSchema<Items[K], Path>
    : K extends string
    ? HsOfHqExprPathForSchema<Items[ToNumber<K>], Path>
    : never
  : never
declare type HsOfHqExprPathRecord<
  Key extends hs.HsRecordKey,
  Value extends hs.HeapSchema,
  K,
  Path extends unknown[],
> = K extends Key['$static'] ? HqNullable<HsOfHqExprPathForSchema<Value, Path>> : never
declare type HsOfHqExprPathUnion<T extends readonly hs.HeapSchema[], Path extends unknown[]> = {
  [K in keyof T]: T[K] extends hs.HsNull ? hs.HsNull : HsOfHqExprPathForSchema<T[K], Path>
}[number]
declare type HsOfHqExprPathMoney<Path extends unknown[]> = Path extends [0 | '0' | 'amount']
  ? hs.HsNumber
  : Path extends [1 | '1' | 'currency']
  ? hs.HsString
  : never
declare type HsOfHqExprPathGenericLink<Path extends unknown[]> = Path extends [0 | '0' | 'type']
  ? hs.HsString
  : Path extends [1 | '1' | 'id']
  ? hs.HsString
  : never
export declare type HqExprDyn<O extends hs.HeapSchema> = {
  $dyn:
    | (HsNumeric extends O ? number : never)
    | (hs.HsString extends O ? string : never)
    | (hs.HsBoolean extends O ? boolean : never)
    | (hs.HsDateTime extends O ? Date : never)
}
/**
 * Infer HeapSchema type of the dynamic parameter expression E.
 */
export declare type HsOfHqExprDyn<E extends HqExprDyn<hs.HeapSchema>> = E['$dyn'] extends number
  ? hs.HsNumber
  : E['$dyn'] extends string
  ? hs.HsString
  : E['$dyn'] extends boolean
  ? hs.HsBoolean
  : E['$dyn'] extends Date
  ? hs.HsDateTime
  : never
/**
 * Union of supported functions for the given O return type of the function.
 */
export declare type HqExprFn<TB extends hs.HsProperties, O extends hs.HeapSchema> =
  | (hs.HsNumber extends O
      ?
          | HqExprFnAbs<TB>
          | HqExprFnCeil<TB>
          | HqExprFnCoalesce<TB>
          | HqExprFnFloor<TB>
          | HqExprFnLength<TB>
          | HqExprFnRound<TB>
          | HqExprOpAdd<TB>
          | HqExprOpSub<TB>
          | HqExprOpNeg<TB>
          | HqExprOpMul<TB>
          | HqExprOpDiv<TB>
          | HqExprOpMod<TB>
          | HqExprOpPow<TB>
      : never)
  | (hs.HsString extends O ? HqExprFnConcat<TB> | HqExprFnLower<TB> | HqExprFnUpper<TB> | HqExprFnCoalesce<TB> : never)
  | (hs.HsDateTime extends O ? HqExprFnNow | HqExprFnCoalesce<TB> : never)
export declare type HqExprFnAbs<TB extends hs.HsProperties> = {
  $abs: [HqExpr<TB, HsNumeric>]
}
export declare type HqExprFnCeil<TB extends hs.HsProperties> = {
  $ceil: [HqExpr<TB, HsNumeric>]
}
export declare type HqExprFnCoalesce<TB extends hs.HsProperties> = {
  $coalesce: HqExpr<TB, hs.HeapSchema>[]
}
export declare type HqExprFnConcat<TB extends hs.HsProperties> = {
  $concat: HqExpr<TB, HsNumeric | hs.HsString>[]
}
export declare type HqExprFnFloor<TB extends hs.HsProperties> = {
  $floor: [HqExpr<TB, HsNumeric>]
}
export declare type HqExprFnLength<TB extends hs.HsProperties> = {
  $length: [HqExpr<TB, hs.HsString>]
}
export declare type HqExprFnLower<TB extends hs.HsProperties> = {
  $lower: [HqExpr<TB, hs.HsString>]
}
export declare type HqExprFnNow = {
  $now: []
}
export declare type HqExprFnRound<TB extends hs.HsProperties> = {
  $round: [HqExpr<TB, HsNumeric>]
}
export declare type HqExprFnUpper<TB extends hs.HsProperties> = {
  $upper: [HqExpr<TB, hs.HsString>]
}
export declare type HqExprOpAdd<TB extends hs.HsProperties> = {
  $add: [HqNumExpr<TB>, HqNumExpr<TB>, ...HqNumExpr<TB>[]]
}
export declare type HqExprOpSub<TB extends hs.HsProperties> = {
  $sub: [HqNumExpr<TB>, HqNumExpr<TB>, ...HqNumExpr<TB>[]]
}
export declare type HqExprOpNeg<TB extends hs.HsProperties> = {
  $neg: [HqNumExpr<TB>]
}
export declare type HqExprOpMul<TB extends hs.HsProperties> = {
  $mul: [HqNumExpr<TB>, HqNumExpr<TB>, ...HqNumExpr<TB>[]]
}
export declare type HqExprOpDiv<TB extends hs.HsProperties> = {
  $div: [HqNumExpr<TB>, HqNumExpr<TB>, ...HqNumExpr<TB>[]]
}
export declare type HqExprOpMod<TB extends hs.HsProperties> = {
  $mod: [HqNumExpr<TB>, HqNumExpr<TB>, ...HqNumExpr<TB>[]]
}
export declare type HqExprOpPow<TB extends hs.HsProperties> = {
  $exp: [HqNumExpr<TB>, HqNumExpr<TB>, ...HqNumExpr<TB>[]]
}
declare type HqNumExpr<TB extends hs.HsProperties> = HqExpr<TB, HsNumeric>
/**
 * Union of supported aggregate functions for the given O return type of the function.
 */
export declare type HqExprAgg<TB extends hs.HsProperties, O extends hs.HeapSchema> =
  | (hs.HsNumber extends O
      ? HqExprAggCount<TB> | HqExprAggSum<TB> | HqExprAggAvg<TB> | HqExprAggMax<TB> | HqExprAggMin<TB>
      : never)
  | (hs.HsString extends O ? HqExprAggStringAgg<TB> | HqExprAggMax<TB> | HqExprAggMin<TB> : never)
  | (hs.HsDateTime extends O ? HqExprAggMax<TB> | HqExprAggMin<TB> : never)
  | (hs.HsBoolean extends O ? HqExprAggBoolAnd<TB> | HqExprAggBoolOr<TB> : never)
export declare type HqExprAggBoolAnd<TB extends hs.HsProperties> = {
  $bool_and: [HqExpr<TB, hs.HsBoolean>]
}
export declare type HqExprAggBoolOr<TB extends hs.HsProperties> = {
  $bool_or: [HqExpr<TB, hs.HsBoolean>]
}
export declare type HqExprAggCount<TB extends hs.HsProperties> = {
  $count: [HqExpr<TB, hs.HeapSchema> | '*'] | []
} & HqExprAggWithDistinct
export declare type HqExprAggSum<TB extends hs.HsProperties> = {
  $sum: [HqExpr<TB, HsNumeric>]
} & HqExprAggWithDistinct
export declare type HqExprAggAvg<TB extends hs.HsProperties> = {
  $avg: [HqExpr<TB, HsNumeric>]
} & HqExprAggWithDistinct
export declare type HqExprAggMax<TB extends hs.HsProperties> = {
  $max: [HqExpr<TB, HsNumeric | hs.HsString | hs.HsDateTime | hs.HsAny | hs.HsUnknown>]
} & HqExprAggWithDistinct
export declare type HqExprAggMin<TB extends hs.HsProperties> = {
  $min: [HqExpr<TB, HsNumeric | hs.HsString | hs.HsDateTime | hs.HsAny | hs.HsUnknown>]
} & HqExprAggWithDistinct
export declare type HqExprAggStringAgg<TB extends hs.HsProperties> = {
  $string_agg: [HqExpr<TB, hs.HsString>, HqExpr<TB, hs.HsString>]
} & HqExprAggWithDistinct
export declare type HqExprAggWithDistinct = {
  $distinct?: boolean
}
declare type HsNumeric = hs.HsNumber | hs.HsInteger
/**
 * Helps to bypass the initial table of the field which is used in HeapSelectQueryBuilder.
 * @internal
 */
export declare type HsRepoHint = {
  $repo?: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>
}
declare type UgcSystemHeapTableName = 'users'
interface HqlSelectQuery {
  from: HqlFrom
  select: HqlSelect
  distinct?: boolean
  where?: CqlWhere
  group?: CqlSelectAlias[]
  having?: CqlHaving
  order?: HqlOrder
  limit?: number
  offset?: number
  resPlainJson?: boolean
  resTakeFirst?: boolean
}
declare type HqlFrom = HqlTable | HqlSubQuery
declare type HqlTable = {
  kind: 'table'
  heapType: HeapObjectType
}
declare type HqlSubQuery = {
  kind: 'sub'
  query: HqlSelectQuery
}
declare type HqlExpr = HqlField | HqlExprFn | HqlExprAgg | CqlDynParam
declare type HqlField = HqlTableField | HqlSubQueryField
declare type HqlTableField = HqlSystemColumn | HqlDataField
declare type HqlSubQueryField = HqlSubPlainField | HqlSubJsonField
declare type HqlSystemColumn = {
  kind: 'sys'
  name: HqlSystemColumnName
}
declare type HqlSystemColumnName = typeof allowedHqlSystemColumns[number]
declare const allowedHqlSystemColumns: readonly ['id', 'createdAt', 'updatedAt', 'createdBy', 'updatedBy']
declare type HqlDataField = {
  kind: 'data'
  path: string | CqlDeepPath
  type: CqlFieldType
}
declare type HqlSubPlainField = {
  kind: 'subPlain'
  name: string
}
declare type HqlSubJsonField = {
  kind: 'subJson'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type HqlExprFn = {
  kind: 'fn'
  fn: string
  args: Array<HqlExpr>
}
declare type HqlExprAgg = {
  kind: 'agg'
  fn: string
  args: [CqlAsterisk] | Array<CqlDynParam | HqlField | HqlExprFnNoAgg>
  distinct?: boolean
}
declare type HqlExprFnNoAgg = {
  kind: 'fn'
  fn: string
  args: Array<HqlField | HqlExprFnNoAgg | CqlDynParam>
}
declare type HqlSelect = Record<string, HqlExpr>
declare type HqlOrder = HqlSimpleOrderBy | Array<HqlSingleOrderBy>
declare type HqlSingleOrderBy = HqlSimpleOrderBy | [HqlSimpleOrderBy, SortDirection]
declare type HqlSimpleOrderBy =
  | HqlSystemColumnName
  | string
  | HqlDataField
  | HqlSubJsonField
  | HqlOrderAliasField
  | HqlExprFn
declare type HqlOrderAliasField = {
  kind: 'aliasJson'
  path: CqlDeepPath
  type: CqlFieldType
}

export {}
