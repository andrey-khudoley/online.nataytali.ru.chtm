import * as tb from '@sinclair/typebox'
import { Filter, OrderByDefinition, SortDirection } from 'core/db/dbQueryTypes'
import { HeapId, HeapObjectBaseRaw, HeapObjectType, HeapOrderBy, HeapRecord } from 'core/heap/heapTypes'
import * as hs from 'core/heap/v2/heapSchemaTypes'
import { HeapTableInfo } from 'core/heap/v2/HeapTableRecordApi'
import { ReadOnlyHeapTableRepo } from 'core/heap/v2/HeapTableRepo'
import {
  ApiCallAction,
  ApiCallOptions,
  ApiCallResponseFields,
  ApiCallSuccessResponse,
  ChatiumActions,
  ChatiumScreen,
  NavigateAction,
  QueryParamsOption,
  apiCall,
  navigate,
} from 'lib/chatium-json'
import { Color, Icon, TuneHttpHeadersResponse } from 'lib/chatium-json/v1'
import {
  BackgroundGradientStyle,
  BorderStyle,
  BoxProps,
  ChatiumChildNode,
  CommonIconStateStyle,
  DesktopLayout,
  IconProps,
  IconScaleStyle,
  IconTextStyle,
  ImageProps,
  PlainIconName,
  ScreenErrorResponseV2,
  ScreenPropsV2,
  ScreenSuccessResponseV2,
  ShadowStyle,
  SimpleBgColorStyle,
  SmartIconProps,
  StandardFontSize,
  TextProps,
  V2IntrinsicElements,
} from 'lib/chatium-json/v2'
import { jsx, jsx as htmlJsx } from 'lib/html-jsx'
import { Fragment as JsxFragment } from 'services/ugc-runner/runtime/builtin/appUi'
import { RichUgcAccount } from 'services/ugc-runner/runtime/context/RichUgcCtxAccount'
import { HeapTableFn, UgcAnyHeapTableRepo } from 'services/ugc-runner/runtime/heap/UgcHeapTableRepo'
import { CtxOutsideFns, UgcRouteType } from 'services/ugc-runner/runtime/runtimeTypes'
import { UgcSmartUser } from 'services/ugc-runner/runtime/user/UgcSmartUser'
import { AnyObject, JSONInputObject, JSONInputValue, JSONValue, PlainOrPromise, PublicFieldsOfClass } from 'utils/types'

interface CqlSelectQuery {
  from: CqlFrom
  select: CqlSelect
  distinct?: boolean
  where?: CqlWhere
  having?: CqlHaving
  order?: CqlOrder
  group?: CqlGroup
  limit?: number
  offset?: number
}
declare type CqlFrom = CqlTable | CqlSubQuery
declare type CqlTable = {
  kind: 'table'
  schema: string
  name: string
}
declare type CqlSubQuery = {
  kind: 'sub'
  query: CqlSelectQuery
}
declare type CqlSelect = Record<string, CqlExpr> | undefined
declare type CqlExpr = CqlPlainColumn | CqlExprFn | CqlDynParam | CqlJsonPath | CqlAsterisk
declare type CqlPlainColumn = {
  kind: 'col'
  name: string
  type?: CqlFieldType
}
declare type CqlExprFn = {
  kind: 'fn'
  fn: string
  args: CqlExpr[]
  distinct?: boolean
  type?: CqlFieldType
}
declare type CqlDynParam = {
  kind: 'dyn'
  value: unknown
  type?: CqlFieldType
}
declare type CqlJsonPath = {
  kind: 'json'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type CqlAsterisk = {
  kind: '*'
  type?: undefined
}
declare type CqlFieldType = 'string' | 'number' | 'boolean' | 'date' | 'json'
declare type CqlDeepPath = [string, ...(string | number)[]]
declare type CqlGroup = CqlSelectAlias[]
declare type CqlSelectAlias = string
declare type CqlWhere = Filter<any>
declare type CqlHaving = Filter<any>
declare type CqlOrder = OrderByDefinition<any>
declare type MessageSticker = {
  url: string
  previewUrl?: string
  emoji?: string[]
}
declare type DynVar = string | number | boolean
declare type TranslationKey<T extends string = string> = [T, StaticTranslateArgs | undefined]
declare type TranslateArgs = {
  [key: string]: DynVar | InCodeSelector | bigint
} & {
  $ns?: string
}
declare type StaticTranslateArgs = {
  [key: string]: StaticInCodeSelector | string
} & {
  $ns?: string
}
declare type DynamicTranslateArgs = {
  [key: string]: DynVar
}
declare type InCodeSelector = {
  $val?: DynVar
} & StaticInCodeSelector
declare type StaticInCodeSelector = {
  $pluralType?: Intl.PluralRulesOptions['type']
  $other?: string | number
} & Record<string | number, DynVar>
declare type Lang = string
interface LangCtx {
  lang: Lang
}
declare abstract class ChatiumError extends Error {
  abstract readonly statusCode: number
  constructor(message?: string)
}
declare class ValidationError extends ChatiumError {
  readonly statusCode = 422
  readonly issues: ValidationIssue[]
  readonly reason?: string
  constructor(issues: ValidationIssue[])
  constructor(reason: string, issues: ValidationIssue[])
  constructor(
    reason: string,
    ajvErrors?: Array<{
      instancePath: string
      message?: string
    }> | null,
  )
  /** @deprecated use issues array instead */
  constructor(reason: string, data?: ValidationErrorData)
  get errors(): ValidationIssue[]
  /** @deprecated use issues or errors */
  get data(): ValidationErrorData
  toString(): string
  get message(): string
  get isEmpty(): boolean
}
interface ValidationIssue {
  fullPath?: string
  message: string
}
declare type ValidationErrorData = ValidationErrorDataFields
interface ValidationErrorDataFields {
  fields: Record<string, string>
}
declare type TimeUnit =
  | 'milliseconds'
  | 'seconds'
  | 'minutes'
  | 'hours'
  | 'days'
  | 'weeks'
  | 'months'
  | 'quarters'
  | 'years'
declare type AccountUrlFn = {
  accountUrlParams: AccountUrlParams
  (path: string, options?: QueryParamsOption): string
}
interface AccountUrlParams {
  accountName: string
  accountHost: string
  accountPathPrefix: string
  pluginAppInfo?: UgcPluginAppUrlInfo
}
interface LocationCtx {
  location: Location | undefined
}
interface Location {
  country: string
  region: string
  timeZone: string
  city: string
  coordinates: Coordinates
}
interface Coordinates {
  latitude: number
  longitude: number
}
interface UgcJobScheduleParams {
  allowRetry?: boolean
}
interface HsPropertiesWithOptions {
  [key: string]: hs.HeapSchema & hs.HsOptionsWithDefault<unknown>
}
declare type ReqQuery = Record<string, string | string[] | undefined>
declare type BS = hs.HeapSchema
declare type PS = hs.HsObject<hs.HsStringFriendlyProperties> | hs.HsRecord<hs.HsString, hs.HsString | hs.HsNumber>
declare type QS = hs.HsObject<HsPropertiesWithOptions> | hs.HsRecord<hs.HsString, hs.HeapSchema>
declare type RS = hs.HeapSchema
declare type VT<S extends hs.HeapSchema> = S['$static']
declare type VTR<S extends hs.HeapSchema> = S['$hsRuntime']
declare type VTC<S extends hs.HeapSchema> = S['$hsCreateInput']
declare type IsOptionalBody<T> = unknown extends T ? true : undefined extends T ? true : false
export interface FunctionRouteRef<B, R> {
  readonly pattern: string
  run: IsOptionalBody<B> extends true
    ? (ctx: RichUgcCtx, params?: B) => Promise<R>
    : (ctx: RichUgcCtx, params: B) => Promise<R>
  path(ctx: RichUgcCtx): Promise<string>
  meta(ctx: RichUgcCtx): Promise<AnyObject>
  bodySchema(ctx: RichUgcCtx): Promise<BS>
  resultSchema(ctx: RichUgcCtx): Promise<RS>
  schema(ctx: RichUgcCtx): Promise<{
    meta: AnyObject
    body: BS
    result: RS
  }>
}
export declare type GetFunctionRouteRefBody<Ref extends FunctionRouteRef<any, any>> = Ref extends FunctionRouteRef<
  infer B,
  any
>
  ? B
  : never
export declare type GetFunctionRouteRefResult<Ref extends FunctionRouteRef<any, any>> = Ref extends FunctionRouteRef<
  any,
  infer R
>
  ? R
  : never
interface FunctionRouteRefNoResultSchema<B, R> {
  readonly pattern: string
  run: IsOptionalBody<B> extends true
    ? (ctx: RichUgcCtx, params?: B) => Promise<R extends Promise<infer T> ? T : R>
    : (ctx: RichUgcCtx, params: B) => Promise<R extends Promise<infer T> ? T : R>
  path(ctx: RichUgcCtx): Promise<string>
  meta(ctx: RichUgcCtx): Promise<AnyObject>
  bodySchema(ctx: RichUgcCtx): Promise<BS>
  resultSchema(ctx: RichUgcCtx): Promise<any>
  schema(ctx: RichUgcCtx): Promise<{
    meta: AnyObject
    body: BS
    result: any
  }>
}
interface FunctionRouteRefNoBodySchema<P, R> {
  readonly pattern: string
  run: IsOptionalBody<P> extends true
    ? (ctx: RichUgcCtx, params?: P) => Promise<R>
    : (ctx: RichUgcCtx, params: P) => Promise<R>
  path(ctx: RichUgcCtx): Promise<string>
  meta(ctx: RichUgcCtx): Promise<AnyObject>
  bodySchema(ctx: RichUgcCtx): Promise<any>
  resultSchema(ctx: RichUgcCtx): Promise<R>
  schema(ctx: RichUgcCtx): Promise<{
    meta: AnyObject
    body: any
    result: R
  }>
}
interface FunctionRouteRefNoSchema<P, R> {
  readonly pattern: string
  run: IsOptionalBody<P> extends true
    ? (ctx: RichUgcCtx, params?: P) => Promise<R extends Promise<infer T> ? T : R>
    : (ctx: RichUgcCtx, params: P) => Promise<R extends Promise<infer T> ? T : R>
  path(ctx: RichUgcCtx): Promise<string>
  meta(ctx: RichUgcCtx): Promise<AnyObject>
  bodySchema(ctx: RichUgcCtx): Promise<any>
  resultSchema(ctx: RichUgcCtx): Promise<any>
  schema(ctx: RichUgcCtx): Promise<{
    meta: AnyObject
    body: any
    result: any
  }>
}
interface JobRouteRef<B> {
  readonly pattern: string
  scheduleJobAt: IsOptionalBody<B> extends true
    ? (ctx: RichUgcCtx, startAt: Date, params?: B, scheduleParams?: UgcJobScheduleParams) => Promise<number>
    : (ctx: RichUgcCtx, startAt: Date, params: B, scheduleParams?: UgcJobScheduleParams) => Promise<number>
  scheduleJobAfter: IsOptionalBody<B> extends true
    ? (
        ctx: RichUgcCtx,
        amount: number,
        unit: TimeUnit,
        params?: B,
        scheduleParams?: UgcJobScheduleParams,
      ) => Promise<number>
    : (
        ctx: RichUgcCtx,
        amount: number,
        unit: TimeUnit,
        params: B,
        scheduleParams?: UgcJobScheduleParams,
      ) => Promise<number>
  scheduleJobAsap: IsOptionalBody<B> extends true
    ? (ctx: RichUgcCtx, params?: B, scheduleParams?: UgcJobScheduleParams) => Promise<number>
    : (ctx: RichUgcCtx, params: B, scheduleParams?: UgcJobScheduleParams) => Promise<number>
  path(): string
  meta(ctx: RichUgcCtx): Promise<AnyObject>
  bodySchema(ctx: RichUgcCtx): Promise<BS>
  schema(ctx: RichUgcCtx): Promise<{
    body: BS
  }>
}
interface JobRouteRefNoSchema<_P> {
  readonly pattern: string
  path(): string
  meta(ctx: RichUgcCtx): Promise<AnyObject>
  bodySchema(ctx: RichUgcCtx): Promise<any>
  schema(ctx: RichUgcCtx): Promise<{
    meta: AnyObject
    body: any
  }>
  scheduleJobAt(
    ctx: RichUgcCtx,
    startAt: Date,
    params?: JSONInputValue,
    scheduleParams?: UgcJobScheduleParams,
  ): Promise<number>
  scheduleJobAfter(
    ctx: RichUgcCtx,
    amount: number,
    unit: TimeUnit,
    params?: JSONInputValue,
    scheduleParams?: UgcJobScheduleParams,
  ): Promise<number>
  scheduleJobAsap(ctx: RichUgcCtx, params?: JSONInputValue, scheduleParams?: UgcJobScheduleParams): Promise<number>
}
declare type RouteRefGetSchemaFn = (
  codeAccountId: number,
  routerUrlPath: string,
  routePattern: string,
  routeType: UgcRouteType,
) => Promise<RouteRefSchema>
declare type RouteRefSchema = {
  meta?: AnyObject
  bs?: BS
  ps?: PS
  qs?: QS
  rs?: RS
}
declare type HeapEmbeddingsUgcResult = Record<number, PartialEmbeddings>
declare type PartialEmbeddings = {
  [K in EmbeddingType]?: Array<number[]>
}
declare type EmbeddingType = 'openai-text-embedding3-large' | 'openai-text-embedding3-small'
declare type TsVectorLangKey = 'ru' | 'en'
interface MetricEventRecord {
  sign?: number
  uid?: string
  sid?: string
  sid_duration?: number
  inferred_uid?: boolean
  inferred_sid?: boolean
  gc_visit_id?: number
  gc_visitor_id?: number
  gc_session_id?: number
  account_id: number
  account_type: AccountType
  url: string
  referer?: string
  user_agent?: string
  ip?: string
  title?: string
  screen_width?: number
  screen_height?: number
  screen_pixel_ratio?: number
  location_country?: string
  location_region?: string
  location_time_zone?: string
  location_city?: string
  location_coordinates_latitude?: number
  location_coordinates_longitude?: number
  ua_client_type?: string
  ua_client_name?: string
  ua_client_version?: string
  ua_device_type?: string
  ua_device_brand?: string
  ua_device_model?: string
  ua_os_name?: string
  ua_os_version?: string
  ua_os_platform?: string
  ua_bot_name?: string
  ua_bot_category?: string
  os_name?: string
  device_name?: string
  request_type: 'screen' | 'apiCall' | 'get' | 'post'
  auth_id?: number
  auth_type?: string
  auth_key?: string
  auth_first_name?: string
  auth_last_name?: string
  auth_lang?: string
  user_id?: string
  user_type?: 'Anonymous' | 'Real' | 'Bot'
  user_roles?: string[]
  user_account_role?: string
  user_status?: string
  user_expires_at?: Date | null
  user_first_name?: string
  user_last_name?: string
  user_icon_image?: string
  user_phone?: string
  user_email?: string
  user_platforms?: string[]
  session_id?: string
  session_email?: string
  session_phone?: string
  fcm_token?: string
  ts: Date
  ts64?: number
  funnel?: string
  funnel_node?: string
  funnel_node_from?: string
  utm_source?: string
  utm_content?: string
  utm_medium?: string
  utm_campaign?: string
  utm_term?: string
  action?: string
  action_params?: string
  action_param1?: string
  action_param2?: string
  action_param3?: string
  action_param1_float?: number
  action_param2_float?: number
  action_param3_float?: number
  action_param4_float?: number
  action_param1_int?: number
  action_param2_int?: number
  action_param3_int?: number
  action_param1_arrstr?: string[]
  action_param2_arrstr?: string[]
  action_param3_arrstr?: string[]
  action_param1_uint32arr?: number[] | undefined
  action_param1_mapstrstr?: Record<string, string> | undefined
  action_param2_mapstrstr?: Record<string, string> | undefined
  keys?: string[]
  values?: string[]
  /**
   * CLRT parsing
   * clrt=t:y_c:{campaign_id}_g:{gbid}_a:{ad_id}_ph:{phrase_id}_k:{keyword}_cr:{creative_id}_rt:{retargeting_id}_int:{interest_id}_at:{adtarget_id}_reg:{region_id}_s:{source}_dt:{device_type}
   */
  param_clrt?: string
  clrt_type?: string
  clrt_campaign_id?: string
  clrt_ad_id?: string
  clrt_run_id?: number
}
declare type EntityId = string
declare enum UserRole {
  Admin = 'Admin',
  Staff = 'Staff',
  Support = 'Support',
  ActiveSupport = 'ActiveSupport',
  Developer = 'Developer',
  BetaTester = 'BetaTester',
  User = 'User',
}
declare enum UserStatus {
  Imported = 'Imported',
  Joined = 'Joined',
  AsSupport = 'AsSupport',
  Left = 'Left',
}
declare const systemOnlyIdentityTypes: readonly ['Password', 'ApiKey', 'DeviceId', 'TechSupport', 'GetcourseId']
declare type IdentityType = CustomProvidableIdentityType | SystemOnlyIdentityType
declare type CustomProvidableIdentityType = 'Phone' | 'Email' | 'TelegramId' | 'ParentAccountUser' | string
declare type SystemOnlyIdentityType = typeof systemOnlyIdentityTypes[number]
declare type AuthProvider =
  | 'Device'
  | 'Sms'
  | 'Email'
  | 'Password'
  | 'AnotherSession'
  | 'ParentAccount'
  | 'Getcourse'
  | 'MobileAppPhone'
  | 'MobileAppEmail'
  | 'Github'
  | 'Google'
  | 'Telegram'
  | 'Chatium'
  | string
declare type PrimaryIdentities = {
  phone?: string
  email?: string
  hasPassword?: boolean
}
declare abstract class SmartUser<Ctx> {
  private ctx
  private coreUser
  private extendedInfo?
  private primaryIdentities?
  protected abstract userApi: SmartUserApi<Ctx>
  protected abstract fileServiceDirectHost: string
  protected abstract fileServiceCdnHost: string
  constructor(
    ctx: LocationCtx,
    coreUser: UgcCtxUser2,
    extendedInfo?: ExtendedUserInfo | undefined,
    primaryIdentities?: PrimaryIdentities | undefined,
  )
  get id(): HeapId
  get type(): User2['type']
  get displayName(): string
  get confirmedPhone(): string | undefined
  get confirmedEmail(): string | undefined
  get accountRole(): AccountRole
  get username(): string | undefined
  get firstName(): string | undefined
  get middleName(): string | undefined
  get lastName(): string | undefined
  get fullName(): string
  get gender(): UserGender | undefined
  get birthdayDate(): Date | undefined
  get birthday(): string | undefined
  get passwordSalt(): string
  get hasPassword(): boolean
  updateAccountRole(ctx: Ctx, newRole: AccountRole): Promise<void>
  updateUsername(ctx: Ctx, username: string): Promise<void>
  updatePassword(ctx: Ctx, password: string): Promise<void>
  updateLang(ctx: Ctx, lang: Lang | null): Promise<void>
  updateExtendedInfo(ctx: Ctx, info: UpdateExtendedUserInfoRaw): Promise<void>
  get smartIconProps(): {
    url?: string
    name?: PlainIconName
    text?: string
  }
  get hasImage(): boolean
  get imageUrl(): string | undefined
  /**
   * Effective image hash XOR url
   * Mainly for copying image data from one user to another
   */
  get rawImageInfo(): {
    imageHash?: string
    imageUrl?: string
  }
  getImageThumbnailUrl(size?: number): string | undefined
  is(role: Exclude<AccountRole, 'None'>): boolean
  get lang(): Lang | undefined
  toJSON(): JSONInputObject
  serialize(): SerializedSmartUser | UgcCtxUser1
  getProfile<T extends JSONInputObject>(): T | undefined
  private get fsHost()
}
declare type SerializedSmartUser = [UgcCtxUser2, ExtendedUserInfo | undefined, PrimaryIdentities | undefined]
interface SmartUserApi<Ctx> {
  updateAccountRole(ctx: Ctx, userId: HeapId, newRole: AccountRole): Promise<AccountRole>
  updateUsername(ctx: Ctx, userId: HeapId, username: string): Promise<string>
  updateExtendedInfo(
    ctx: Ctx,
    userId: HeapId,
    info: UpdateExtendedUserInfo,
  ): Promise<[UgcCtxUser2, ExtendedUserInfo | undefined]>
  updatePassword(ctx: Ctx, userId: HeapId, password: string): Promise<void>
  updateLang(ctx: Ctx, userId: HeapId, lang: Lang | null): Promise<string | undefined>
}
declare type ExtendedUserInfo = ExtendedUserFields & {
  displayName?: string
  profile?: JSONInputObject
}
declare type UpdateExtendedUserInfo = {
  firstName?: string | null
  lastName?: string | null
  middleName?: string | null
  gender?: UserGender | null
  birthday?: string | null
  imageHash?: string | null
  imageUrl?: string | null
}
declare type UpdateExtendedUserInfoRaw = Pick<
  UpdateExtendedUserInfo,
  'firstName' | 'middleName' | 'lastName' | 'gender' | 'imageHash' | 'imageUrl'
> & {
  birthday?: string | Date | null
}
declare type UserGender = 'male' | 'female' | 'other'
declare type ExtendedUserFieldsSupport = Partial<Record<keyof ExtendedUserFields, boolean>>
declare type HashMediaType = 'file' | 'video' | 'image' | 'audio'
interface StorageUploadOptions {
  /** upload a non-public file */
  protected?: boolean
  /** allow only these media types (supported: image | video | audio) */
  mediaType?: HashMediaType | HashMediaType[]
  /** allow only these content type pattern(s) */
  contentType?: string | string[]
  /** allow only these file extensions */
  extension?: string | string[]
  /** minimum file size in bytes */
  minBytes?: number
  /** maximum file size in bytes */
  maxBytes?: number
  /** custom auth session authorizing URL expiration time in seconds, default is a week */
  expiresInSeconds?: number
}
declare abstract class BaseRefLink<T extends object, ReadCtx = unknown> {
  /**
   * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
   *
   * This is technical type, like written to heap-table "type" field,
   *  don't mix up with developer-defined table name provided to Heap.Table.
   * For system ref-links this also contains heap-type ('core.User' instead of 'users').
   */
  readonly type: HeapObjectType
  readonly id: HeapId
  /** Repository (table) that owns the row of this RefLink instance */
  readonly myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>
  /**
   * Repository (table) that owns the row of the target record.
   * Can be passed as table name or as repository instance.
   * When available, used in 'get' method implementation.
   */
  protected targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<hs.HsProperties, unknown, unknown> | undefined
  constructor(
    /**
     * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
     *
     * This is technical type, like written to heap-table "type" field,
     *  don't mix up with developer-defined table name provided to Heap.Table.
     * For system ref-links this also contains heap-type ('core.User' instead of 'users').
     */
    type: HeapObjectType,
    id: HeapId,
    /** Repository (table) that owns the row of this RefLink instance */
    myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>,
    /**
     * Repository (table) that owns the row of the target record.
     * Can be passed as table name or as repository instance.
     * When available, used in 'get' method implementation.
     */
    targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<hs.HsProperties, unknown, unknown> | undefined,
  )
  toJSON(): string
  toString(): string
  get<R = T>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  abstract getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface RefLinkClass {
  new (
    type: HeapObjectType,
    id: HeapId,
    myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>,
    targetRepoOrTableName?: ReadOnlyHeapTableRepo<hs.HsProperties, unknown> | string,
  ): BaseRefLink<AnyObject>
}
declare abstract class BaseGenericLink<ReadCtx = unknown> {
  readonly type: HeapObjectType
  readonly id: HeapId
  readonly myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>;
  [index: number]: HeapObjectType | HeapId
  readonly length = 2
  constructor(type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>)
  get<R = hs.HeapObjectBase>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  /** simulates the serialized format for compatibility */
  [Symbol.iterator](): IterableIterator<HeapObjectType | HeapId>
  toJSON(): GenericLinkJson
  toString(): string
  abstract getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface GenericLinkClass {
  new (type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>): BaseGenericLink
}
declare type GenericLinkJson = [HeapObjectType, HeapId]
declare type UnionConstructorInput = hs.HsUnionable | hs.HsUnion<hs.HsUnionable[]>
declare type User2 = hs.HeapObjectBase & {
  type: 'Anonymous' | 'Real' | 'Bot'
  username?: string
  lang?: Lang
  timeZone?: string
  accountRole: AccountRole
  isBlocked: boolean
  knownChildAccounts?: number[]
} & ExtendedUserFields
declare type ExtendedUserFields = {
  firstName?: string
  lastName?: string
  middleName?: string
  gender?: UserGender
  birthday?: string
  imageHash?: string
  imageUrl?: string
}
declare type AccountRole = typeof validAccountRoles[number]
declare const validAccountRoles: readonly ['None', 'Staff', 'Admin', 'Developer', 'Owner']
declare class AuthHelperClass {
  id: number
  type: AuthType
  key: string
  /**
   * List of account IDs which have this auth registered as a user
   * This field seems redundant because this info can be obtained from Users of each account,
   *   but as every account has its own heap DB, there is no easy way to iterate over accounts for the given auths
   *   without this field.
   */
  accounts: number[]
  avatar: Icon | null
  first_name: string | null
  last_name: string | null
  /**
   * Stores info about which session auth data was merged to which real auth.
   * This is a key for performant detecting when to migrate data without any additional db queries or computations.
   *
   * For type === Session -> map from <account ID> -> list of linked <real auth ID>s
   * For others           -> map from <account ID> -> list of linked <session auth KEY>s
   * @see mergeSessionToRealAuth
   * @see unlinkSessionAuth
   */
  session_links: Record<number, string[] | number[]>
  expires_at: Date | null
  constructor(
    id: number,
    type: AuthType,
    key: string,
    /**
     * List of account IDs which have this auth registered as a user
     * This field seems redundant because this info can be obtained from Users of each account,
     *   but as every account has its own heap DB, there is no easy way to iterate over accounts for the given auths
     *   without this field.
     */
    accounts: number[],
    avatar: Icon | null,
    first_name: string | null,
    last_name: string | null,
    /**
     * Stores info about which session auth data was merged to which real auth.
     * This is a key for performant detecting when to migrate data without any additional db queries or computations.
     *
     * For type === Session -> map from <account ID> -> list of linked <real auth ID>s
     * For others           -> map from <account ID> -> list of linked <session auth KEY>s
     * @see mergeSessionToRealAuth
     * @see unlinkSessionAuth
     */
    session_links: Record<number, string[] | number[]>,
    expires_at: Date | null,
  )
}
declare type Auth = PublicFieldsOfClass<AuthHelperClass>
declare enum AuthType {
  Email = 'Email',
  None = 'None',
  Phone = 'Phone',
  Session = 'Session',
  Inbox = 'Inbox',
  API = 'API',
}
interface HeapLink<_HD extends HeapData> {
  type: HeapObjectType
  id: HeapId
}
declare type HeapObjectBaseV1 = HeapObjectBaseRaw & {
  idx: number
  createdBy: HeapLink<UserData> | null
  updatedBy: HeapLink<UserData> | null
}
declare type HeapData = {
  '~~heap~data~tag~~': never
}
declare type EraseHD<HD extends HeapData> = Omit<HD, keyof HeapData>
declare type RefLink<HD extends HeapData> = HD & {
  '~~ref~link~tag~~': never
}
declare type GenericLink = {
  '~~generic~link~tag~~': never
}
declare type HeapObjectV1<HD extends HeapData> = HeapObjectBaseV1 & MapHeapLinks<HD>
declare type MapHeapLinks<HD extends HeapData> = {
  [K in keyof EraseHD<HD>]: LinksMap<HD[K]>
}
declare type LinksMap<T> = T extends null
  ? null
  : T extends GenericLink
  ? HeapId
  : T extends RefLink<HeapData>
  ? HeapLink<T>
  : T
interface PurchasedProducts {
  [productName: string]: string | true | undefined
}
interface UserData extends HeapData {
  authId: number
  roles: UserRole[]
  status: UserStatus
  expiresAt: string | null
  avatar: Icon
  firstName: string | null
  lastName: string | null
  phone: string | null
  email: string | null
  platforms: EnvPlatform[]
  purchasedProducts: PurchasedProducts
}
declare type User1 = HeapObjectV1<UserData>
declare type AuthSession = PublicFieldsOfClass<AuthSessionHelperClass>
declare class AuthSessionHelperClass {
  id: string
  account_id: number
  user_id: string
  auth_log: AuthLogItem[]
  device_name: string
  is_mobile: boolean
  os_name: string
  last_ip: string
  last_active_approx_at: Date
  created_at: Date
  /**
   * matching session token from the external auth provider or device ID for the anonymous user sessions
   * helps to avoid creating a new session duing upstream provider session revalidation
   * @see getOrCreateExternalAuthSession
   */
  external_token: string | null
  constructor(
    id: string,
    account_id: number,
    user_id: string,
    auth_log: AuthLogItem[],
    device_name: string,
    is_mobile: boolean,
    os_name: string,
    last_ip: string,
    last_active_approx_at: Date,
    created_at: Date,
    /**
     * matching session token from the external auth provider or device ID for the anonymous user sessions
     * helps to avoid creating a new session duing upstream provider session revalidation
     * @see getOrCreateExternalAuthSession
     */
    external_token: string | null,
  )
}
interface AuthLogItem {
  provider: AuthProvider
  /**
   * Provider-specific additional data provided by the provider that can be used for later system call to the provider.
   */
  providerData?: AnyObject
  /**
   * 'AuthSession' means that this session has been authenticated by another active session with the session ID as a key
   */
  type: IdentityType | 'AuthSession'
  key: string
  authAt: number
}
declare type UgcFileStorage = 'cgs' | 'db'
declare type CgsRepoVersion = string
declare type AccountAuthType = 'Email' | 'Phone' | 'Multi'
declare enum AccountType {
  Chatium = 'Chatium',
  Getcourse = 'Getcourse',
  FollowersClub = 'FollowersClub',
  Playground = 'Playground',
  Reserved = 'Reserved',
}
declare type UgcRouter404ErrorHook = (ctx: RichUgcCtx, req: UntypedUgcRouteParsedRequest) => Promise<unknown>
declare type IapUpdatedHook = (ctx: RichUgcCtx, iapIds: string[]) => Promise<void>
declare type UserMergeHook = (ctx: RichUgcCtx, payload: UserMergeHookPayload) => Promise<void>
interface UserMergeHookPayload {
  fromUserId: HeapId
  toUserId: HeapId
}
declare type UserProfileHook = {
  obtainExtendedUserInfo?(
    ctx: RichUgcCtx,
    coreUsers: Record<HeapId, UgcCtxUser2>,
  ): Promise<Record<HeapId, ExtendedUserInfo>>
  updateExtendedUserInfo?(
    ctx: RichUgcCtx,
    coreUser: UgcCtxUser2,
    info: UpdateExtendedUserInfo,
  ): Promise<ExtendedUserInfo>
  findUserIdsByFuzzyText?(ctx: RichUgcCtx, word: string): Promise<HeapId[]>
  getExtendedUserFieldsSupport?(ctx: RichUgcCtx): Promise<ExtendedUserFieldsSupport>
}
declare type AppEnabledHook = (ctx: RichUgcCtx, payload: AppEnabledHookPayload) => Promise<void>
declare type AppEnabledHookPayload = AppInstalled
declare type AppInstalled = {
  reason: 'installed'
  customParams?: AnyObject
}
interface MobileAppLinkPrefixes {
  bundleId: string
  custom?: string
  web?: string
}
declare type AuthProviderHook = {
  id: string
  /**
   * Returns basic information about the provider
   * Used auth provider preferences editor UI
   */
  getInfo(ctx: RichUgcCtx): Promise<AuthProviderInfo>
  /**
   * Should return a button that is shown on sign-in screen as an alternative authentication method
   */
  getAuthButton(ctx: RichUgcCtx, params: AuthFlowParams): Promise<AuthProviderButtonInfo | null | undefined>
}
interface AuthFlowParams {
  backUrl?: string
  fromApiCall?: boolean
  mobileAppLinkPrefixes?: MobileAppLinkPrefixes
}
interface AuthProviderButtonInfo {
  title: string
  onClick: ChatiumActions
  icon?: Pick<SmartIconProps, 'url' | 'name' | 'text' | 'class'> & {
    style?: BackgroundGradientStyle &
      BorderStyle &
      CommonIconStateStyle &
      IconScaleStyle &
      IconTextStyle &
      ShadowStyle &
      SimpleBgColorStyle
  }
}
interface AuthProviderInfo {
  id: AuthProvider
  title: string
  icon?: Pick<SmartIconProps, 'name' | 'url' | 'text'>
  settingsUrl?: string
}
declare type CalcHeapEmbeddingsHook = (
  ctx: RichUgcCtx,
  payload: CalcEmbeddingsForHeapHookPayload,
) => Promise<CalcEmbeddingsForHeapResult>
declare type CalcSearchEmbeddingsHook = (
  ctx: RichUgcCtx,
  payload: CalcEmbeddingsForSeachHookPayload,
) => Promise<CalcEmbeddingsForSeachHookResult>
declare type CalcEmbeddingsForHeapHookPayload = {
  tableInfo: HeapTableInfo
  records: Array<HeapRecord>
}
declare type CalcEmbeddingsForHeapResult = {
  embeddings: HeapEmbeddingsUgcResult
}
declare type CalcEmbeddingsForSeachHookPayload = {
  tableInfo: HeapTableInfo
  search: string
}
declare type CalcEmbeddingsForSeachHookResult = {
  embeddings: PartialEmbeddings
}
declare type MetricEventHook = (ctx: RichUgcCtx, payload: MetricEventHookPayload) => Promise<void>
interface MetricEventHookPayload {
  event: MetricEventRecord
  params: JSONValue
  groupKey: string | null
}
declare function registerUgcHook(hookName: 'app-enabled', value: AppEnabledHook): void
declare function registerUgcHook(hookName: 'user-profile', value: UserProfileHook): void
declare function registerUgcHook(hookName: 'user-merge', value: UserMergeHook): void
declare function registerUgcHook(hookName: 'iap-updated-by-user', value: IapUpdatedHook): void
declare function registerUgcHook(hookName: 'iap-updated-txns', value: IapUpdatedHook): void
declare function registerUgcHook(hookName: '404', value: UgcRouter404ErrorHook): void
declare function registerUgcHook(hookName: 'auth-provider', value: AuthProviderHook): void
declare function registerUgcHook(hookName: 'metric-event', value: MetricEventHook): void
declare function registerUgcHook(hookName: 'calc-heap-embeddings', value: CalcHeapEmbeddingsHook): void
declare function registerUgcHook(hookName: 'calc-search-embeddings', value: CalcSearchEmbeddingsHook): void
declare function registerUgcHook<Params, Result>(
  hookName: string,
  value: (ctx: RichUgcCtx, params: Params) => Promise<Result>,
): CustomHookRegistration<Params, Result>
declare function registerUgcHook(
  hookName: string,
  value: (ctx: RichUgcCtx, params: JSONValue) => void | unknown | Promise<unknown | void>,
): void
declare type CustomHookRegistration<Params, Result> = {
  hookName: string
  handler?: (ctx: RichUgcCtx, params: Params) => Promise<Result>
}
declare type UgcCodeVersion = CgsRepoVersion
interface UgcRouteRequest {
  method: UgcRequestMethod
  path: string
  /** instead of running the requested route itself, returns its schema */
  getSchema?: boolean
  query?: ReqQuery
  headers?: Record<string, string | undefined>
  body?: any
}
export interface UgcRouteParsedRequest<Body, PathParams, Query> extends Omit<UgcRouteRequest, 'query' | 'body'> {
  body: Body
  params: PathParams
  query: Query
  /** like in node, without protocol and domain, starting with slash, normalized, includes query params */
  url: string
}
declare type UntypedUgcRouteParsedRequest = UgcRouteParsedRequest<any, Record<string, string | undefined>, ReqQuery>
declare type UgcRequestMethod = 'get' | 'post' | 'job' | 'function'
declare type UgcCtxBaseAuth = Pick<Auth, 'id' | 'type' | 'key'>
declare type UgcCtxUser1 = Pick<
  User1,
  'id' | 'firstName' | 'lastName' | 'roles' | 'avatar' | 'purchasedProducts' | 'phone' | 'email'
>
declare type UgcCtxUser2 = Pick<
  User2,
  | 'id'
  | 'type'
  | 'accountRole'
  | 'username'
  | 'firstName'
  | 'lastName'
  | 'middleName'
  | 'gender'
  | 'birthday'
  | 'imageHash'
  | 'imageUrl'
  | 'lang'
>
declare type UgcAuthSession = Pick<AuthSession, 'id' | 'auth_log'> & {
  deviceName: string
}
declare type UgcCtxLocation = Location
interface UgcCtx extends UgcInternalCtx {
  router: {
    id: EntityId
    parentId: EntityId | null
    parentIds: EntityId[] | null
    filePath: string
    name: string
    urlPath: string
    params?: Record<string, unknown> | null
  }
}
interface UgcInternalCtx extends EnvCtx, LangCtx {
  account: UgcCtxAccount
  app?: UgcCtxApp
  authSession?: UgcAuthSession
  user2?: UgcCtxUser2 | SerializedSmartUser
  location: UgcCtxLocation | undefined
  rc?: UgcCtxRc
  session: UgcCtxSession | null
  timeZone: string
  traceId: string
  auth1?:
    | (UgcCtxBaseAuth & {
        expiresAtMs?: number
      })
    | undefined
  user1?: UgcCtxUser1
}
declare type UgcCtxApp = UgcCtxProxyApp | UgcCtxPluginApp
interface UgcCtxPluginApp extends UgcPluginAppUrlInfo {
  type: 'UgcPlugin'
  appId: number
  callingAcc: UgcCtxAccount
  hostAccUser1?: UgcCtxUser1
  hostAccUser2?: UgcCtxUser2 | SerializedSmartUser
}
interface UgcPluginAppUrlInfo {
  appSlug: string
  /** path to the application root directory */
  directoryPath: string
}
interface UgcCtxProxyApp {
  type: 'UgcProxy'
  accId: number
  accName: string
  accHost: string
  accOwner: UgcCtxUser1 | null
  accUrl: string
  accExternalHost: string | null
  accPathPrefix: string | null
  appPrefix: string
  directoryPath: string | null
  user: UgcCtxUser1 | null
}
interface UgcCtxAccount {
  id: number
  name: string
  host: string
  authType: AccountAuthType
  /** @deprecated use host instead */
  externalHost: string | null
  publishedVersion: string | null
  metaHash: string
  pathPrefix: string
}
declare type UgcCtxRc = Pick<ChatiumRc, 'defaultDesktopLayout'>
interface UgcCtxSession {
  id: string
  email?: string
  phone?: string
}
declare type ImportMeta = {
  clientVersionUrl: string
}
declare type ExportInfo = [ImportMeta, string]
interface ChatiumRc {
  defaultDesktopLayout?: DesktopLayout
  favicon?: string
  faviconHash?: string
  fonts?: ScreenPropsV2['fonts']
  htmlTemplate?: string
  ogDescription?: string
  ogImage?: string
  ogImageHash?: string
  ogTitle?: string
  ogType?: string
  title?: string
  titleScreen?: string
  headExtra?: string[]
  bodyExtra?: string[]
  layout?: Layout | string
  i18n?: {
    /**
     * Language, in which the in-code key strings are defined.
     * It's important to only set this if the keys are really of that language, not technical IDs
     *  because this info is used for proper language bundle loading.
     */
    keyLang?: Lang | null
    /**
     * List of languages to which auto-translation actions will target when they are activated
     */
    autoTranslateLangs?: Lang[]
    /**
     * List of languages that are considered supported in this account.
     * 'auto-detect-all' (default) - collect a combined set of translation languages from the account code,
     *                               external dependencies, and all connected plugin apps.
     * 'auto-detect-local-with-externals' - collect a combined set of translation languages only from the account code
     *                                      and external dependencies, without plugin apps
     * 'auto-detect-only-local' - collect a combined set of translation languages only from the account's own code
     *
     * Alternatively, an explicit list of languages may be provided which disable auto-detection.
     * @see getSupportedTranslationLangs
     */
    supportedLangs?: typeof i18nSupportedLangsAutoValues[number] | Lang[]
  }
  signInPath?: string
  globalJsx?: 'app/ui' | false
}
declare const i18nSupportedLangsAutoValues: readonly [
  'auto-detect-all',
  'auto-detect-local-with-externals',
  'auto-detect-only-local',
]
interface Layout {
  leftMenu?: {
    items?: LayoutMenuItem
  }
  bottomTabs?: LayoutBottomTabs
}
interface LayoutBottomTabs {
  tabs?: LayoutMenuItem[]
  activeTintColor?: string
  inactiveTintColor?: string
}
interface LayoutMenuItem {
  id?: string
  type: 'tab' | 'button'
  title?: string
  url?: string
  onClick?: ChatiumActions
  icon: IconProps
  key?: string
}
interface EnvAvc {
  id: string
  signature: string
  accMap: Record<
    /** base account ID */
    number,
    [
      /** branch account ID */
      number,
      UgcFileStorage,
      UgcCodeVersion | null,
      /** expiration timestamp in seconds */
      number,
    ]
  >
}
interface EnvCtx {
  env: Env
}
interface OptionalEnvCtx {
  env: Env | null
}
interface Env {
  development: boolean
  production: boolean
  platform: EnvPlatform
  version: number
  appBuildNumber?: number
  ios: boolean
  android: boolean
  web: boolean
  job: boolean
  debugSocketId: string | null
  usePreviewMode: boolean
  useScopedPreviewMode: null | Record<string, boolean | null | undefined>
  viewportWidth: number | null
  viewportHeight: number | null
  devicePixelRatio: number
  alwaysHeader: boolean
  clientScope?: 'modal' | 'desktop' | 'ide'
  desktopLayout?: DesktopLayout
  acceptChatiumJson: boolean
  client?: ClientInfo
  avc?: EnvAvc
}
declare const EnvPlatform: {
  readonly iOS: 'iOS'
  readonly Android: 'Android'
  readonly Web: 'Web'
  readonly Job: 'Job'
}
declare type EnvPlatform = keyof typeof EnvPlatform
interface ClientInfo {
  ip: string
  deviceName: string
  osName: string
}
declare type HsSelectOptions<HSP extends hs.HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  limit?: number | null | undefined
  offset?: number | null | undefined
  order?: HsOrderBy<HSP> | null | undefined
}
declare type HsOrderBy<HSP extends hs.HsProperties> = HsSingleOrderBy<HSP> | Array<HsSingleOrderBy<HSP>>
declare type HsSingleOrderBy<HSP extends hs.HsProperties> = (keyof HSP & string) | hs.HsOrderInputObject<HSP>
declare type HsTableSelectOptions<HSP extends hs.HsProperties> = Pick<
  HsSelectOptions<HSP & hs.HeapObjectFilterableSchema>,
  'where' | 'limit' | 'offset'
> & {
  order?: HeapOrderBy<HSP> | null | undefined
}
declare type HsTableSearchByOptions<HSP extends hs.HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  query: string
  embeddingsQuery?: string
  limit?: number
}
declare type HsUpdateAllOptions<HSP extends hs.HsProperties> = {
  patch: Partial<hs.HsUpdateInputObject<HSP>>
  where?: HsTableFilter<HSP> | null | undefined
  limit: number | null
}
declare type HsDeleteAllOptions<HSP extends hs.HsProperties> = {
  where?: HsTableFilter<HSP> | null | undefined
  limit: number | null
  /** default is false */
  hard?: boolean
}
declare type HsFilter<HSP extends hs.HsProperties> =
  | hs.HsFilterInputObject<HSP>
  | HsTopAndOperator<HSP>
  | HsTopOrOperator<HSP>
  | HsTopNotOperator<HSP>
  | HsNoopOperator
declare type HsTableFilter<HSP extends hs.HsProperties> = HsFilter<HSP & hs.HeapObjectFilterableSchema>
declare type HsTopAndOperator<HSP extends hs.HsProperties> = {
  $and: Array<HsFilter<HSP>>
}
declare type HsTopOrOperator<HSP extends hs.HsProperties> = {
  $or: Array<HsFilter<HSP>>
}
declare type HsTopNotOperator<HSP extends hs.HsProperties> = {
  $not: HsFilter<HSP>
}
declare type HsFilterRighthand<HS extends hs.HeapSchema> = null | HsFilterRighthandNonNull<HS>
declare type HsFilterRighthandNonNull<HS extends hs.HeapSchema> = hs.HsFilterInput<HS> | CommonOperator<HS>
declare type CommonOperator<HS extends hs.HeapSchema> =
  | HsAndOperator<HS>
  | HsNoopOperator
  | HsNotOperator<HS>
  | HsOrOperator<HS>
declare type HsNoopOperator = {
  $noop: true | 1 | '1' | 'true' | 'yes'
}
declare type HsNotOperator<HS extends hs.HeapSchema> = {
  $not: HsFilterRighthand<HS>
}
declare type HsAndOperator<HS extends hs.HeapSchema> = {
  $and: Array<HsFilterRighthand<HS>>
}
declare type HsOrOperator<HS extends hs.HeapSchema> = {
  $or: Array<HsFilterRighthand<HS>>
}
declare type HsCompareOperators<V> = HsGtOperator<V> | HsGteOperator<V> | HsLtOperator<V> | HsLteOperator<V>
declare type HsGtOperator<V> = {
  $gt: V
}
declare type HsGteOperator<V> = {
  $gte: V
}
declare type HsLtOperator<V> = {
  $lt: V
}
declare type HsLteOperator<V> = {
  $lte: V
}
declare type HsIlikeOperator<V> = V extends string
  ? {
      $ilike: string
    }
  : never
declare type HsHasOperator<V> = V extends null | unknown[] | object
  ? never
  : [
      {
        $has: V
      },
    ]
declare type HsIncludesOperator<V> = {
  $includes:
    | V
    | {
        $any: V[]
      }
    | {
        $all: V[]
      }
}
declare type UgcSystemHeapTableName = 'users'
interface HqlSelectQuery {
  from: HqlFrom
  select: HqlSelect
  distinct?: boolean
  where?: CqlWhere
  group?: CqlSelectAlias[]
  having?: CqlHaving
  order?: HqlOrder
  limit?: number
  offset?: number
  resPlainJson?: boolean
  resTakeFirst?: boolean
}
declare type HqlFrom = HqlTable | HqlSubQuery
declare type HqlTable = {
  kind: 'table'
  heapType: HeapObjectType
}
declare type HqlSubQuery = {
  kind: 'sub'
  query: HqlSelectQuery
}
declare type HqlExpr = HqlField | HqlExprFn | HqlExprAgg | CqlDynParam
declare type HqlField = HqlTableField | HqlSubQueryField
declare type HqlTableField = HqlSystemColumn | HqlDataField
declare type HqlSubQueryField = HqlSubPlainField | HqlSubJsonField
declare type HqlSystemColumn = {
  kind: 'sys'
  name: HqlSystemColumnName
}
declare type HqlSystemColumnName = typeof allowedHqlSystemColumns[number]
declare const allowedHqlSystemColumns: readonly ['id', 'createdAt', 'updatedAt', 'createdBy', 'updatedBy']
declare type HqlDataField = {
  kind: 'data'
  path: string | CqlDeepPath
  type: CqlFieldType
}
declare type HqlSubPlainField = {
  kind: 'subPlain'
  name: string
}
declare type HqlSubJsonField = {
  kind: 'subJson'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type HqlExprFn = {
  kind: 'fn'
  fn: string
  args: Array<HqlExpr>
}
declare type HqlExprAgg = {
  kind: 'agg'
  fn: string
  args: [CqlAsterisk] | Array<CqlDynParam | HqlField | HqlExprFnNoAgg>
  distinct?: boolean
}
declare type HqlExprFnNoAgg = {
  kind: 'fn'
  fn: string
  args: Array<HqlField | HqlExprFnNoAgg | CqlDynParam>
}
declare type HqlSelect = Record<string, HqlExpr>
declare type HqlOrder = HqlSimpleOrderBy | Array<HqlSingleOrderBy>
declare type HqlSingleOrderBy = HqlSimpleOrderBy | [HqlSimpleOrderBy, SortDirection]
declare type HqlSimpleOrderBy =
  | HqlSystemColumnName
  | string
  | HqlDataField
  | HqlSubJsonField
  | HqlOrderAliasField
  | HqlExprFn
declare type HqlOrderAliasField = {
  kind: 'aliasJson'
  path: CqlDeepPath
  type: CqlFieldType
}
interface ZSmartUnionable {
  $unionable: typeof hs.Unionable
}
interface ZType<HS extends hs.HeapSchema = hs.HeapSchema> {
  $static: HS['$static']
  $hsRuntime: HS['$hsRuntime']
  $hsCreateInput: HS['$hsCreateInput']
  $hsUpdateInput: HS['$hsUpdateInput']
  $hsFilterInput: HS['$hsFilterInput']
  $hsOrderInput: HS['$hsOrderInput']
  readonly kind: HS['kind']
  readonly title?: string
  readonly description?: string
  readonly examples?: unknown[]
  readonly deprecated?: boolean
  readonly customMeta?: Record<string, any>
  readonly defaultValue?: tb.Static<HS>
  parse(data: unknown): hs.HsRuntime<HS>
  safeParse(data: unknown): SafeParseReturnType<hs.HsRuntime<HS>>
  array(): ZArray<HS>
  describe(description: string): this
  meta(meta: hs.HsCommonOptions): this
  nullable(): hs.HsNonRequired<ZSmartUnion<[HS, hs.HsNull]>>
  optional(): hs.HsOptional<this>
  default(defaultValue: hs.NoUndefined<tb.Static<HS>>): hs.HsNonRequired<this>
}
interface HType<HS extends hs.HeapSchema> extends ZType<HS> {
  readonly searchable?: hs.HsSearchable['searchable']
  array(): HArray<HS>
  meta(meta: hs.HsSearchableOptions): this
  nullable(): hs.HsNonRequired<HSmartUnion<[HS, hs.HsNull]>>
}
declare type ZTypeOptsWithDefault<HS extends hs.HeapSchema> = hs.HsCommonOptions & {
  defaultValue?: tb.Static<HS>
}
declare type HTypeOptsWithDefault<HS extends hs.HeapSchema> = hs.HsCommonOptions &
  hs.HsSearchable & {
    defaultValue?: tb.Static<HS>
  }
declare type SafeParseReturnType<Output> = SafeParseSuccess<Output> | SafeParseError
declare type SafeParseSuccess<Output> = {
  success: true
  data: Output
  error?: never
}
declare type SafeParseError = {
  success: false
  error: ValidationError
  data?: never
}
interface ZArrayCommon extends CustomArrayOpts, ZSmartUnionable {
  readonly type: 'array'
  min(minItems: number): this
  max(maxItems: number): this
  length(len: number): this
  skipInvalid(): this
}
interface ZArray<IHS extends hs.HeapSchema> extends ZType<hs.HsArray<IHS>>, ZArrayCommon {
  readonly items: ZType<IHS>
}
interface HArray<IHS extends hs.HeapSchema> extends HType<hs.HsArray<IHS>>, ZArrayCommon {
  readonly items: HType<IHS>
}
declare type ZArrayOpts<IHS extends hs.HeapSchema> = ZTypeOptsWithDefault<hs.HsArray<IHS>> & CustomArrayOpts
declare type HArrayOpts<IHS extends hs.HeapSchema> = HTypeOptsWithDefault<hs.HsArray<IHS>> & CustomArrayOpts
declare type CustomArrayOpts = Pick<
  hs.HsArrayOptions<hs.HeapSchema>,
  'uniqueItems' | 'minItems' | 'maxItems' | 'skipInvalidItems'
>
interface ZNullCommon extends ZSmartUnionable {
  readonly type: 'null'
}
interface ZNull extends ZType<hs.HsNull>, ZNullCommon {}
interface HNull extends ZType<hs.HsNull>, ZNullCommon {}
declare type ZNullOpts = hs.HsCommonOptions
declare type HNullOpts = hs.HsCommonOptions
interface ZSmartUnion<OHS extends readonly hs.HeapSchema[]> extends ZType<hs.HsUnion<OHS>> {
  readonly anyOf: ZSmartUnionAlternatives<OHS>
}
interface HSmartUnion<OHS extends readonly hs.HeapSchema[]> extends HType<hs.HsUnion<OHS>> {
  readonly anyOf: HSmartUnionAlternatives<OHS>
}
declare type ZSmartUnionOpts<OHS extends readonly hs.HeapSchema[]> = ZTypeOptsWithDefault<hs.HsUnion<OHS>>
declare type HSmartUnionOpts<OHS extends readonly hs.HeapSchema[]> = HTypeOptsWithDefault<hs.HsUnion<OHS>>
declare type ZSmartUnionAlternatives<OHS extends readonly hs.HeapSchema[]> = {
  [K in keyof OHS]: ZType<OHS[K]>
}
declare type HSmartUnionAlternatives<OHS extends readonly hs.HeapSchema[]> = {
  [K in keyof OHS]: HType<OHS[K]>
}
declare type ZAny<T> = ZType<hs.HsAny<T>>
declare type HAny<T> = HType<hs.HsAny<T>>
declare type ZAnyOpts<T> = ZTypeOptsWithDefault<hs.HsAny<T>>
declare type HAnyOpts<T> = HTypeOptsWithDefault<hs.HsAny<T>>
interface ZBooleanCommon extends ZSmartUnionable {
  readonly type: 'boolean'
}
interface ZBoolean extends ZType<hs.HsBoolean>, ZBooleanCommon {}
interface HBoolean extends HType<hs.HsBoolean>, ZBooleanCommon {}
declare type ZBooleanOpts = ZTypeOptsWithDefault<hs.HsBoolean>
declare type HBooleanOpts = HTypeOptsWithDefault<hs.HsBoolean>
interface ZCurrencyCommon extends ZSmartUnionable {
  readonly type: 'string'
  readonly pattern: string
}
interface ZCurrency extends ZType<hs.HsString>, ZCurrencyCommon {}
interface HCurrency extends HType<hs.HsString>, ZCurrencyCommon {}
declare type ZCurrencyOpts = ZTypeOptsWithDefault<hs.HsString>
declare type HCurrencyOpts = HTypeOptsWithDefault<hs.HsString>
interface ZDateCommon extends ZSmartUnionable {
  readonly type: 'string'
  readonly format: 'date-time'
}
interface ZDate extends ZType<hs.HsDateTime>, ZDateCommon {}
interface HDate extends HType<hs.HsDateTime>, ZDateCommon {}
declare type ZDateOpts = ZTypeOptsWithDefault<hs.HsDateTime>
declare type HDateOpts = HTypeOptsWithDefault<hs.HsDateTime>
interface ZEnumCommon<ES extends tb.TEnumKey[]> extends ZSmartUnionable {
  readonly anyOf: ES
}
interface ZEnum<ES extends tb.TEnumKey[]> extends ZType<hs.HsEnum<ES>>, ZEnumCommon<ES> {}
interface HEnum<ES extends tb.TEnumKey[]> extends HType<hs.HsEnum<ES>>, ZEnumCommon<ES> {}
declare type ZEnumOpts<ES extends tb.TEnumKey[]> = ZTypeOptsWithDefault<hs.HsEnum<ES>>
declare type HEnumOpts<ES extends tb.TEnumKey[]> = HTypeOptsWithDefault<hs.HsEnum<ES>>
declare type EnumTypeToSchema<ET extends tb.TEnumType> = tb.TEnumKey<ET[keyof ET]>[]
declare type EnumValue = string | number
interface ZNumericCommon extends ZSmartUnionable {
  readonly minimum?: number
  readonly exclusiveMinimum?: number
  readonly maximum?: number
  readonly exclusiveMaximum?: number
  readonly multipleOf?: number
  min(minimum: number): this
  gte(minimum: number): this
  gt(exclusiveMinimum: number): this
  max(maximum: number): this
  lte(maximum: number): this
  lt(exclusiveMaximum: number): this
  divisibleBy(multipleOf: number): this
}
interface ZNumberCommon extends ZNumericCommon {
  readonly type: 'number'
}
interface ZNumber extends ZType<hs.HsNumber>, ZNumberCommon {
  int(): NumberToInteger<this, ZInteger>
}
interface HNumber extends HType<hs.HsNumber>, ZNumberCommon {
  int(): NumberToInteger<this, HInteger>
}
declare type ZNumberOpts = ZTypeOptsWithDefault<hs.HsNumber> & CustomNumberOpts
declare type HNumberOpts = HTypeOptsWithDefault<hs.HsNumber> & CustomNumberOpts
declare type CustomNumberOpts = Pick<
  tb.NumberOptions,
  'exclusiveMinimum' | 'exclusiveMaximum' | 'minimum' | 'maximum' | 'multipleOf'
>
declare type NumberToInteger<T, Int extends hs.HeapSchema> = T extends hs.HsOptional<ZNumber>
  ? hs.HsOptional<Int>
  : T extends hs.HsNonRequired<ZNumber>
  ? hs.HsNonRequired<Int>
  : Int
interface ZIntegerCommon extends ZNumericCommon {
  readonly type: 'integer'
}
interface ZInteger extends ZType<hs.HsInteger>, ZIntegerCommon {}
interface HInteger extends HType<hs.HsInteger>, ZIntegerCommon {}
interface ZStringCommon extends ZSmartUnionable {
  readonly type: 'string'
  readonly minLength?: number
  readonly maxLength?: number
  readonly format?: 'date-time' | 'email'
  readonly pattern?: string
  datetime(): this
  email(): this
  length(len: number): this
  max(maxLength: number): this
  min(minLength: number): this
  nonempty(): this
  regex(pattern: string): this
}
interface ZString<S extends string = string> extends ZType<hs.HsString<S>>, ZStringCommon {}
interface HString<S extends string = string> extends HType<hs.HsString<S>>, ZStringCommon {}
declare type ZStringOpts<S extends string> = ZTypeOptsWithDefault<hs.HsString<S>> & CustomStringOpts
declare type HStringOpts<S extends string> = HTypeOptsWithDefault<hs.HsString<S>> & CustomStringOpts
declare type CustomStringOpts = Pick<
  tb.StringOptions<'date-time' | 'email'>,
  'format' | 'minLength' | 'maxLength' | 'pattern'
>
interface ZFunctionRouteRefCommon extends ZSmartUnionable {
  readonly type: 'array'
  readonly additionalItems: false
  readonly minItems: number
  readonly maxItems: number
  readonly body: hs.HeapSchema
  readonly result: hs.HeapSchema
}
interface ZFuntionRouteRef<B, R> extends ZType<hs.HsFunctionRouteRef<B, R>>, ZFunctionRouteRefCommon {
  readonly items: readonly [ZNumber, ZString, ZString]
}
interface HFunctionRouteRef<B, R> extends HType<hs.HsFunctionRouteRef<B, R>>, ZFunctionRouteRefCommon {
  readonly items: readonly [HNumber, HString, HString]
}
declare type ZFunctionRouteRefOpts<B, R> = ZTypeOptsWithDefault<hs.HsFunctionRouteRef<B, R>>
declare type HFunctionRouteRefOpts<B, R> = ZTypeOptsWithDefault<hs.HsFunctionRouteRef<B, R>>
interface HGenericLink extends HType<hs.HsGenericLink>, ZSmartUnionable {
  readonly type: 'array'
  readonly additionalItems: false
  readonly minItems: number
  readonly maxItems: number
  readonly items: readonly [HString, HString]
  readonly onDelete: hs.HsGenericLink['onDelete']
}
declare type HGenericLinkOpts = Partial<hs.HsLinkOptions>
interface ZJobRouteRefCommon extends ZSmartUnionable {
  readonly type: 'array'
  readonly additionalItems: false
  readonly minItems: number
  readonly maxItems: number
  readonly body: hs.HeapSchema
}
interface ZJobRouteRef<B> extends ZType<hs.HsJobRouteRef<B>>, ZJobRouteRefCommon {
  readonly items: readonly [ZNumber, ZString, ZString]
}
interface HJobRouteRef<B> extends HType<hs.HsJobRouteRef<B>>, ZJobRouteRefCommon {
  readonly items: readonly [HNumber, HString, HString]
}
declare type ZJobRouteRefOpts<B> = ZTypeOptsWithDefault<hs.HsJobRouteRef<B>>
declare type HJobRouteRefOpts<B> = ZTypeOptsWithDefault<hs.HsJobRouteRef<B>>
interface ZLiteralCommon<T extends tb.TValue> extends ZSmartUnionable {
  readonly type: 'string' | 'number' | 'boolean'
  readonly const: T
}
interface ZLiteral<T extends tb.TValue> extends ZType<hs.HsLiteral<T>>, ZLiteralCommon<T> {}
interface HLiteral<T extends tb.TValue> extends HType<hs.HsLiteral<T>>, ZLiteralCommon<T> {}
declare type ZLiteralOpts = hs.HsCommonOptions
declare type HLiteralOpts = hs.HsSearchableOptions
interface ZMoneyCommon extends ZSmartUnionable {
  readonly type: 'array'
  readonly additionalItems: false
  readonly minItems: number
  readonly maxItems: number
}
interface ZMoney extends ZType<hs.HsMoney>, ZMoneyCommon {
  readonly items: readonly [ZNumber, ZCurrency]
}
interface HMoney extends HType<hs.HsMoney>, ZMoneyCommon {
  readonly items: readonly [HNumber, HCurrency]
}
declare type ZMoneyOpts = ZTypeOptsWithDefault<hs.HsMoney>
declare type HMoneyOpts = HTypeOptsWithDefault<hs.HsMoney>
interface ZObjectCommon extends ZSmartUnionable {
  readonly type: 'object'
  readonly required?: string[]
  readonly additionalProperties?: boolean
}
interface ZObject<HSP extends hs.HsProperties> extends ZType<hs.HsObject<HSP>>, ZObjectCommon {
  readonly properties: ZObjectProps<HSP>
}
interface HObject<HSP extends hs.HsProperties> extends HType<hs.HsObject<HSP>>, ZObjectCommon {
  readonly properties: HObjectProps<HSP>
}
declare type ZObjectOpts<HSP extends hs.HsProperties> = ZTypeOptsWithDefault<hs.HsObject<HSP>> & {
  additionalProperties?: boolean
}
declare type HObjectOpts<HSP extends hs.HsProperties> = HTypeOptsWithDefault<hs.HsObject<HSP>> & {
  additionalProperties?: boolean
}
declare type ZObjectProps<HSP extends hs.HsProperties> = {
  [K in keyof HSP]: ZType<HSP[K]>
}
declare type HObjectProps<HSP extends hs.HsProperties> = {
  [K in keyof HSP]: HType<HSP[K]>
}
interface ZRecordCommon extends ZSmartUnionable {
  readonly type: 'object'
  readonly additionalProperties: false
}
interface ZRecord<KHS extends hs.HsRecordKey, VHS extends hs.HeapSchema>
  extends ZType<hs.HsRecord<KHS, VHS>>,
    ZRecordCommon {
  readonly patternProperties: {
    [pattern: string]: ZType<VHS>
  }
}
interface HRecord<KHS extends hs.HsRecordKey, VHS extends hs.HeapSchema>
  extends HType<hs.HsRecord<KHS, VHS>>,
    ZRecordCommon {
  readonly patternProperties: {
    [pattern: string]: HType<VHS>
  }
}
declare type ZRecordOpts<KHS extends hs.HsRecordKey, VHS extends hs.HeapSchema> = ZTypeOptsWithDefault<
  hs.HsRecord<KHS, VHS>
>
declare type HRecordOpts<KHS extends hs.HsRecordKey, VHS extends hs.HeapSchema> = HTypeOptsWithDefault<
  hs.HsRecord<KHS, VHS>
>
interface HRefLink<T extends object> extends HType<hs.HsRefLink<T>>, ZSmartUnionable {
  readonly type: 'string'
  readonly targetType: HeapObjectType | UgcSystemHeapTableName
  readonly targetRepoOrTableName?: ReadOnlyHeapTableRepo<hs.HsProperties, unknown, unknown> | string
  readonly isSystemTarget: boolean
  readonly onDelete: hs.HsGenericLink['onDelete']
}
declare type HRefLinkOpts = Partial<hs.HsLinkOptions>
interface ZStorageFileCommon extends ZSmartUnionable {
  readonly type: 'string'
}
interface ZStorageFile extends ZType<hs.HsFile>, ZStorageFileCommon {}
interface HStorageFile extends ZType<hs.HsFile>, ZStorageFileCommon {}
declare type ZStorageFileOpts = ZTypeOptsWithDefault<hs.HsFile>
declare type HStorageFileOpts = ZTypeOptsWithDefault<hs.HsFile>
interface ZStorageImageFile extends ZType<hs.HsImageFile>, ZStorageFileCommon {}
interface HStorageImageFile extends ZType<hs.HsImageFile>, ZStorageFileCommon {}
interface ZStorageVideoFile extends ZType<hs.HsVideoFile>, ZStorageFileCommon {}
interface HStorageVideoFile extends ZType<hs.HsVideoFile>, ZStorageFileCommon {}
interface ZStorageAudioFile extends ZType<hs.HsAudioFile>, ZStorageFileCommon {}
interface HStorageAudioFile extends ZType<hs.HsAudioFile>, ZStorageFileCommon {}
interface ZTupleCommon extends ZSmartUnionable {
  readonly type: 'array'
  readonly additionalItems: false
  readonly minItems: number
  readonly maxItems: number
}
interface ZTuple<IHS extends hs.HeapSchema[]> extends ZType<hs.HsTuple<IHS>>, ZTupleCommon {
  readonly items: ZTupleAlternatives<IHS>
}
interface HTuple<IHS extends hs.HeapSchema[]> extends HType<hs.HsTuple<IHS>>, ZTupleCommon {
  readonly items: HTupleAlternatives<IHS>
}
declare type ZTupleOpts<IHS extends hs.HeapSchema[]> = ZTypeOptsWithDefault<hs.HsTuple<IHS>>
declare type HTupleOpts<IHS extends hs.HeapSchema[]> = HTypeOptsWithDefault<hs.HsTuple<IHS>>
declare type ZTupleAlternatives<IHS extends hs.HeapSchema[]> = {
  [K in keyof IHS]: ZType<IHS[K]>
}
declare type HTupleAlternatives<IHS extends hs.HeapSchema[]> = {
  [K in keyof IHS]: HType<IHS[K]>
}
interface ZUndefinedCommon extends ZSmartUnionable {
  readonly type: 'undefined'
}
interface ZUndefined extends ZType<hs.HsUndefined>, ZUndefinedCommon {}
interface HUndefined extends ZType<hs.HsUndefined>, ZUndefinedCommon {}
declare type ZUndefinedOpts = hs.HsCommonOptions
declare type HUndefinedOpts = hs.HsCommonOptions
declare type ZUnknown = ZType<hs.HsUnknown>
declare type HUnknown = HType<hs.HsUnknown>
declare type ZUnknownOpts = ZTypeOptsWithDefault<hs.HsUnknown>
declare type HUnknownOpts = HTypeOptsWithDefault<hs.HsUnknown>
interface SchemaBuilder {
  any<T = any>(options?: ZAnyOpts<T>): ZAny<T>
  array<IHS extends hs.HeapSchema>(items: IHS, options?: ZArrayOpts<IHS>): ZArray<IHS>
  array<IHS extends hs.HeapSchema>(items: ZType<IHS>, options?: ZArrayOpts<IHS>): ZArray<IHS>
  boolean(options?: ZBooleanOpts): ZBoolean
  currency(options?: ZCurrencyOpts): ZCurrency
  date(options?: ZDateOpts): ZDate
  enum<ET extends tb.TEnumType>(items: ET, options?: ZEnumOpts<EnumTypeToSchema<ET>>): ZEnum<EnumTypeToSchema<ET>>
  enum<T extends EnumValue, EV extends readonly [T, ...T[]]>(
    items: EV,
    opts?: ZEnumOpts<tb.TEnumKey<EV[number]>[]>,
  ): ZEnum<tb.TEnumKey<EV[number]>[]>
  functionRouteRef<B extends hs.HeapSchema, R extends hs.HeapSchema>(
    bs: B,
    rs: R,
    options?: ZFunctionRouteRefOpts<B['$hsRuntime'], R['$hsRuntime']>,
  ): ZFuntionRouteRef<B['$hsRuntime'], R['$hsRuntime']>
  /** @deprecated use s.functionRouteRef instead */
  interAppCallRouteRef<B extends hs.HeapSchema, R extends hs.HeapSchema>(
    bs: B,
    rs: R,
    options?: ZFunctionRouteRefOpts<B['$hsRuntime'], R['$hsRuntime']>,
  ): ZFuntionRouteRef<B['$hsRuntime'], R['$hsRuntime']>
  jobRouteRef<B extends hs.HeapSchema>(bs: B, options?: ZJobRouteRefOpts<B>): ZJobRouteRef<B['$hsRuntime']>
  literal<T extends tb.TValue>(value: T, options?: ZLiteralOpts): ZLiteral<T>
  money(options?: ZMoneyOpts): ZMoney
  null(options?: ZNullOpts): ZNull
  nullable<HS extends hs.HeapSchema>(innerType: ZType<HS>): hs.HsNonRequired<ZSmartUnion<[HS, hs.HsNull]>>
  number(options?: ZNumberOpts): ZNumber
  object<HSP extends hs.HsProperties>(properties: hs.HsPropertiesNo$<HSP>, options?: ZObjectOpts<HSP>): ZObject<HSP>
  optional<Z extends ZType<hs.HeapSchema>>(innerType: Z): hs.HsOptional<Z>
  record<KHS extends hs.HsRecordKey, VHS extends hs.HeapSchema>(
    key: KHS | ZType<KHS>,
    value: VHS | ZType<VHS>,
    options?: ZRecordOpts<KHS, VHS>,
  ): ZRecord<KHS, VHS>
  smartUnion<OHS extends UnionConstructorInput[]>(items: OHS, options?: ZSmartUnionOpts<OHS>): ZSmartUnion<OHS>
  storageFile(options?: ZStorageFileOpts): ZStorageFile
  storageImageFile(options?: ZStorageFileOpts): ZStorageImageFile
  storageVideoFile(options?: ZStorageFileOpts): ZStorageVideoFile
  storageAudioFile(options?: ZStorageFileOpts): ZStorageAudioFile
  string<S extends string = string>(options?: ZStringOpts<S>): ZString<S>
  tuple<IHS extends hs.HeapSchema[]>(items: [...IHS], options?: ZTupleOpts<IHS>): ZTuple<IHS>
  undefined(options?: ZUndefinedOpts): ZUndefined
  unknown(options?: ZUnknownOpts): ZUnknown
}
interface TableSchemaBuilder {
  any<T = any>(options?: HAnyOpts<T>): HAny<T>
  array<IHS extends hs.HeapSchema>(items: IHS, options?: HArrayOpts<IHS>): HArray<IHS>
  array<IHS extends hs.HeapSchema>(items: ZType<IHS>, options?: HArrayOpts<IHS>): HArray<IHS>
  boolean(options?: HBooleanOpts): HBoolean
  currency(options?: HCurrencyOpts): HCurrency
  date(options?: HDateOpts): HDate
  enum<ET extends tb.TEnumType>(items: ET, options?: HEnumOpts<EnumTypeToSchema<ET>>): HEnum<EnumTypeToSchema<ET>>
  enum<T extends EnumValue, EV extends readonly [T, ...T[]]>(
    items: EV,
    opts?: HEnumOpts<tb.TEnumKey<EV[number]>[]>,
  ): HEnum<tb.TEnumKey<EV[number]>[]>
  genericLink(options?: HGenericLinkOpts): HGenericLink
  functionRouteRef<B extends hs.HeapSchema, R extends hs.HeapSchema>(
    bs: B,
    rs: R,
    options?: HFunctionRouteRefOpts<B['$hsRuntime'], R['$hsRuntime']>,
  ): HFunctionRouteRef<B['$hsRuntime'], R['$hsRuntime']>
  /** @deprecated use s.functionRouteRef instead */
  interAppCallRouteRef<B extends hs.HeapSchema, R extends hs.HeapSchema>(
    bs: B,
    rs: R,
    options?: HFunctionRouteRefOpts<B['$hsRuntime'], R['$hsRuntime']>,
  ): HFunctionRouteRef<B['$hsRuntime'], R['$hsRuntime']>
  jobRouteRef<B extends hs.HeapSchema>(bs: B, options?: HJobRouteRefOpts<B>): HJobRouteRef<B['$hsRuntime']>
  literal<T extends tb.TValue>(value: T, options?: HLiteralOpts): HLiteral<T>
  money(options?: HMoneyOpts): HMoney
  null(options?: HNullOpts): HNull
  nullable<HS extends hs.HeapSchema>(innerType: HType<HS>): hs.HsNonRequired<HSmartUnion<[HS, hs.HsNull]>>
  number(options?: HNumberOpts): HNumber
  object<HSP extends hs.HsProperties>(properties: hs.HsPropertiesNo$<HSP>, options?: HObjectOpts<HSP>): HObject<HSP>
  optional<Z extends HType<hs.HeapSchema>>(innerType: Z): hs.HsOptional<Z>
  record<KHS extends hs.HsRecordKey, VHS extends hs.HeapSchema>(
    key: KHS | HType<KHS>,
    value: VHS | HType<VHS>,
    options?: HRecordOpts<KHS, VHS>,
  ): HRecord<KHS, VHS>
  refLink<T extends Record<string, unknown>>(tableName: string, options?: HRefLinkOpts): HRefLink<T>
  refLink<HSP extends hs.HsProperties>(
    repo: UgcAnyHeapTableRepo<HSP>,
    options?: HRefLinkOpts,
  ): HRefLink<hs.HsRuntime<hs.HsObject<HSP & hs.HeapObjectBaseSchema>>>
  smartUnion<OHS extends UnionConstructorInput[]>(items: OHS, options?: HSmartUnionOpts<OHS>): HSmartUnion<OHS>
  storageFile(options?: HStorageFileOpts): HStorageFile
  storageImageFile(options?: HStorageFileOpts): HStorageImageFile
  storageVideoFile(options?: HStorageFileOpts): HStorageVideoFile
  storageAudioFile(options?: HStorageFileOpts): HStorageAudioFile
  string<S extends string = string>(options?: HStringOpts<S>): HString<S>
  tuple<IHS extends hs.HeapSchema[]>(items: [...IHS], options?: HTupleOpts<IHS>): HTuple<IHS>
  undefined(options?: HUndefinedOpts): HUndefined
  unknown(options?: HUnknownOpts): HUnknown
}
declare type UgcPluginAppVmInfo = Pick<UgcCtxPluginApp, 'appId' | 'appSlug' | 'directoryPath'> & {
  /** @deprecated use codeAccount.id */
  hostAccId: number
  /** @deprecated use codeAccount.name */
  hostAccName: string
  codeAccount: UgcCtxAccount
}
declare type LogLevel = 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace' | 'unknown'
declare type UgcKvOpts = {
  [key: string]: string | number | undefined
}
declare type LogParams = {
  err?: Error
  kv?: UgcKvOpts
  json?: unknown
  level?: LogLevel
  msg?: string | number
}
declare type LogParamsNoMsg = Omit<LogParams, 'msg'>
declare class UgcHttpResponseTuner {
  #private
  statusCode: number | undefined
  simplifiedContentType: SimplifiedContentType
  setHeader(name: string, value: string): this
  getHeader(name: string): string | undefined
  hasHeader(name: string): boolean
  removeHeader(name: string): this
  get headers(): Array<[string, string]> | undefined
  setCookie(name: string, value: string, options?: CookieOptions): this
  getCookie(name: string): CookieInfo | undefined
  hasCookie(name: string): boolean
  /**
   * Sends cookie header that tells the browser to delete cookie with this name and (optionally) path.
   * Don't mix up with removeCookie method below
   */
  clearCookie(name: string, options?: Omit<CookieOptions, 'expires' | 'maxAge'>): this
  /**
   * Remove cookie definition "command" previously defined during this request.
   * This method doesn't delete actually set cookie in browser!
   * Don't mix up with clearCookie which sends header that tells browser - delete this cookie.
   */
  removeCookie(name: string): this
  get cookies(): CookieInfo[] | undefined
  setStatusCode(code: number): this
  setSimplifiedContentType(type: SimplifiedContentType): this
  screen<T = unknown>(data: T): T
  json<T = unknown>(data: T): T
  html<T = unknown>(data: T): T
  plain<T = unknown>(data: T): T
  redirect(location: string, statusCode?: number): this
}
declare type SimplifiedContentType = 'screen' | 'json' | 'html' | 'plain' | 'unknown'
interface CookieInfo extends CookieOptions {
  name: string
  value: string
}
interface CookieOptions {
  expires?: Date
  maxAge?: number
  path?: string
  sameSite?: boolean | 'lax' | 'strict' | 'none'
}
interface UgcErrorResponse {
  success: false
  errorType?: string
  statusCode: number
  reason?: string
  stack?: string
  __type__?: 'getScreen' | 'apiCall' | 'getHtml'
  [key: string]: unknown
}
declare class CtxConsole {
  private logFn?
  constructor(
    logFn?:
      | import('isolated-vm').Reference<
          (level: 'log' | 'error' | 'warn' | 'info' | 'debug', ...args: unknown[]) => void
        >
      | undefined,
  )
  debug(...args: unknown[]): void
  log(...args: unknown[]): void
  info(...args: unknown[]): void
  warn(...args: unknown[]): void
  error(...args: unknown[]): void
  private writeLog
}
/**
 * Context provided to end-user code enriched with some helper methods
 */
export declare class RichUgcCtxDef
  implements Omit<UgcCtx, 'account' | 'app' | 'auth1' | 'rc' | 'router' | 'user2' | 'user1'>
{
  readonly account: RichUgcAccount
  readonly auth?: UgcCtxBaseAuth & {
    expiresAt?: Date
  }
  readonly authSession?: UgcAuthSession
  readonly app: {
    readonly account: {
      readonly id: number
      readonly host: string
      readonly name: string
      readonly apiCall: typeof apiCall
      readonly navigate: typeof navigate
      readonly owner: UgcCtxUser1 | null
      url(path: string): string
      externalUrl(path: string): string
    }
    readonly apiCall: typeof apiCall
    readonly navigate: typeof navigate
    readonly user: UgcCtxUser1 | null
    url(path: string): string
  }
  readonly env: UgcCtx['env']
  readonly entryModule: {
    id: string
    filePath: string
  }
  readonly location: UgcCtxLocation | undefined
  readonly rc: UgcCtxRc
  /** @deprecated use ctx.entryModule instead */
  readonly router: Pick<DeprecatedCtxRouter, 'filePath' | 'urlPath'>
  readonly session: UgcCtx['session']
  readonly timeZone: UgcCtx['timeZone']
  readonly user?: UgcSmartUser
  readonly req: UntypedUgcRouteParsedRequest
  readonly resp: UgcHttpResponseTuner
  readonly console: CtxConsole
  readonly traceId: string
  readonly routeType?: UgcCtxRouteType
  private _lang
  /** accountId -> bundles */
  private langBundles
  /**
   * List of langs, whose bundles are actually loaded in langBundles and are effective for the ctx.t calls.
   * This list is used to preserve consistent logic when transferring translation for the client-side (browser) code.
   */
  private __effectiveLangs__
  private __keyLangPerAccount__
  /**
   * Same as langBundles but may contain empty slots in bundle lists for each account.
   * Helps to match lang bundles with order of __effectiveLangs__.
   * @see RichUgcCtxHiddenLangFeatures
   * @see getUntranslatedI18nKeys
   */
  private rawLangBundles
  constructor(ctx: UgcCtx, ctxFns: CtxOutsideFns, req: UgcRouteRequest)
  constructor(ctx: UgcInternalCtx, ctxFns: CtxOutsideFns)
  log(...args: unknown[]): void
  /**
   * @deprecated use import { requireAnyUser, requireRealUser } from '@app/auth'
   */
  getOrCreateUser(): Promise<UgcCtxUser1>
  toJSON(): UgcInternalCtx
  t(key: string, args?: TranslateArgs): string
  t(key: string | undefined, args?: TranslateArgs): string | undefined
  t(key: string | null, args?: TranslateArgs): string | null
  t(key: TranslationKey, args?: DynamicTranslateArgs): string
  t(key: TranslationKey | undefined, args?: DynamicTranslateArgs): string | undefined
  t(key: TranslationKey | null, args?: DynamicTranslateArgs): string | null
  t(key: TranslationKey | string, args?: TranslateArgs): string
  t<T extends null | undefined>(key: null | undefined, args?: TranslateArgs): T
  get lang(): Lang
  /**
   * Optionaly changes the current request lang and loads corresponding lang bundles (translations),
   *  so all necessary translations are available synchronously for ctx.t function
   */
  updateAndLoadLang(lang?: Lang): Promise<Lang>
}
declare type DeprecatedCtxRouter = UgcCtx['router'] & {
  params: Record<string, unknown>
  readonly apiCall: typeof apiCall
  readonly navigate: typeof navigate
  setParam(key: string, val: unknown): Promise<void>
  url(path: string): string
  redirect(path: string): never
}
declare type UgcCtxRouteType = UgcRouteType | 'hook'
declare type InitializerCtx = RichUgcCtx | ClientCtx
declare type ClientCtx = {
  t: RichUgcCtx['t']
  user: RichUgcCtx['user']
  account: {
    url(path: string): string
  }
  location: RichUgcCtx['location']
}
declare type SolidComponent<Props> = {
  (
    props: Props & {
      ctx: InitializerCtx
    },
  ): any
  __solidComponent: true
  __exportInfo: ExportInfo
}
declare type CustomHtmlElement<Props> =
  | ((props: Props, ...children: Array<jsx.JSX.Child>) => jsx.JSX.Child)
  | SolidComponent<any>
declare type JSONEvent = {
  type: string
  [prop: string]: any
}
declare type HtmlEvent = Function | string | JSONEvent | Array<HtmlEvent>
interface FormEvents {
  onblur?: HtmlEvent
  onchange?: HtmlEvent
  onfocus?: HtmlEvent
  onformchange?: HtmlEvent
  onforminput?: HtmlEvent
  oninput?: HtmlEvent
  oninvalid?: HtmlEvent
  onselect?: HtmlEvent
  onsubmit?: HtmlEvent
}
interface MediaEvents {
  onabort?: HtmlEvent
  oncanplay?: HtmlEvent
  oncanplaythrough?: HtmlEvent
  ondurationchange?: HtmlEvent
  onemptied?: HtmlEvent
  onended?: HtmlEvent
  onerror?: HtmlEvent
  onloadeddata?: HtmlEvent
  onloadedmetadata?: HtmlEvent
  onloadstart?: HtmlEvent
  onpause?: HtmlEvent
  onplay?: HtmlEvent
  onplaying?: HtmlEvent
  onprogress?: HtmlEvent
  onratechange?: HtmlEvent
  onreadystatechange?: HtmlEvent
  onseeked?: HtmlEvent
  onseeking?: HtmlEvent
  onstalled?: HtmlEvent
  onsuspend?: HtmlEvent
  ontimeupdate?: HtmlEvent
  onvolumechange?: HtmlEvent
  onwaiting?: HtmlEvent
}
declare type HtmlClassObjectAttribute = {
  [name: string]: boolean
}
declare type HtmlClassAttribute =
  | null
  | undefined
  | string
  | HtmlClassObjectAttribute
  | Array<string | HtmlClassObjectAttribute | null | undefined>
declare type HtmlStyleObjectAttribute = {
  [name: string]: string | number
}
declare type HtmlStyleAttribute =
  | string
  | HtmlStyleObjectAttribute
  | null
  | undefined
  | Array<string | HtmlStyleObjectAttribute | null | undefined>
interface HtmlTag {
  innerHTML?: string
  accesskey?: string
  class?: HtmlClassAttribute
  contenteditable?: string
  dir?: string
  hidden?: string | boolean
  id?: string
  role?: string
  lang?: string
  draggable?: string | boolean
  spellcheck?: string | boolean
  style?: HtmlStyleAttribute
  tabindex?: string
  title?: string
  translate?: string | boolean
  oncontextmenu?: HtmlEvent
  onkeydown?: HtmlEvent
  onkeypress?: HtmlEvent
  onkeyup?: HtmlEvent
  onclick?: HtmlEvent
  ondblclick?: HtmlEvent
  ondrag?: HtmlEvent
  ondragend?: HtmlEvent
  ondragenter?: HtmlEvent
  ondragleave?: HtmlEvent
  ondragover?: HtmlEvent
  ondragstart?: HtmlEvent
  ondrop?: HtmlEvent
  onmousedown?: HtmlEvent
  onmousemove?: HtmlEvent
  onmouseout?: HtmlEvent
  onmouseover?: HtmlEvent
  onmouseup?: HtmlEvent
  onmousewheel?: HtmlEvent
  onscroll?: HtmlEvent
  portal?: ('body-start' | 'body-end' | 'head-start' | 'head-end') | (string & {})
  portalDedupe?: boolean
}
interface HtmlAnchorTag extends HtmlTag {
  href?: string
  target?: string
  download?: string
  ping?: string
  rel?: string
  media?: string
  hreflang?: string
  type?: string
}
interface HtmlAreaTag extends HtmlTag {
  alt?: string
  coords?: string
  shape?: string
  href?: string
  target?: string
  ping?: string
  rel?: string
  media?: string
  hreflang?: string
  type?: string
}
interface HtmlAudioTag extends HtmlTag, MediaEvents {
  src?: string
  autobuffer?: string
  autoplay?: string
  loop?: string
  controls?: string
}
interface BaseTag extends HtmlTag {
  href?: string
  target?: string
}
interface HtmlQuoteTag extends HtmlTag {
  cite?: string
}
interface HtmlBodyTag extends HtmlTag {
  onafterprint?: HtmlEvent
  onbeforeprint?: HtmlEvent
  onbeforeonload?: HtmlEvent
  onblur?: HtmlEvent
  onerror?: HtmlEvent
  onfocus?: HtmlEvent
  onhaschange?: HtmlEvent
  onload?: HtmlEvent
  onmessage?: HtmlEvent
  onoffline?: HtmlEvent
  ononline?: HtmlEvent
  onpagehide?: HtmlEvent
  onpageshow?: HtmlEvent
  onpopstate?: HtmlEvent
  onredo?: HtmlEvent
  onresize?: HtmlEvent
  onstorage?: HtmlEvent
  onundo?: HtmlEvent
  onunload?: HtmlEvent
}
interface HtmlButtonTag extends HtmlTag {
  action?: string
  autofocus?: string
  disabled?: string
  enctype?: string
  form?: string
  method?: string
  name?: string
  novalidate?: string | boolean
  target?: string
  type?: string
  value?: string
}
interface HtmlDataListTag extends HtmlTag {}
interface HtmlCanvasTag extends HtmlTag {
  width?: string
  height?: string
}
interface HtmlTableColTag extends HtmlTag {
  span?: string
}
interface HtmlTableSectionTag extends HtmlTag {}
interface HtmlTableRowTag extends HtmlTag {}
interface DataTag extends HtmlTag {
  value?: string
}
interface HtmlEmbedTag extends HtmlTag, MediaEvents {
  src?: string
  type?: string
  width?: string
  height?: string
  [anything: string]: any
}
interface HtmlFieldSetTag extends HtmlTag, FormEvents {
  disabled?: string
  form?: string
  name?: string
}
interface HtmlFormTag extends HtmlTag, FormEvents {
  acceptCharset?: string
  action?: string
  autocomplete?: string
  enctype?: string
  method?: string
  name?: string
  novalidate?: string | boolean
  target?: string
}
interface HtmlHtmlTag extends HtmlTag {
  manifest?: string
}
interface HtmlIFrameTag extends HtmlTag {
  src?: string
  srcdoc?: string
  name?: string
  sandbox?: string
  seamless?: string
  width?: string
  height?: string
}
interface HtmlImageTag extends HtmlTag, MediaEvents {
  alt?: string
  src?: string
  crossorigin?: string
  usemap?: string
  ismap?: string
  width?: string
  height?: string
}
interface HtmlInputTag extends HtmlTag, FormEvents {
  accept?: string
  action?: string
  alt?: string
  autocomplete?: string
  autofocus?: string
  checked?: string | boolean
  disabled?: string | boolean
  enctype?: string
  form?: string
  height?: string
  list?: string
  max?: string
  maxlength?: string
  method?: string
  min?: string
  multiple?: string
  name?: string
  novalidate?: string | boolean
  pattern?: string
  placeholder?: string
  readonly?: boolean
  required?: boolean
  size?: string
  src?: string
  step?: string
  target?: string
  type?: string
  value?: string
  width?: string
}
interface HtmlModTag extends HtmlTag {
  cite?: string
  datetime?: string | Date
}
interface KeygenTag extends HtmlTag {
  autofocus?: string
  challenge?: string
  disabled?: string
  form?: string
  keytype?: string
  name?: string
}
interface HtmlLabelTag extends HtmlTag {
  form?: string
  for?: string
}
interface HtmlLITag extends HtmlTag {
  value?: string | number
}
interface HtmlLinkTag extends HtmlTag {
  href?: string
  crossorigin?: string
  rel?: string
  media?: string
  hreflang?: string
  type?: string
  sizes?: string
  integrity?: string
}
interface HtmlMapTag extends HtmlTag {
  name?: string
}
interface HtmlMetaTag extends HtmlTag {
  name?: string
  httpEquiv?: string
  content?: string
  charset?: string
}
interface HtmlMeterTag extends HtmlTag {
  value?: string | number
  min?: string | number
  max?: string | number
  low?: string | number
  high?: string | number
  optimum?: string | number
}
interface HtmlObjectTag extends HtmlTag, MediaEvents {
  data?: string
  type?: string
  name?: string
  usemap?: string
  form?: string
  width?: string
  height?: string
}
interface HtmlOListTag extends HtmlTag {
  reversed?: string
  start?: string | number
}
interface HtmlOptgroupTag extends HtmlTag {
  disabled?: string
  label?: string
}
interface HtmlOptionTag extends HtmlTag {
  disabled?: string
  label?: string
  selected?: boolean
  value?: string
}
interface HtmlOutputTag extends HtmlTag {
  for?: string
  form?: string
  name?: string
}
interface HtmlParamTag extends HtmlTag {
  name?: string
  value?: string
}
interface HtmlProgressTag extends HtmlTag {
  value?: string | number
  max?: string | number
}
interface HtmlCommandTag extends HtmlTag {
  type?: string
  label?: string
  icon?: string
  disabled?: string
  checked?: string
  radiogroup?: string
  default?: string
}
interface HtmlLegendTag extends HtmlTag {}
interface HtmlBrowserButtonTag extends HtmlTag {
  type?: string
}
interface HtmlMenuTag extends HtmlTag {
  type?: string
  label?: string
}
interface HtmlScriptTag extends HtmlTag {
  src?: string
  type?: string
  charset?: string
  async?: boolean
  defer?: boolean
  crossorigin?: string
  integrity?: string
  text?: string
}
interface HtmlDetailsTag extends HtmlTag {
  open?: string
}
interface HtmlSelectTag extends HtmlTag {
  autofocus?: string
  disabled?: string
  form?: string
  multiple?: string
  name?: string
  required?: string
  size?: string
}
interface HtmlSourceTag extends HtmlTag {
  src?: string
  type?: string
  media?: string
}
interface HtmlStyleTag extends HtmlTag {
  media?: string
  type?: string
  disabled?: string
  scoped?: string
}
interface HtmlTableTag extends HtmlTag {}
interface HtmlTableDataCellTag extends HtmlTag {
  colspan?: string | number
  rowspan?: string | number
  headers?: string
}
interface HtmlTextAreaTag extends HtmlTag {
  autofocus?: string
  cols?: string
  dirname?: string
  disabled?: string
  form?: string
  maxlength?: string
  minlength?: string
  name?: string
  placeholder?: string
  readonly?: string
  required?: string
  rows?: string
  wrap?: string
}
interface HtmlTableHeaderCellTag extends HtmlTag {
  colspan?: string | number
  rowspan?: string | number
  headers?: string
  scope?: string
}
interface HtmlTimeTag extends HtmlTag {
  datetime?: string | Date
}
interface HtmlTrackTag extends HtmlTag {
  default?: string
  kind?: string
  label?: string
  src?: string
  srclang?: string
}
interface HtmlVideoTag extends HtmlTag, MediaEvents {
  src?: string
  poster?: string
  autobuffer?: string
  autoplay?: string
  loop?: string
  controls?: string
  width?: string
  height?: string
}
interface HtmlSvgTag extends HtmlTag {
  [anything: string]: any
}
interface HtmlSvgPathTag extends HtmlTag {
  [anything: string]: any
}
interface HtmlJsxIntrinsicElements {
  a: HtmlAnchorTag
  abbr: HtmlTag
  address: HtmlTag
  area: HtmlAreaTag
  article: HtmlTag
  aside: HtmlTag
  audio: HtmlAudioTag
  b: HtmlTag
  bb: HtmlBrowserButtonTag
  base: BaseTag
  bdi: HtmlTag
  bdo: HtmlTag
  blockquote: HtmlQuoteTag
  body: HtmlBodyTag
  br: HtmlTag
  button: HtmlButtonTag
  canvas: HtmlCanvasTag
  caption: HtmlTag
  cite: HtmlTag
  code: HtmlTag
  col: HtmlTableColTag
  colgroup: HtmlTableColTag
  commands: HtmlCommandTag
  data: DataTag
  datalist: HtmlDataListTag
  dd: HtmlTag
  del: HtmlModTag
  details: HtmlDetailsTag
  dfn: HtmlTag
  div: HtmlTag
  dl: HtmlTag
  dt: HtmlTag
  em: HtmlTag
  embed: HtmlEmbedTag
  fieldset: HtmlFieldSetTag
  figcaption: HtmlTag
  figure: HtmlTag
  footer: HtmlTag
  form: HtmlFormTag
  h1: HtmlTag
  h2: HtmlTag
  h3: HtmlTag
  h4: HtmlTag
  h5: HtmlTag
  h6: HtmlTag
  head: HtmlTag
  header: HtmlTag
  hr: HtmlTag
  html: HtmlHtmlTag
  i: HtmlTag
  iframe: HtmlIFrameTag
  img: HtmlImageTag
  input: HtmlInputTag
  ins: HtmlModTag
  kbd: HtmlTag
  keygen: KeygenTag
  label: HtmlLabelTag
  legend: HtmlLegendTag
  li: HtmlLITag
  link: HtmlLinkTag
  main: HtmlTag
  map: HtmlMapTag
  mark: HtmlTag
  menu: HtmlMenuTag
  meta: HtmlMetaTag
  meter: HtmlMeterTag
  nav: HtmlTag
  noscript: HtmlTag
  object: HtmlObjectTag
  ol: HtmlOListTag
  optgroup: HtmlOptgroupTag
  option: HtmlOptionTag
  output: HtmlOutputTag
  p: HtmlTag
  param: HtmlParamTag
  pre: HtmlTag
  progress: HtmlProgressTag
  q: HtmlQuoteTag
  rb: HtmlTag
  rp: HtmlTag
  rt: HtmlTag
  rtc: HtmlTag
  ruby: HtmlTag
  s: HtmlTag
  samp: HtmlTag
  script: HtmlScriptTag
  section: HtmlTag
  select: HtmlSelectTag
  small: HtmlTag
  source: HtmlSourceTag
  span: HtmlTag
  strong: HtmlTag
  style: HtmlStyleTag
  sub: HtmlTag
  sup: HtmlTag
  table: HtmlTableTag
  tbody: HtmlTag
  td: HtmlTableDataCellTag
  template: HtmlTag
  textarea: HtmlTextAreaTag
  tfoot: HtmlTableSectionTag
  th: HtmlTableHeaderCellTag
  thead: HtmlTableSectionTag
  time: HtmlTimeTag
  title: HtmlTag
  tr: HtmlTableRowTag
  track: HtmlTrackTag
  u: HtmlTag
  ul: HtmlTag
  var: HtmlTag
  video: HtmlVideoTag
  wbr: HtmlTag
  svg: HtmlSvgTag
  path: HtmlSvgPathTag
}
declare type AttributeValue =
  | number
  | string
  | Date
  | boolean
  | string[]
  | HtmlClassAttribute
  | HtmlStyleAttribute
  | HtmlEvent
  | ((...args: any[]) => any)
declare class HtmlNode {
  readonly tag: string
  readonly attributes: Attributes
  readonly children: ReadonlyArray<HtmlNodeChild>
  portalValuesById: Map<string, PortalValuesHolder> | undefined
  portalTargetIds: Set<string> | undefined
  augmentCreatedHtmlElement: undefined | ((document: Document, element: Node) => void)
  private readonly mutableChildren
  constructor(tag: string, attributes: Attributes, children: Array<HtmlNodeChild | undefined>)
  appendChild(...children: Array<HtmlNodeChild | undefined | null>): void
}
declare class PortalValue {
  readonly portalId: string
  readonly children: HtmlNodeChild
  readonly dedupe: boolean
  constructor(portalId: string, children: HtmlNodeChild, dedupe: boolean)
}
declare class PortalValuesHolder {
  readonly portalId: string
  readonly values: Array<PortalValue>
  constructor(portalId: string)
  add(value: PortalValue): this
  addAll(holder: PortalValuesHolder): this
}
declare class PortalRenderTarget {
  readonly portalId: string
  constructor(portalId: string)
}
declare type HtmlNodeChild =
  | string
  | number
  | HtmlNode
  | PortalRenderTarget
  | PortalValue
  | ReadonlyArray<HtmlNodeChild>
declare type Attributes = Record<string, AttributeValue>
export declare type SmartTextProps = TextProps & {
  size?: number | StandardFontSize
  color?: Color
}
export declare type SmartImageProps = Omit<ImageProps, 'src'> & {
  src: ImageProps['src'] | string
}
export declare type UGCIntrinsicElements = Omit<V2IntrinsicElements, 'text' | 'image'> & {
  text: SmartTextProps
  image: SmartImageProps
  img: SmartImageProps
  section: BoxProps
  b: SmartTextProps
  p: SmartTextProps
}
export declare function jsx(block: BlockFactory | string, props?: AnyObject, ...children: Array<any>): JsxNode
export declare namespace jsx {
  const Fragment: typeof JsxFragment
  namespace JSX {
    type IntrinsicElements = UGCIntrinsicElements
  }
}
declare type BlockFactory = (props?: AnyObject, ...children: JsxNode[]) => JsxNode
declare type JsxNode =
  | ChatiumChildNode
  | ChatiumChildNode[]
  | ChatiumScreen
  | Promise<ChatiumChildNode | ChatiumChildNode[] | ChatiumScreen>
declare type RouteRunCtx = InitializerCtx
interface HttpRouteRef<P extends PS, Q extends QS> {
  readonly routerUrlPath: string
  readonly pattern: string
  readonly needParams: boolean | null
  /** For routes with star param it's allowed to pass the param itself instead of the object with a '*' key */
  (
    params: P extends hs.HsObject<{
      '*': hs.HsStringFriendly
    }>
      ? VTC<P['properties']['*']> | VTC<P>
      : VTC<P>,
  ): this
  query(queryParams: VTC<Q>): this
  path(): string
  url(): string
}
declare type RouteRefHandlerFn<B extends BS, P extends PS, Q extends QS, Result> = (
  url: string,
  ctx: RichUgcCtx,
  req: UgcRouteParsedRequest<VTC<B>, VTC<P>, VTC<Q>>,
) => PlainOrPromise<Result>
declare type RouteRefRunResult<T> = T extends Promise<any> ? T : Promise<T>
interface PostRouteRef<B extends BS, P extends PS, Q extends QS, Result> extends HttpRouteRef<P, Q> {
  run: IsOptionalBody<VTC<B>> extends true
    ? (ctx: RouteRunCtx, body?: VTC<B>) => RouteRefRunResult<Result>
    : (ctx: RouteRunCtx, body: VTC<B>) => RouteRefRunResult<Result>
}
declare function PostRouteRef<B extends BS, P extends PS, Q extends QS, Result>(
  pattern: string,
  handlerFn: RouteRefHandlerFn<B, P, Q, Result>,
  needParams: boolean | null,
  routerUrlPath: string | null,
  accountUrl: AccountUrlFn,
): PostRouteRef<B, P, Q, Result>
interface GetRouteRef<P extends PS, Q extends QS, Result> extends HttpRouteRef<P, Q> {
  navigate(options?: Parameters<typeof navigate>[1]): NavigateAction
  run(ctx: InitializerCtx): RouteRefRunResult<Result>
}
declare function GetRouteRef<P extends PS, Q extends QS, Result>(
  pattern: string,
  handlerFn: RouteRefHandlerFn<any, P, Q, Result>,
  needParams: boolean | null,
  routerUrlPath: string | null,
  accountUrl: AccountUrlFn,
): GetRouteRef<P, Q, Result>
interface ApiCallRouteRef<B extends BS, P extends PS, Q extends QS, Result> extends PostRouteRef<B, P, Q, Result> {
  apiCall: IsOptionalBody<VTC<B>> extends true
    ? (apiParams?: VTC<B>, options?: ApiCallOptions) => ApiCallAction
    : (apiParams: VTC<B>, options?: ApiCallOptions) => ApiCallAction
}
declare function ApiCallRouteRef<B extends BS, P extends PS, Q extends QS, Result>(
  pattern: string,
  handlerFn: RouteRefHandlerFn<B, P, Q, Result>,
  needParams: boolean | null,
  routerUrlPath: string | null,
  accountUrl: AccountUrlFn,
): ApiCallRouteRef<B, P, Q, Result>
declare type Middleware<Ctx, Req> = {
  <R>(ctx: Ctx, req: Req, next: () => R): R | Promise<R>
}
declare type UgcRoutesDefinitionMiddleware<B extends BS, P extends PS, Q extends QS> = Middleware<
  RichUgcCtx,
  UgcRouteParsedRequest<VTR<B>, VTR<P>, VTR<Q>>
>
declare type CustomRouteHandlerFn<B extends BS, P extends PS, Q extends QS> = (
  ctx: RichUgcCtx,
  req: UgcRouteParsedRequest<VTR<B>, VTR<P>, VTR<Q>>,
) => PlainOrPromise<UgcCustomHandlerResult>
declare type CustomRouteHandlerFnR<B extends BS, P extends PS, Q extends QS, R extends RS> = (
  ctx: RichUgcCtx,
  req: UgcRouteParsedRequest<VTR<B>, VTR<P>, VTR<Q>>,
) => PlainOrPromise<UgcCustomHandlerResultR<VT<R>>>
declare type UgcCustomHandlerResult = unknown | TuneHttpHeadersResponse | UgcErrorResponse
declare type UgcCustomHandlerResultR<R> = R | TuneHttpHeadersResponse<R> | UgcErrorResponse
declare type HtmlRouteHandlerFn<P extends PS, Q extends QS> = (
  ctx: RichUgcCtx,
  req: UgcRouteParsedRequest<any, VTR<P>, VTR<Q>>,
) => PlainOrPromise<UgcHtmlHandlerResult>
declare type UgcHtmlHandlerResult = htmlJsx.JSX.SingleElement | TuneHttpHeadersResponse<htmlJsx.JSX.SingleElement>
declare type ScreenRouteHandlerFn<P extends PS, Q extends QS> = (
  ctx: RichUgcCtx,
  req: UgcRouteParsedRequest<any, VTR<P>, VTR<Q>>,
) => PlainOrPromise<UgcScreenHandlerResult>
declare type UgcScreenHandlerResult = ScreenPropsV2 | ScreenSuccessResponseV2 | ScreenErrorResponseV2
declare type ApiCallRouteHandlerFn<B extends BS, P extends PS, Q extends QS> = (
  ctx: RichUgcCtx,
  req: UgcRouteParsedRequest<VTR<B>, VTR<P>, VTR<Q>>,
) => PlainOrPromise<UgcApiCallHandlerResult>
declare type UgcApiCallHandlerResult =
  | undefined
  | null
  | void
  | ChatiumActions
  | ApiCallResponseFields
  | ApiCallSuccessResponse
  | (UgcErrorResponse & ApiCallResponseFields)
declare type JobHandlerFn<P, R = void> = (ctx: RichUgcCtx, params: P) => PlainOrPromise<R>
declare type AppFunctionHandlerFn<P, R = unknown | void> = (
  ctx: RichUgcCtx,
  params: P,
  callerInfo: AppFunctionCallerInfo,
) => PlainOrPromise<R>
export declare type AppFunctionCallerInfo =
  | {
      type: 'plugin'
      appSlug: string
      appId: number
      codeAccount: UgcCtxAccount
    }
  | {
      type: 'account'
      codeAccount: UgcCtxAccount
    }
declare type GetReturnTypeOfHandler<Handler> = Handler extends
  | ScreenRouteHandlerFn<any, any>
  | HtmlRouteHandlerFn<any, any>
  | ApiCallRouteHandlerFn<any, any, any>
  | AppFunctionHandlerFn<any>
  ? ReturnType<Handler>
  : Handler extends CustomRouteHandlerFn<any, any, any>
  ? GetReturnTypeOfCustomRouteHandlerFn<ReturnType<Handler>>
  : never
declare type GetReturnTypeOfCustomRouteHandlerFn<V> = V extends TuneHttpHeadersResponse<infer Body> ? Body : V
/**
 * Initial full API, not narrowed by any context
 */
export interface RouteApi<B extends BS, P extends PS, Q extends QS> extends RouteApiWithoutUse<B, P, Q> {
  accountHook: typeof registerUgcHook
  pluginHook: typeof registerUgcHook
  table: HeapTableFn
  use(...middlewares: UgcRoutesDefinitionMiddleware<B, P, Q>[]): RouteApiWithUrl<B, P, Q>
  meta(meta: AnyObject): RouteApiNoHooks<B, P, Q>
}
interface RouteApiNoHooks<B extends BS, P extends PS, Q extends QS>
  extends RouteApiWithoutUse<B, P, Q>,
    CommonRouteApiWithUse<B, P, Q> {}
interface RouteApiWithoutUse<B extends BS, P extends PS, Q extends QS>
  extends GetRouteConstructors<P, Q>,
    PostRouteConstructors<B, P, Q>,
    InternalRouteConstructors {
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiWithBody<Schema, P, Q>
  body<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): RouteApiWithBody<hs.HsObject<Props>, P, Q>
  optionalBody<Schema extends hs.HeapSchema>(
    schema: SchemaOrBuilder<Schema>,
  ): RouteApiWithBody<hs.HsUnion<[Schema, hs.HsUndefined]>, P, Q>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithBody<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>, P, Q>
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithUrl<B, hs.HsObject<Props>, Q>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: SchemaOrBuilder<StarProp>,
  ): RouteApiWithUrl<
    B,
    hs.HsObject<{
      '*': StarProp
    }>,
    Q
  >
  query<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): RouteApiWithUrl<B, P, hs.HsObject<Props>>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiWithResult<B, P, Q, Schema>
  result<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithResult<B, P, Q, hs.HsObject<Props>>
}
interface RouteApiWithResult<B extends BS, P extends PS, Q extends QS, R extends RS>
  extends GetRouteConstructorsR<P, Q, R>,
    PostRouteConstructorsR<B, P, Q, R>,
    InternalRouteConstructorsR<R> {
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiWithBodyR<Schema, P, Q, R>
  body<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithBodyR<hs.HsObject<Props>, P, Q, R>
  optionalBody<Schema extends hs.HeapSchema>(
    schema: SchemaOrBuilder<Schema>,
  ): RouteApiWithBodyR<hs.HsUnion<[Schema, hs.HsUndefined]>, P, Q, R>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithBodyR<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>, P, Q, R>
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithUrlR<B, hs.HsObject<Props>, Q, R>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: SchemaOrBuilder<StarProp>,
  ): RouteApiWithUrlR<
    B,
    hs.HsObject<{
      '*': StarProp
    }>,
    Q,
    R
  >
  query<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithUrlR<B, P, hs.HsObject<Props>, R>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiWithResult<B, P, Q, Schema>
  result<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithResult<B, P, Q, hs.HsObject<Props>>
}
interface CommonRouteApi {
  meta(meta: AnyObject): this
}
interface CommonRouteApiWithUse<B extends BS, P extends PS, Q extends QS> extends CommonRouteApi {
  use(...middlewares: UgcRoutesDefinitionMiddleware<B, P, Q>[]): this
}
interface RouteApiWithBody<B extends BS, P extends PS, Q extends QS>
  extends CommonRouteApi,
    PostRouteConstructors<B, P, Q>,
    InternalRouteConstructorsWithBody<B> {
  use(...middlewares: UgcRoutesDefinitionMiddleware<B, P, Q>[]): RouteApiWithUrl<B, P, Q>
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiWithBody<Schema, P, Q>
  body<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): RouteApiWithBody<hs.HsObject<Props>, P, Q>
  optionalBody<Schema extends hs.HeapSchema>(
    schema: SchemaOrBuilder<Schema>,
  ): RouteApiWithBody<hs.HsUnion<[Schema, hs.HsUndefined]>, P, Q>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithBody<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>, P, Q>
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithUrl<B, hs.HsObject<Props>, Q>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: SchemaOrBuilder<StarProp>,
  ): RouteApiWithBody<
    B,
    hs.HsObject<{
      '*': StarProp
    }>,
    Q
  >
  query<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): RouteApiWithUrl<B, P, hs.HsObject<Props>>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiWithBodyR<B, P, Q, Schema>
  result<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithBodyR<B, P, Q, hs.HsObject<Props>>
}
interface RouteApiWithBodyR<B extends BS, P extends PS, Q extends QS, R extends RS>
  extends CommonRouteApi,
    PostRouteConstructorsR<B, P, Q, R>,
    InternalRouteConstructorsWithBodyR<B, R> {
  use(...middlewares: UgcRoutesDefinitionMiddleware<B, P, Q>[]): RouteApiWithUrlR<B, P, Q, R>
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiWithBodyR<Schema, P, Q, R>
  body<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithBodyR<hs.HsObject<Props>, P, Q, R>
  optionalBody<Schema extends hs.HeapSchema>(
    schema: SchemaOrBuilder<Schema>,
  ): RouteApiWithBodyR<hs.HsUnion<[Schema, hs.HsUndefined]>, P, Q, R>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithBodyR<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>, P, Q, R>
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithUrlR<B, hs.HsObject<Props>, Q, R>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: SchemaOrBuilder<StarProp>,
  ): RouteApiWithUrlR<
    B,
    hs.HsObject<{
      '*': StarProp
    }>,
    Q,
    R
  >
  query<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithUrlR<B, P, hs.HsObject<Props>, R>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiWithBodyR<B, P, Q, Schema>
  result<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithBodyR<B, P, Q, hs.HsObject<Props>>
}
interface RouteApiWithUrl<B extends BS, P extends PS, Q extends QS>
  extends CommonRouteApi,
    PostRouteConstructors<B, P, Q>,
    GetRouteConstructors<P, Q> {
  use(...middlewares: UgcRoutesDefinitionMiddleware<B, P, Q>[]): RouteApiWithUrl<B, P, Q>
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiPostOnly<Schema, P, Q>
  body<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): RouteApiPostOnly<hs.HsObject<Props>, P, Q>
  optionalBody<Schema extends hs.HeapSchema>(
    schema: SchemaOrBuilder<Schema>,
  ): RouteApiPostOnly<hs.HsUnion<[Schema, hs.HsUndefined]>, P, Q>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiPostOnly<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>, P, Q>
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithUrl<B, hs.HsObject<Props>, Q>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: SchemaOrBuilder<StarProp>,
  ): RouteApiPostOnly<
    B,
    hs.HsObject<{
      '*': StarProp
    }>,
    Q
  >
  query<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): RouteApiWithUrl<B, P, hs.HsObject<Props>>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiWithUrlR<B, P, Q, Schema>
  result<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithUrlR<B, P, Q, hs.HsObject<Props>>
}
interface RouteApiWithUrlR<B extends BS, P extends PS, Q extends QS, R extends RS>
  extends CommonRouteApi,
    PostRouteConstructorsR<B, P, Q, R>,
    GetRouteConstructorsR<P, Q, R> {
  use(...middlewares: UgcRoutesDefinitionMiddleware<B, P, Q>[]): RouteApiWithUrlR<B, P, Q, R>
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiPostOnlyR<Schema, P, Q, R>
  body<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiPostOnlyR<hs.HsObject<Props>, P, Q, R>
  optionalBody<Schema extends hs.HeapSchema>(
    schema: SchemaOrBuilder<Schema>,
  ): RouteApiPostOnly<hs.HsUnion<[Schema, hs.HsUndefined]>, P, Q>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiPostOnly<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>, P, Q>
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithUrl<B, hs.HsObject<Props>, Q>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: SchemaOrBuilder<StarProp>,
  ): RouteApiPostOnly<
    B,
    hs.HsObject<{
      '*': StarProp
    }>,
    Q
  >
  query<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): RouteApiWithUrl<B, P, hs.HsObject<Props>>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiWithUrlR<B, P, Q, Schema>
  result<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiWithUrlR<B, P, Q, hs.HsObject<Props>>
}
interface RouteApiPostOnly<B extends BS, P extends PS, Q extends QS>
  extends CommonRouteApi,
    PostRouteConstructors<B, P, Q> {
  use(...middlewares: UgcRoutesDefinitionMiddleware<B, P, Q>[]): RouteApiPostOnly<B, P, Q>
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiPostOnly<Schema, P, Q>
  body<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): RouteApiPostOnly<hs.HsObject<Props>, P, Q>
  optionalBody<Schema extends hs.HeapSchema>(
    schema: SchemaOrBuilder<Schema>,
  ): RouteApiPostOnly<hs.HsUnion<[Schema, hs.HsUndefined]>, P, Q>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiPostOnly<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>, P, Q>
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiPostOnly<B, hs.HsObject<Props>, Q>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: SchemaOrBuilder<StarProp>,
  ): RouteApiPostOnly<
    B,
    hs.HsObject<{
      '*': StarProp
    }>,
    Q
  >
  query<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): RouteApiPostOnly<B, P, hs.HsObject<Props>>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiPostOnlyR<B, P, Q, Schema>
  result<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiPostOnlyR<B, P, Q, hs.HsObject<Props>>
}
interface RouteApiPostOnlyR<B extends BS, P extends PS, Q extends QS, R extends RS>
  extends CommonRouteApi,
    PostRouteConstructorsR<B, P, Q, R> {
  use(...middlewares: UgcRoutesDefinitionMiddleware<B, P, Q>[]): RouteApiPostOnlyR<B, P, Q, R>
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiPostOnlyR<Schema, P, Q, R>
  body<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiPostOnlyR<hs.HsObject<Props>, P, Q, R>
  optionalBody<Schema extends hs.HeapSchema>(
    schema: SchemaOrBuilder<Schema>,
  ): RouteApiPostOnlyR<hs.HsUnion<[Schema, hs.HsUndefined]>, P, Q, R>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiPostOnlyR<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>, P, Q, R>
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiPostOnlyR<B, hs.HsObject<Props>, Q, R>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: SchemaOrBuilder<StarProp>,
  ): RouteApiPostOnlyR<
    B,
    hs.HsObject<{
      '*': StarProp
    }>,
    Q,
    R
  >
  query<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiPostOnlyR<B, P, hs.HsObject<Props>, R>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): RouteApiPostOnlyR<B, P, Q, Schema>
  result<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): RouteApiPostOnlyR<B, P, Q, hs.HsObject<Props>>
}
interface GetRouteConstructors<P extends PS, Q extends QS> {
  get(pattern: string): GetRouteApi<P, Q>
  get<Handler extends CustomRouteHandlerFn<hs.HsUndefined, P, Q>>(
    pattern: string,
    handler: Handler,
  ): GetRouteRef<P, Q, GetReturnTypeOfHandler<Handler>>
  html(pattern: string): HtmlRouteApi<P, Q>
  html<Handler extends HtmlRouteHandlerFn<P, Q>>(
    pattern: string,
    handler: Handler,
  ): GetRouteRef<P, Q, GetReturnTypeOfHandler<Handler>>
  screen(pattern: string): ScreenRouteApi<P, Q>
  screen<Handler extends ScreenRouteHandlerFn<P, Q>>(
    pattern: string,
    handler: Handler,
  ): GetRouteRef<P, Q, GetReturnTypeOfHandler<Handler>>
}
interface GetRouteConstructorsR<P extends PS, Q extends QS, R extends RS> {
  get(pattern: string): GetRouteApiR<P, Q, R>
  get<Handler extends CustomRouteHandlerFnR<hs.HsUndefined, P, Q, R>>(
    pattern: string,
    handler: Handler,
  ): GetRouteRef<P, Q, VT<R>>
}
interface PostRouteConstructors<B extends BS, P extends PS, Q extends QS> {
  post(pattern: string): PostRouteApi<B, P, Q>
  post<Handler extends CustomRouteHandlerFn<B, P, Q>>(
    pattern: string,
    handler: Handler,
  ): PostRouteRef<B, P, Q, GetReturnTypeOfHandler<Handler>>
  apiCall(pattern: string): ApiCallRouteApi<B, P, Q>
  apiCall<Handler extends ApiCallRouteHandlerFn<B, P, Q>>(
    pattern: string,
    handler: Handler,
  ): ApiCallRouteRef<B, P, Q, GetReturnTypeOfHandler<Handler>>
}
interface PostRouteConstructorsR<B extends BS, P extends PS, Q extends QS, R extends RS> {
  post(pattern: string): PostRouteApiR<B, P, Q, R>
  post<Handler extends CustomRouteHandlerFnR<B, P, Q, R>>(
    pattern: string,
    handler: Handler,
  ): PostRouteRef<B, P, Q, VT<R>>
}
interface InternalRouteConstructors {
  job(path: string): JobRouteApi
  job<P extends JSONInputValue | undefined>(
    path: string,
    handler: JobHandlerFn<P, unknown | void>,
  ): JobRouteRefNoSchema<P>
  function(path: string): AppFunctionRouteApi
  function<P, Handler extends AppFunctionHandlerFn<P>>(
    path: string,
    handler: Handler,
  ): FunctionRouteRefNoSchema<P, GetReturnTypeOfHandler<Handler>>
  /** @deprecated use app.function() instead */
  interAppCall(path: string): AppFunctionRouteApi
  /** @deprecated use app.function() instead */
  interAppCall<P, Handler extends AppFunctionHandlerFn<P>>(
    path: string,
    handler: Handler,
  ): FunctionRouteRefNoSchema<P, GetReturnTypeOfHandler<Handler>>
}
interface InternalRouteConstructorsWithBody<B extends BS> {
  job(path: string): JobRouteApiWithBody<B>
  job(path: string, handler: JobHandlerFn<VTR<B>, unknown | void>): JobRouteRef<B>
  function(path: string): FunctionRouteApiWithBody<B>
  function<Handler extends AppFunctionHandlerFn<VTR<B>>>(
    path: string,
    handler: Handler,
  ): FunctionRouteRefNoResultSchema<VTC<B>, GetReturnTypeOfHandler<Handler>>
  /** @deprecated use app.function() instead */
  interAppCall(path: string): FunctionRouteApiWithBody<B>
  /** @deprecated use app.function() instead */
  interAppCall<Handler extends AppFunctionHandlerFn<VTR<B>>>(
    path: string,
    handler: Handler,
  ): FunctionRouteRefNoResultSchema<VTC<B>, GetReturnTypeOfHandler<Handler>>
}
interface InternalRouteConstructorsR<R extends RS> {
  function(path: string): FunctionRouteApiR<R>
  function<P>(path: string, handler: AppFunctionHandlerFn<P, VTC<R>>): FunctionRouteRefNoBodySchema<P, VTR<R>>
  /** @deprecated use app.function() instead */
  interAppCall(path: string): FunctionRouteApiR<R>
  /** @deprecated use app.function() instead */
  interAppCall<P>(path: string, handler: AppFunctionHandlerFn<P, VTC<R>>): FunctionRouteRefNoBodySchema<P, VTR<R>>
}
interface InternalRouteConstructorsWithBodyR<B extends BS, R extends RS> {
  function(path: string): FunctionRouteApiWithBodyR<B, R>
  function(path: string, handler: AppFunctionHandlerFn<VTR<B>, VTC<R>>): FunctionRouteRef<VTC<B>, VTR<R>>
  /** @deprecated use app.function() instead */
  interAppCall(path: string): FunctionRouteApiWithBodyR<B, R>
  /** @deprecated use app.function() instead */
  interAppCall(path: string, handler: AppFunctionHandlerFn<VTR<B>, VTC<R>>): FunctionRouteRef<VTC<B>, VTR<R>>
}
interface GetRouteApi<P extends PS, Q extends QS> extends CommonRouteApiWithUse<hs.HsUndefined, P, Q> {
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): GetRouteApi<hs.HsObject<Props>, Q>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: StarProp,
  ): GetRouteApi<
    hs.HsObject<{
      '*': StarProp
    }>,
    Q
  >
  query<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): GetRouteApi<P, hs.HsObject<Props>>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): GetRouteApiR<P, Q, Schema>
  result<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): GetRouteApiR<P, Q, hs.HsObject<Props>>
  handle<Handler extends CustomRouteHandlerFn<hs.HsUndefined, P, Q>>(
    handler: Handler,
  ): GetRouteRef<P, Q, GetReturnTypeOfHandler<Handler>>
}
interface GetRouteApiR<P extends PS, Q extends QS, R extends RS> extends CommonRouteApiWithUse<hs.HsUndefined, P, Q> {
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): GetRouteApiR<hs.HsObject<Props>, Q, R>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: SchemaOrBuilder<StarProp>,
  ): GetRouteApiR<
    hs.HsObject<{
      '*': StarProp
    }>,
    Q,
    R
  >
  query<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): GetRouteApiR<P, hs.HsObject<Props>, R>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): GetRouteApiR<P, Q, Schema>
  result<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): GetRouteApiR<P, Q, hs.HsObject<Props>>
  handle<Handler extends CustomRouteHandlerFnR<hs.HsUndefined, P, Q, R>>(handler: Handler): GetRouteRef<P, Q, VT<R>>
}
interface HtmlRouteApi<P extends PS, Q extends QS> extends CommonRouteApiWithUse<hs.HsUndefined, P, Q> {
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): HtmlRouteApi<hs.HsObject<Props>, Q>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: SchemaOrBuilder<StarProp>,
  ): HtmlRouteApi<
    hs.HsObject<{
      '*': StarProp
    }>,
    Q
  >
  query<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): HtmlRouteApi<P, hs.HsObject<Props>>
  handle<Handler extends HtmlRouteHandlerFn<P, Q>>(handler: Handler): GetRouteRef<P, Q, GetReturnTypeOfHandler<Handler>>
}
interface ScreenRouteApi<P extends PS, Q extends QS> extends CommonRouteApiWithUse<hs.HsUndefined, P, Q> {
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): ScreenRouteApi<hs.HsObject<Props>, Q>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: SchemaOrBuilder<StarProp>,
  ): ScreenRouteApi<
    hs.HsObject<{
      '*': StarProp
    }>,
    Q
  >
  query<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): ScreenRouteApi<P, hs.HsObject<Props>>
  handle<Handler extends ScreenRouteHandlerFn<P, Q>>(
    handler: Handler,
  ): GetRouteRef<P, Q, GetReturnTypeOfHandler<Handler>>
}
interface PostRouteApi<B extends BS, P extends PS, Q extends QS> extends CommonRouteApiWithUse<B, P, Q> {
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): PostRouteApi<Schema, P, Q>
  body<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): PostRouteApi<hs.HsObject<Props>, P, Q>
  optionalBody<Schema extends hs.HeapSchema>(schema: Schema): PostRouteApi<hs.HsUnion<[Schema, hs.HsUndefined]>, P, Q>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): PostRouteApi<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>, P, Q>
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): PostRouteApi<B, hs.HsObject<Props>, Q>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: SchemaOrBuilder<StarProp>,
  ): PostRouteApi<
    B,
    hs.HsObject<{
      '*': StarProp
    }>,
    Q
  >
  query<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): PostRouteApi<B, P, hs.HsObject<Props>>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): PostRouteApiR<B, P, Q, Schema>
  result<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): PostRouteApiR<B, P, Q, hs.HsObject<Props>>
  handle<Handler extends CustomRouteHandlerFn<B, P, Q>>(
    handler: Handler,
  ): PostRouteRef<B, P, Q, GetReturnTypeOfHandler<Handler>>
}
interface PostRouteApiR<B extends BS, P extends PS, Q extends QS, R extends RS> extends CommonRouteApiWithUse<B, P, Q> {
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): PostRouteApiR<Schema, P, Q, R>
  body<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): PostRouteApiR<hs.HsObject<Props>, P, Q, R>
  optionalBody<Schema extends hs.HeapSchema>(
    schema: SchemaOrBuilder<Schema>,
  ): PostRouteApiR<hs.HsUnion<[Schema, hs.HsUndefined]>, P, Q, R>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): PostRouteApiR<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>, P, Q, R>
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): PostRouteApiR<B, hs.HsObject<Props>, Q, R>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: SchemaOrBuilder<StarProp>,
  ): PostRouteApiR<
    B,
    hs.HsObject<{
      '*': StarProp
    }>,
    Q,
    R
  >
  query<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): PostRouteApiR<B, P, hs.HsObject<Props>, R>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): PostRouteApiR<B, P, Q, Schema>
  result<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): PostRouteApiR<B, P, Q, hs.HsObject<Props>>
  handle<Handler extends CustomRouteHandlerFnR<B, P, Q, R>>(handler: Handler): PostRouteRef<B, P, Q, VT<R>>
}
interface ApiCallRouteApi<B extends BS, P extends PS, Q extends QS> extends CommonRouteApiWithUse<B, P, Q> {
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): ApiCallRouteApi<Schema, P, Q>
  body<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): ApiCallRouteApi<hs.HsObject<Props>, P, Q>
  optionalBody<Schema extends hs.HeapSchema>(
    schema: SchemaOrBuilder<Schema>,
  ): ApiCallRouteApi<hs.HsUnion<[Schema, hs.HsUndefined]>, P, Q>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): ApiCallRouteApi<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>, P, Q>
  pathParams<Props extends hs.HsStringFriendlyProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): ApiCallRouteApi<B, hs.HsObject<Props>, Q>
  pathParams<StarProp extends hs.HsStringFriendly>(
    propSchema: SchemaOrBuilder<StarProp>,
  ): ApiCallRouteApi<
    B,
    hs.HsObject<{
      '*': StarProp
    }>,
    Q
  >
  query<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): ApiCallRouteApi<B, P, hs.HsObject<Props>>
  handle<Handler extends CustomRouteHandlerFn<B, P, Q>>(
    handler: Handler,
  ): ApiCallRouteRef<B, P, Q, GetReturnTypeOfHandler<Handler>>
}
interface JobRouteApi extends CommonRouteApi {
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): JobRouteApiWithBody<Schema>
  body<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): JobRouteApiWithBody<hs.HsObject<Props>>
  optionalBody<Schema extends hs.HeapSchema>(schema: Schema): JobRouteApiWithBody<hs.HsUnion<[Schema, hs.HsUndefined]>>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): JobRouteApiWithBody<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>>
  handle<P extends JSONInputValue | undefined>(handler: JobHandlerFn<P, unknown | void>): JobRouteRefNoSchema<P>
}
interface JobRouteApiWithBody<B extends BS> extends CommonRouteApi {
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): JobRouteApiWithBody<Schema>
  body<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): JobRouteApiWithBody<hs.HsObject<Props>>
  optionalBody<Schema extends hs.HeapSchema>(schema: Schema): JobRouteApiWithBody<hs.HsUnion<[Schema, hs.HsUndefined]>>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): JobRouteApiWithBody<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>>
  handle(handler: JobHandlerFn<VTR<B>, unknown | void>): JobRouteRef<VTC<B>>
}
interface AppFunctionRouteApi extends CommonRouteApi {
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): FunctionRouteApiWithBody<Schema>
  body<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): FunctionRouteApiWithBody<hs.HsObject<Props>>
  optionalBody<Schema extends hs.HeapSchema>(
    schema: SchemaOrBuilder<Schema>,
  ): FunctionRouteApiWithBody<hs.HsUnion<[Schema, hs.HsUndefined]>>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): FunctionRouteApiWithBody<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): FunctionRouteApiR<Schema>
  result<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): FunctionRouteApiR<hs.HsObject<Props>>
  handle<P, Handler extends AppFunctionHandlerFn<P>>(
    handler: Handler,
  ): FunctionRouteRefNoSchema<P, GetReturnTypeOfHandler<Handler>>
}
interface FunctionRouteApiWithBody<B extends BS> extends CommonRouteApi {
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): FunctionRouteApiWithBody<Schema>
  body<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): FunctionRouteApiWithBody<hs.HsObject<Props>>
  optionalBody<Schema extends hs.HeapSchema>(
    schema: SchemaOrBuilder<Schema>,
  ): FunctionRouteApiWithBody<hs.HsUnion<[Schema, hs.HsUndefined]>>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): FunctionRouteApiWithBody<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): FunctionRouteApiWithBodyR<B, Schema>
  result<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): FunctionRouteApiWithBodyR<B, hs.HsObject<Props>>
  handle<Handler extends AppFunctionHandlerFn<VTR<B>>>(
    handler: Handler,
  ): FunctionRouteRefNoResultSchema<VTC<B>, GetReturnTypeOfHandler<Handler>>
}
interface FunctionRouteApiR<R extends RS> extends CommonRouteApi {
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): FunctionRouteApiWithBodyR<Schema, R>
  body<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): FunctionRouteApiWithBodyR<hs.HsObject<Props>, R>
  optionalBody<Schema extends hs.HeapSchema>(
    schema: SchemaOrBuilder<Schema>,
  ): FunctionRouteApiWithBodyR<hs.HsUnion<[Schema, hs.HsUndefined]>, R>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): FunctionRouteApiWithBodyR<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>, R>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): FunctionRouteApiR<Schema>
  result<Props extends hs.HsProperties>(propSchema: SchemaOrBuilder<Props>): FunctionRouteApiR<hs.HsObject<Props>>
  handle<P>(handler: AppFunctionHandlerFn<P, VTC<R>>): FunctionRouteRefNoBodySchema<P, VTR<R>>
}
interface FunctionRouteApiWithBodyR<B extends BS, R extends RS> extends CommonRouteApi {
  body<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): FunctionRouteApiWithBodyR<Schema, R>
  body<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): FunctionRouteApiWithBodyR<hs.HsObject<Props>, R>
  optionalBody<Schema extends hs.HeapSchema>(
    schema: SchemaOrBuilder<Schema>,
  ): FunctionRouteApiWithBodyR<hs.HsUnion<[Schema, hs.HsUndefined]>, R>
  optionalBody<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): FunctionRouteApiWithBodyR<hs.HsUnion<[hs.HsObject<Props>, hs.HsUndefined]>, R>
  result<Schema extends hs.HeapSchema>(schema: SchemaOrBuilder<Schema>): FunctionRouteApiWithBodyR<B, Schema>
  result<Props extends hs.HsProperties>(
    propSchema: SchemaOrBuilder<Props>,
  ): FunctionRouteApiWithBodyR<B, hs.HsObject<Props>>
  handle(handler: AppFunctionHandlerFn<VTR<B>, VTC<R>>): FunctionRouteRef<VTC<B>, VTR<R>>
}
declare type SchemaOrBuilder<T> = T | ((s: SchemaBuilder) => T)
export declare namespace app {
  type Ctx = RichUgcCtx
  type Req<Body = any, PathParams = Record<string, string | undefined>, Query = ReqQuery> = UgcRouteParsedRequest<
    Body,
    PathParams,
    Query
  >
}

export {}
