export declare type CustomHookRegistration<Params, Result> = {
  hookName: string
  handler?: (ctx: RichUgcCtx, params: Params) => Promise<Result>
}
export declare function runHook<T = unknown>(ctx: RichUgcCtx, hookName: string, params: unknown): Promise<Array<T>>
export declare function runHook<Params, Result>(
  ctx: RichUgcCtx,
  hookRegistration: CustomHookRegistration<Params, Result>,
  params: Params,
): Promise<Array<Result>>
export declare function execHook<R = unknown>(
  ctx: RichUgcCtx,
  hookName: string,
  params: unknown,
): Promise<ExecHookResults<R>>
export declare function isExecHookResultSuccess<R>(result: ExecHookResult<R>): result is ExecHookResultSuccess<R>
export declare function isExecHookResultFailure(result: ExecHookResult<any>): result is ExecHookResultFailure
export declare type ExecHookResults<R> = ExecHookResult<R>[]
export declare type ExecHookResult<R> = ExecHookResultSuccess<R> | ExecHookResultFailure
export declare type ExecHookResultSuccess<R> = {
  success: true
  result: R
  handler?: ExecHookHandlerInfo
}
export declare type ExecHookResultFailure = {
  [key: string]: unknown
  success: false
  reason: string
  failedAt: 'ivm' | 'hook'
  errorType?: string
  handler?: ExecHookHandlerInfo
}
export declare type ExecHookHandlerInfo =
  | {
      type: 'plugin'
      appSlug: string
      appId: number
    }
  | {
      type: 'account'
    }
/**
 * Special value that can be returned by supported hook handlers (e.g., 404 hook)
 *  which allows to cache the fact that this is no-op hook and don't try to call it again.
 */
export declare const alwaysNoopHookResult: unique symbol

export {}
