import { Filter, OrderByDefinition, SortDirection } from 'core/db/dbQueryTypes'
import { HeapId, HeapObjectBaseRaw, HeapObjectType, HeapOrderBy } from 'core/heap/heapTypes'
import * as hs from 'core/heap/v2/heapSchemaTypes'
import { ReadOnlyHeapTableRepo } from 'core/heap/v2/HeapTableRepo'
import { QueryParamsOption } from 'lib/chatium-json'
import { Icon } from 'lib/chatium-json/v1'
import { DesktopLayout, PlainIconName } from 'lib/chatium-json/v2'
import { RichUgcAccount } from 'services/ugc-runner/runtime/context/RichUgcCtxAccount'
import {
  CreateIdentityParams,
  CreateRealUserCoreInfo,
  FindIdentitiesOptions,
  UgcIdentity,
  UgcRouteType,
} from 'services/ugc-runner/runtime/runtimeTypes'
import { UgcSmartUser } from 'services/ugc-runner/runtime/user/UgcSmartUser'
import { AnyObject, JSONInputObject, PublicFieldsOfClass } from 'utils/types'

interface CqlSelectQuery {
  from: CqlFrom
  select: CqlSelect
  distinct?: boolean
  where?: CqlWhere
  having?: CqlHaving
  order?: CqlOrder
  group?: CqlGroup
  limit?: number
  offset?: number
}
declare type CqlFrom = CqlTable | CqlSubQuery
declare type CqlTable = {
  kind: 'table'
  schema: string
  name: string
}
declare type CqlSubQuery = {
  kind: 'sub'
  query: CqlSelectQuery
}
declare type CqlSelect = Record<string, CqlExpr> | undefined
declare type CqlExpr = CqlPlainColumn | CqlExprFn | CqlDynParam | CqlJsonPath | CqlAsterisk
declare type CqlPlainColumn = {
  kind: 'col'
  name: string
  type?: CqlFieldType
}
declare type CqlExprFn = {
  kind: 'fn'
  fn: string
  args: CqlExpr[]
  distinct?: boolean
  type?: CqlFieldType
}
declare type CqlDynParam = {
  kind: 'dyn'
  value: unknown
  type?: CqlFieldType
}
declare type CqlJsonPath = {
  kind: 'json'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type CqlAsterisk = {
  kind: '*'
  type?: undefined
}
declare type CqlFieldType = 'string' | 'number' | 'boolean' | 'date' | 'json'
declare type CqlDeepPath = [string, ...(string | number)[]]
declare type CqlGroup = CqlSelectAlias[]
declare type CqlSelectAlias = string
declare type CqlWhere = Filter<any>
declare type CqlHaving = Filter<any>
declare type CqlOrder = OrderByDefinition<any>
declare type Lang = string
interface LangCtx {
  lang: Lang
}
declare abstract class ChatiumError extends Error {
  abstract readonly statusCode: number
  constructor(message?: string)
}
export declare class AccessDeniedError extends ChatiumError {
  readonly statusCode = 403
  constructor(message?: string)
}
declare type AccountUrlFn = {
  accountUrlParams: AccountUrlParams
  (path: string, options?: QueryParamsOption): string
}
interface AccountUrlParams {
  accountName: string
  accountHost: string
  accountPathPrefix: string
  pluginAppInfo?: UgcPluginAppUrlInfo
}
interface LocationCtx {
  location: Location | undefined
}
interface Location {
  country: string
  region: string
  timeZone: string
  city: string
  coordinates: Coordinates
}
interface Coordinates {
  latitude: number
  longitude: number
}
interface HsPropertiesWithOptions {
  [key: string]: hs.HeapSchema & hs.HsOptionsWithDefault<unknown>
}
declare type ReqQuery = Record<string, string | string[] | undefined>
declare type BS = hs.HeapSchema
declare type PS = hs.HsObject<hs.HsStringFriendlyProperties> | hs.HsRecord<hs.HsString, hs.HsString | hs.HsNumber>
declare type QS = hs.HsObject<HsPropertiesWithOptions> | hs.HsRecord<hs.HsString, hs.HeapSchema>
declare type RS = hs.HeapSchema
declare type RouteRefGetSchemaFn = (
  codeAccountId: number,
  routerUrlPath: string,
  routePattern: string,
  routeType: UgcRouteType,
) => Promise<RouteRefSchema>
declare type RouteRefSchema = {
  meta?: AnyObject
  bs?: BS
  ps?: PS
  qs?: QS
  rs?: RS
}
declare type TsVectorLangKey = 'ru' | 'en'
declare enum UserRole {
  Admin = 'Admin',
  Staff = 'Staff',
  Support = 'Support',
  ActiveSupport = 'ActiveSupport',
  Developer = 'Developer',
  BetaTester = 'BetaTester',
  User = 'User',
}
declare enum UserStatus {
  Imported = 'Imported',
  Joined = 'Joined',
  AsSupport = 'AsSupport',
  Left = 'Left',
}
declare const systemOnlyIdentityTypes: readonly ['Password', 'ApiKey', 'DeviceId', 'TechSupport', 'GetcourseId']
declare type Identity = PublicFieldsOfClass<IdentityHelperClass>
declare class IdentityHelperClass {
  id: string
  account_id: number
  user_id: string
  type: IdentityType
  key: string
  secret: string | null
  last_confirmed_at: Date | null
  is_primary: boolean
  is_blocked: boolean
  created_at: Date
  updated_at: Date
  confirmed_by: AuthProvider[]
  constructor(
    id: string,
    account_id: number,
    user_id: string,
    type: IdentityType,
    key: string,
    secret: string | null,
    last_confirmed_at: Date | null,
    is_primary: boolean,
    is_blocked: boolean,
    created_at: Date,
    updated_at: Date,
    confirmed_by: AuthProvider[],
  )
}
declare type IdentityType = CustomProvidableIdentityType | SystemOnlyIdentityType
declare type CustomProvidableIdentityType = 'Phone' | 'Email' | 'TelegramId' | 'ParentAccountUser' | string
declare type SystemOnlyIdentityType = typeof systemOnlyIdentityTypes[number]
export declare type AuthProvider =
  | 'Device'
  | 'Sms'
  | 'Email'
  | 'Password'
  | 'AnotherSession'
  | 'ParentAccount'
  | 'Getcourse'
  | 'MobileAppPhone'
  | 'MobileAppEmail'
  | 'Github'
  | 'Google'
  | 'Telegram'
  | 'Chatium'
  | string
declare type PrimaryIdentities = {
  phone?: string
  email?: string
  hasPassword?: boolean
}
declare abstract class SmartUser<Ctx> {
  private ctx
  private coreUser
  private extendedInfo?
  private primaryIdentities?
  protected abstract userApi: SmartUserApi<Ctx>
  protected abstract fileServiceDirectHost: string
  protected abstract fileServiceCdnHost: string
  constructor(
    ctx: LocationCtx,
    coreUser: UgcCtxUser2,
    extendedInfo?: ExtendedUserInfo | undefined,
    primaryIdentities?: PrimaryIdentities | undefined,
  )
  get id(): HeapId
  get type(): User2['type']
  get displayName(): string
  get confirmedPhone(): string | undefined
  get confirmedEmail(): string | undefined
  get accountRole(): AccountRole
  get username(): string | undefined
  get firstName(): string | undefined
  get middleName(): string | undefined
  get lastName(): string | undefined
  get fullName(): string
  get gender(): UserGender | undefined
  get birthdayDate(): Date | undefined
  get birthday(): string | undefined
  get passwordSalt(): string
  get hasPassword(): boolean
  updateAccountRole(ctx: Ctx, newRole: AccountRole): Promise<void>
  updateUsername(ctx: Ctx, username: string): Promise<void>
  updatePassword(ctx: Ctx, password: string): Promise<void>
  updateLang(ctx: Ctx, lang: Lang | null): Promise<void>
  updateExtendedInfo(ctx: Ctx, info: UpdateExtendedUserInfoRaw): Promise<void>
  get smartIconProps(): {
    url?: string
    name?: PlainIconName
    text?: string
  }
  get hasImage(): boolean
  get imageUrl(): string | undefined
  /**
   * Effective image hash XOR url
   * Mainly for copying image data from one user to another
   */
  get rawImageInfo(): {
    imageHash?: string
    imageUrl?: string
  }
  getImageThumbnailUrl(size?: number): string | undefined
  is(role: Exclude<AccountRole, 'None'>): boolean
  get lang(): Lang | undefined
  toJSON(): JSONInputObject
  serialize(): SerializedSmartUser | UgcCtxUser1
  getProfile<T extends JSONInputObject>(): T | undefined
  private get fsHost()
}
declare type SerializedSmartUser = [UgcCtxUser2, ExtendedUserInfo | undefined, PrimaryIdentities | undefined]
interface SmartUserApi<Ctx> {
  updateAccountRole(ctx: Ctx, userId: HeapId, newRole: AccountRole): Promise<AccountRole>
  updateUsername(ctx: Ctx, userId: HeapId, username: string): Promise<string>
  updateExtendedInfo(
    ctx: Ctx,
    userId: HeapId,
    info: UpdateExtendedUserInfo,
  ): Promise<[UgcCtxUser2, ExtendedUserInfo | undefined]>
  updatePassword(ctx: Ctx, userId: HeapId, password: string): Promise<void>
  updateLang(ctx: Ctx, userId: HeapId, lang: Lang | null): Promise<string | undefined>
}
export declare type ExtendedUserInfo = ExtendedUserFields & {
  displayName?: string
  profile?: JSONInputObject
}
export declare type UpdateExtendedUserInfo = {
  firstName?: string | null
  lastName?: string | null
  middleName?: string | null
  gender?: UserGender | null
  birthday?: string | null
  imageHash?: string | null
  imageUrl?: string | null
}
declare type UpdateExtendedUserInfoRaw = Pick<
  UpdateExtendedUserInfo,
  'firstName' | 'middleName' | 'lastName' | 'gender' | 'imageHash' | 'imageUrl'
> & {
  birthday?: string | Date | null
}
export declare type UserGender = 'male' | 'female' | 'other'
export declare type ExtendedUserFieldsSupport = Partial<Record<keyof ExtendedUserFields, boolean>>
declare type HashMediaType = 'file' | 'video' | 'image' | 'audio'
interface StorageUploadOptions {
  /** upload a non-public file */
  protected?: boolean
  /** allow only these media types (supported: image | video | audio) */
  mediaType?: HashMediaType | HashMediaType[]
  /** allow only these content type pattern(s) */
  contentType?: string | string[]
  /** allow only these file extensions */
  extension?: string | string[]
  /** minimum file size in bytes */
  minBytes?: number
  /** maximum file size in bytes */
  maxBytes?: number
  /** custom auth session authorizing URL expiration time in seconds, default is a week */
  expiresInSeconds?: number
}
declare abstract class BaseRefLink<T extends object, ReadCtx = unknown> {
  /**
   * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
   *
   * This is technical type, like written to heap-table "type" field,
   *  don't mix up with developer-defined table name provided to Heap.Table.
   * For system ref-links this also contains heap-type ('core.User' instead of 'users').
   */
  readonly type: HeapObjectType
  readonly id: HeapId
  /** Repository (table) that owns the row of this RefLink instance */
  readonly myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>
  /**
   * Repository (table) that owns the row of the target record.
   * Can be passed as table name or as repository instance.
   * When available, used in 'get' method implementation.
   */
  protected targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<hs.HsProperties, unknown, unknown> | undefined
  constructor(
    /**
     * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
     *
     * This is technical type, like written to heap-table "type" field,
     *  don't mix up with developer-defined table name provided to Heap.Table.
     * For system ref-links this also contains heap-type ('core.User' instead of 'users').
     */
    type: HeapObjectType,
    id: HeapId,
    /** Repository (table) that owns the row of this RefLink instance */
    myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>,
    /**
     * Repository (table) that owns the row of the target record.
     * Can be passed as table name or as repository instance.
     * When available, used in 'get' method implementation.
     */
    targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<hs.HsProperties, unknown, unknown> | undefined,
  )
  toJSON(): string
  toString(): string
  get<R = T>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  abstract getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface RefLinkClass {
  new (
    type: HeapObjectType,
    id: HeapId,
    myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>,
    targetRepoOrTableName?: ReadOnlyHeapTableRepo<hs.HsProperties, unknown> | string,
  ): BaseRefLink<AnyObject>
}
declare abstract class BaseGenericLink<ReadCtx = unknown> {
  readonly type: HeapObjectType
  readonly id: HeapId
  readonly myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>;
  [index: number]: HeapObjectType | HeapId
  readonly length = 2
  constructor(type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>)
  get<R = hs.HeapObjectBase>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  /** simulates the serialized format for compatibility */
  [Symbol.iterator](): IterableIterator<HeapObjectType | HeapId>
  toJSON(): GenericLinkJson
  toString(): string
  abstract getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface GenericLinkClass {
  new (type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>): BaseGenericLink
}
declare type GenericLinkJson = [HeapObjectType, HeapId]
declare type User2 = hs.HeapObjectBase & {
  type: 'Anonymous' | 'Real' | 'Bot'
  username?: string
  lang?: Lang
  timeZone?: string
  accountRole: AccountRole
  isBlocked: boolean
  knownChildAccounts?: number[]
} & ExtendedUserFields
declare type ExtendedUserFields = {
  firstName?: string
  lastName?: string
  middleName?: string
  gender?: UserGender
  birthday?: string
  imageHash?: string
  imageUrl?: string
}
export declare type AccountRole = typeof validAccountRoles[number]
declare const validAccountRoles: readonly ['None', 'Staff', 'Admin', 'Developer', 'Owner']
interface HeapLink<_HD extends HeapData> {
  type: HeapObjectType
  id: HeapId
}
declare type HeapObjectBaseV1 = HeapObjectBaseRaw & {
  idx: number
  createdBy: HeapLink<UserData> | null
  updatedBy: HeapLink<UserData> | null
}
declare type HeapData = {
  '~~heap~data~tag~~': never
}
declare type EraseHD<HD extends HeapData> = Omit<HD, keyof HeapData>
declare type RefLink<HD extends HeapData> = HD & {
  '~~ref~link~tag~~': never
}
declare type GenericLink = {
  '~~generic~link~tag~~': never
}
declare type HeapObjectV1<HD extends HeapData> = HeapObjectBaseV1 & MapHeapLinks<HD>
declare type MapHeapLinks<HD extends HeapData> = {
  [K in keyof EraseHD<HD>]: LinksMap<HD[K]>
}
declare type LinksMap<T> = T extends null
  ? null
  : T extends GenericLink
  ? HeapId
  : T extends RefLink<HeapData>
  ? HeapLink<T>
  : T
interface PurchasedProducts {
  [productName: string]: string | true | undefined
}
interface UserData extends HeapData {
  authId: number
  roles: UserRole[]
  status: UserStatus
  expiresAt: string | null
  avatar: Icon
  firstName: string | null
  lastName: string | null
  phone: string | null
  email: string | null
  platforms: EnvPlatform[]
  purchasedProducts: PurchasedProducts
}
declare type User1 = HeapObjectV1<UserData>
declare type UgcFileStorage = 'cgs' | 'db'
declare type CgsRepoVersion = string
declare type AccountAuthType = 'Email' | 'Phone' | 'Multi'
declare type UgcCodeVersion = CgsRepoVersion
interface UgcRouteRequest {
  method: UgcRequestMethod
  path: string
  /** instead of running the requested route itself, returns its schema */
  getSchema?: boolean
  query?: ReqQuery
  headers?: Record<string, string | undefined>
  body?: any
}
interface UgcRouteParsedRequest<Body, PathParams, Query> extends Omit<UgcRouteRequest, 'query' | 'body'> {
  body: Body
  params: PathParams
  query: Query
  /** like in node, without protocol and domain, starting with slash, normalized, includes query params */
  url: string
}
declare type AnyUgcRouteParsedRequest = UgcRouteParsedRequest<any, any, any>
declare type UgcRequestMethod = 'get' | 'post' | 'job' | 'function'
declare type UgcCtxUser1 = Pick<
  User1,
  'id' | 'firstName' | 'lastName' | 'roles' | 'avatar' | 'purchasedProducts' | 'phone' | 'email'
>
declare type UgcCtxUser2 = Pick<
  User2,
  | 'id'
  | 'type'
  | 'accountRole'
  | 'username'
  | 'firstName'
  | 'lastName'
  | 'middleName'
  | 'gender'
  | 'birthday'
  | 'imageHash'
  | 'imageUrl'
  | 'lang'
>
interface UgcPluginAppUrlInfo {
  appSlug: string
  /** path to the application root directory */
  directoryPath: string
}
interface UgcCtxAccount {
  id: number
  name: string
  host: string
  authType: AccountAuthType
  /** @deprecated use host instead */
  externalHost: string | null
  publishedVersion: string | null
  metaHash: string
  pathPrefix: string
}
interface EnvAvc {
  id: string
  signature: string
  accMap: Record<
    /** base account ID */
    number,
    [
      /** branch account ID */
      number,
      UgcFileStorage,
      UgcCodeVersion | null,
      /** expiration timestamp in seconds */
      number,
    ]
  >
}
interface OptionalEnvCtx {
  env: Env | null
}
interface Env {
  development: boolean
  production: boolean
  platform: EnvPlatform
  version: number
  appBuildNumber?: number
  ios: boolean
  android: boolean
  web: boolean
  job: boolean
  debugSocketId: string | null
  usePreviewMode: boolean
  useScopedPreviewMode: null | Record<string, boolean | null | undefined>
  viewportWidth: number | null
  viewportHeight: number | null
  devicePixelRatio: number
  alwaysHeader: boolean
  clientScope?: 'modal' | 'desktop' | 'ide'
  desktopLayout?: DesktopLayout
  acceptChatiumJson: boolean
  client?: ClientInfo
  avc?: EnvAvc
}
declare const EnvPlatform: {
  readonly iOS: 'iOS'
  readonly Android: 'Android'
  readonly Web: 'Web'
  readonly Job: 'Job'
}
declare type EnvPlatform = keyof typeof EnvPlatform
interface ClientInfo {
  ip: string
  deviceName: string
  osName: string
}
declare type HsSelectOptions<HSP extends hs.HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  limit?: number | null | undefined
  offset?: number | null | undefined
  order?: HsOrderBy<HSP> | null | undefined
}
declare type HsOrderBy<HSP extends hs.HsProperties> = HsSingleOrderBy<HSP> | Array<HsSingleOrderBy<HSP>>
declare type HsSingleOrderBy<HSP extends hs.HsProperties> = (keyof HSP & string) | hs.HsOrderInputObject<HSP>
declare type HsTableSelectOptions<HSP extends hs.HsProperties> = Pick<
  HsSelectOptions<HSP & hs.HeapObjectFilterableSchema>,
  'where' | 'limit' | 'offset'
> & {
  order?: HeapOrderBy<HSP> | null | undefined
}
declare type HsTableSearchByOptions<HSP extends hs.HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  query: string
  embeddingsQuery?: string
  limit?: number
}
declare type HsFilter<HSP extends hs.HsProperties> =
  | hs.HsFilterInputObject<HSP>
  | HsTopAndOperator<HSP>
  | HsTopOrOperator<HSP>
  | HsTopNotOperator<HSP>
  | HsNoopOperator
declare type HsTableFilter<HSP extends hs.HsProperties> = HsFilter<HSP & hs.HeapObjectFilterableSchema>
declare type HsTopAndOperator<HSP extends hs.HsProperties> = {
  $and: Array<HsFilter<HSP>>
}
declare type HsTopOrOperator<HSP extends hs.HsProperties> = {
  $or: Array<HsFilter<HSP>>
}
declare type HsTopNotOperator<HSP extends hs.HsProperties> = {
  $not: HsFilter<HSP>
}
declare type HsFilterRighthand<HS extends hs.HeapSchema> = null | HsFilterRighthandNonNull<HS>
declare type HsFilterRighthandNonNull<HS extends hs.HeapSchema> = hs.HsFilterInput<HS> | CommonOperator<HS>
declare type CommonOperator<HS extends hs.HeapSchema> =
  | HsAndOperator<HS>
  | HsNoopOperator
  | HsNotOperator<HS>
  | HsOrOperator<HS>
declare type HsNoopOperator = {
  $noop: true | 1 | '1' | 'true' | 'yes'
}
declare type HsNotOperator<HS extends hs.HeapSchema> = {
  $not: HsFilterRighthand<HS>
}
declare type HsAndOperator<HS extends hs.HeapSchema> = {
  $and: Array<HsFilterRighthand<HS>>
}
declare type HsOrOperator<HS extends hs.HeapSchema> = {
  $or: Array<HsFilterRighthand<HS>>
}
declare type HsCompareOperators<V> = HsGtOperator<V> | HsGteOperator<V> | HsLtOperator<V> | HsLteOperator<V>
declare type HsGtOperator<V> = {
  $gt: V
}
declare type HsGteOperator<V> = {
  $gte: V
}
declare type HsLtOperator<V> = {
  $lt: V
}
declare type HsLteOperator<V> = {
  $lte: V
}
declare type HsIlikeOperator<V> = V extends string
  ? {
      $ilike: string
    }
  : never
declare type HsHasOperator<V> = V extends null | unknown[] | object
  ? never
  : [
      {
        $has: V
      },
    ]
declare type HsIncludesOperator<V> = {
  $includes:
    | V
    | {
        $any: V[]
      }
    | {
        $all: V[]
      }
}
declare type UgcSystemHeapTableName = 'users'
interface HqlSelectQuery {
  from: HqlFrom
  select: HqlSelect
  distinct?: boolean
  where?: CqlWhere
  group?: CqlSelectAlias[]
  having?: CqlHaving
  order?: HqlOrder
  limit?: number
  offset?: number
  resPlainJson?: boolean
  resTakeFirst?: boolean
}
declare type HqlFrom = HqlTable | HqlSubQuery
declare type HqlTable = {
  kind: 'table'
  heapType: HeapObjectType
}
declare type HqlSubQuery = {
  kind: 'sub'
  query: HqlSelectQuery
}
declare type HqlExpr = HqlField | HqlExprFn | HqlExprAgg | CqlDynParam
declare type HqlField = HqlTableField | HqlSubQueryField
declare type HqlTableField = HqlSystemColumn | HqlDataField
declare type HqlSubQueryField = HqlSubPlainField | HqlSubJsonField
declare type HqlSystemColumn = {
  kind: 'sys'
  name: HqlSystemColumnName
}
declare type HqlSystemColumnName = typeof allowedHqlSystemColumns[number]
declare const allowedHqlSystemColumns: readonly ['id', 'createdAt', 'updatedAt', 'createdBy', 'updatedBy']
declare type HqlDataField = {
  kind: 'data'
  path: string | CqlDeepPath
  type: CqlFieldType
}
declare type HqlSubPlainField = {
  kind: 'subPlain'
  name: string
}
declare type HqlSubJsonField = {
  kind: 'subJson'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type HqlExprFn = {
  kind: 'fn'
  fn: string
  args: Array<HqlExpr>
}
declare type HqlExprAgg = {
  kind: 'agg'
  fn: string
  args: [CqlAsterisk] | Array<CqlDynParam | HqlField | HqlExprFnNoAgg>
  distinct?: boolean
}
declare type HqlExprFnNoAgg = {
  kind: 'fn'
  fn: string
  args: Array<HqlField | HqlExprFnNoAgg | CqlDynParam>
}
declare type HqlSelect = Record<string, HqlExpr>
declare type HqlOrder = HqlSimpleOrderBy | Array<HqlSingleOrderBy>
declare type HqlSingleOrderBy = HqlSimpleOrderBy | [HqlSimpleOrderBy, SortDirection]
declare type HqlSimpleOrderBy =
  | HqlSystemColumnName
  | string
  | HqlDataField
  | HqlSubJsonField
  | HqlOrderAliasField
  | HqlExprFn
declare type HqlOrderAliasField = {
  kind: 'aliasJson'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type CreateBotUserInfo = Pick<ExtendedUserFields, typeof botUserExtendedFields[number]>
declare const botUserExtendedFields: readonly ['firstName', 'middleName', 'lastName', 'imageHash', 'imageUrl']
declare type LogLevel = 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace' | 'unknown'
declare type UgcKvOpts = {
  [key: string]: string | number | undefined
}
declare type LogParams = {
  err?: Error
  kv?: UgcKvOpts
  json?: unknown
  level?: LogLevel
  msg?: string | number
}
declare type LogParamsNoMsg = Omit<LogParams, 'msg'>
declare type Middleware<Ctx, Req> = {
  <R>(ctx: Ctx, req: Req, next: () => R): R | Promise<R>
}
declare type AnyUgcRoutesDefinitionMiddleware = Middleware<RichUgcCtx, AnyUgcRouteParsedRequest>
interface AuthRequirements {
  phone?: boolean
  email?: boolean
  inCurrentSession?: boolean
  notBefore?: Date
}
/**
 * Checks if there is a user of any type in the context,
 *  if not - creates a new anonymous user auth session and sets `ctx.user` in the context
 * @returns existing user from ctx or the created anonymous user
 */
export declare function requireAnyUser(ctx: RichUgcCtx): Promise<UgcSmartUser>
export declare function requireRealUser(ctx: RichUgcCtx, requirements?: AuthRequirements): UgcSmartUser
/**
 * Creates a new auth session for the current user in the given child account and returns the URL pointing
 *  to the special /s/auth/parent/ endpoint that should be immediately navigated
 *  to set a proper auth cookie in the target account domain.
 * The user must have a proper identity of ParentAccount type in the child account,
 *  and the given account must be actual child account of the current account.
 */
export declare function authenticateCurrentUserInChildAccount(
  ctx: RichUgcCtx,
  childAccount: UgcCtxAccount | RichUgcAccount,
  gotoPathOrUrl?: string,
): Promise<string>
/**
 * Returns a very short-living URL which allows to easily authenticate current user
 *  under another domain and/or in another browser
 * The URL should be immediately navigated to set a proper auth cookie in the target domain/browser.
 */
export declare function authenticateCurrentUserInNewDomainOrBrowser(
  ctx: RichUgcCtx,
  targetDomain?: string,
  gotoPathOrUrl?: string,
): Promise<string>
/**
 * Main function to get list of account users.
 * Returns UgcUser class instance for each user containing information about user
 *  with respect to application permission rules.
 * @todo implement application context awareness
 */
export declare function findUsers(ctx: RichUgcCtx, options?: FindUsersOptions): Promise<UgcSmartUser[]>
interface FindUsersOptions {
  where?: {
    type?: User2['type']
    accountRole?: AccountRole | AccountRole[]
    username?: string
    fuzzyText?: string
  }
  limit?: number
  offset?: number
}
export declare function getUserById(ctx: RichUgcCtx, id: HeapId): Promise<UgcSmartUser>
export declare function findUserById(ctx: RichUgcCtx, id: HeapId): Promise<UgcSmartUser | null>
export declare function findUsersByIds(ctx: RichUgcCtx, ids: Array<HeapId>): Promise<Array<UgcSmartUser>>
/**
 * Programmatically creates a new real user.
 * Allows to create an unconfirmed phone and/or email identity along with the user itself.
 * If so, checks that no user with the same identity already exists.
 */
export declare function createRealUser(ctx: RichUgcCtx, info?: CreateRealUserInfoRaw): Promise<UgcSmartUser>
declare type CreateRealUserInfoRaw = Pick<
  ExtendedUserFields,
  'firstName' | 'middleName' | 'lastName' | 'gender' | 'imageHash' | 'imageUrl'
> & {
  birthday?: string | Date
} & CreateRealUserCoreInfo
/**
 * Creates a user type=Bot by the given unique username, username is additionally namespaces with the :bot suffix
 *  and @appSlug (if any) to avoid username conflicts.
 * If the bot user with the given username already exists, then its props are updated if they differ from the given ones.
 */
export declare function createOrUpdateBotUser(
  ctx: RichUgcCtx,
  username: string,
  info?: CreateBotUserInfo,
): Promise<UgcSmartUser>
export declare function getExtendedUserFieldsSupport(ctx: RichUgcCtx): Promise<ExtendedUserFieldsSupport>
export declare function requireAccountRole(ctx: RichUgcCtx, atLeastAccountRole: Exclude<AccountRole, 'None'>): void
export declare function findIdentities(_ctx: RichUgcCtx, options: FindIdentitiesOptions): Promise<UgcIdentity[]>
/**
 * Normalizes given identity key (depending on type) as it is stored in the database to avoid duplicates.
 * Helpful in combination with findIdentities when searching by key.
 */
export declare function normalizeIdentityKey(identityType: IdentityType, identityKey: string): string
export declare function createUnconfirmedIdentity(ctx: RichUgcCtx, params: CreateIdentityParams): Promise<UgcIdentity>
export declare function makeIdentityPrimary(ctx: RichUgcCtx, identityId: string): Promise<UgcIdentity>
export declare function deleteIdentity(ctx: RichUgcCtx, identityId: string): Promise<UgcIdentity | null>
declare function __deprecatedIsAdminUser__(ctx: RichUgcCtx): boolean
declare function __deprecatedIsRealAuth__(ctx: RichUgcCtx): boolean
export declare function hasRealUser(ctx: RichUgcCtx): boolean
interface ProvideUserOptions {
  anonymous?: boolean
  minRole?: Exclude<AccountRole, 'None'>
}
export declare function provideUser(options?: ProvideUserOptions): AnyUgcRoutesDefinitionMiddleware
export declare function checkFilePermissions(): AnyUgcRoutesDefinitionMiddleware
export { updateAccountRole, updateUsername } from 'services/ugc-runner/runtime/user/UgcSmartUser'

export { UgcCtxUser2 as CoreUser, UgcIdentity as Identity, UgcSmartUser as SmartUser }

export {}
