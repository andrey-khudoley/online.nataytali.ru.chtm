import * as tb from '@sinclair/typebox'
import { Filter, OrderByDefinition, SortDirection } from 'core/db/dbQueryTypes'
import { HeapId, HeapObjectBaseRaw, HeapObjectType, HeapOrderBy } from 'core/heap/heapTypes'
import * as hs from 'core/heap/v2/heapSchemaTypes'
import { HeapTableOptions, ReadOnlyHeapTableRepo } from 'core/heap/v2/HeapTableRepo'
import { Icon } from 'lib/chatium-json/v1'
import { DesktopLayout, PlainIconName } from 'lib/chatium-json/v2'
import {
  UgcAnyHeapTableRepo,
  UgcHeapTableName,
  UgcHeapTableRepo,
  UgcReadOnlyHeapTableRepo,
} from 'services/ugc-runner/runtime/heap/UgcHeapTableRepo'
import { UgcRouteType } from 'services/ugc-runner/runtime/runtimeTypes'
import { UgcSmartUser } from 'services/ugc-runner/runtime/user/UgcSmartUser'
import { AnyObject, JSONInputObject } from 'utils/types'

interface CqlSelectQuery {
  from: CqlFrom
  select: CqlSelect
  distinct?: boolean
  where?: CqlWhere
  having?: CqlHaving
  order?: CqlOrder
  group?: CqlGroup
  limit?: number
  offset?: number
}
declare type CqlFrom = CqlTable | CqlSubQuery
declare type CqlTable = {
  kind: 'table'
  schema: string
  name: string
}
declare type CqlSubQuery = {
  kind: 'sub'
  query: CqlSelectQuery
}
declare type CqlSelect = Record<string, CqlExpr> | undefined
declare type CqlExpr = CqlPlainColumn | CqlExprFn | CqlDynParam | CqlJsonPath | CqlAsterisk
declare type CqlPlainColumn = {
  kind: 'col'
  name: string
  type?: CqlFieldType
}
declare type CqlExprFn = {
  kind: 'fn'
  fn: string
  args: CqlExpr[]
  distinct?: boolean
  type?: CqlFieldType
}
declare type CqlDynParam = {
  kind: 'dyn'
  value: unknown
  type?: CqlFieldType
}
declare type CqlJsonPath = {
  kind: 'json'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type CqlAsterisk = {
  kind: '*'
  type?: undefined
}
declare type CqlFieldType = 'string' | 'number' | 'boolean' | 'date' | 'json'
declare type CqlDeepPath = [string, ...(string | number)[]]
declare type CqlGroup = CqlSelectAlias[]
declare type CqlSelectAlias = string
declare type CqlWhere = Filter<any>
declare type CqlHaving = Filter<any>
declare type CqlOrder = OrderByDefinition<any>
declare type Lang = string
interface LangCtx {
  lang: Lang
}
declare abstract class ChatiumError extends Error {
  abstract readonly statusCode: number
  constructor(message?: string)
}
declare class ValidationError extends ChatiumError {
  readonly statusCode = 422
  readonly issues: ValidationIssue[]
  readonly reason?: string
  constructor(issues: ValidationIssue[])
  constructor(reason: string, issues: ValidationIssue[])
  constructor(
    reason: string,
    ajvErrors?: Array<{
      instancePath: string
      message?: string
    }> | null,
  )
  /** @deprecated use issues array instead */
  constructor(reason: string, data?: ValidationErrorData)
  get errors(): ValidationIssue[]
  /** @deprecated use issues or errors */
  get data(): ValidationErrorData
  toString(): string
  get message(): string
  get isEmpty(): boolean
}
interface ValidationIssue {
  fullPath?: string
  message: string
}
declare type ValidationErrorData = ValidationErrorDataFields
interface ValidationErrorDataFields {
  fields: Record<string, string>
}
declare type TimeUnit =
  | 'milliseconds'
  | 'seconds'
  | 'minutes'
  | 'hours'
  | 'days'
  | 'weeks'
  | 'months'
  | 'quarters'
  | 'years'
/**
 * Converts heap schema to a form that can be transferred outside the isolate
 */
export declare function serializeHeapSchema(schema: hs.HeapSchema): serializeHeapSchema.HsSerialized
export declare namespace serializeHeapSchema {
  interface HssArray extends HsSerializedBase, hs.HsArrayOptions<hs.HeapSchema> {
    kind: 'ArrayKind'
    type: 'array'
    items: HsSerialized
  }
  interface HssEnum extends HsSerializedBase, hs.HsOptionsWithDefault<string | number> {
    kind: 'EnumKind'
    anyOf: tb.TEnumKey<string | number>[]
  }
  interface HssGenericLink extends HsSerializedBase, hs.HsLinkOptions {
    kind: 'GenericLinkKind'
    type: 'array'
  }
  interface HssFunctionRouteRef extends Omit<HssTuple, 'kind'> {
    kind: 'FunctionRouteRefKind'
    body: HsSerialized
    result: HsSerialized
  }
  interface HssIntersect extends HsSerializedBase, hs.HsIntersectOptions<hs.HeapSchema[]> {
    kind: 'IntersectKind'
    type: 'object'
    allOf: HsSerialized[]
  }
  interface HssJobRouteRef extends Omit<HssTuple, 'kind'> {
    kind: 'JobRouteRefKind'
    body: HsSerialized
  }
  interface HssMoney extends Omit<HssTuple, 'kind'> {
    kind: 'MoneyKind'
  }
  interface HssNumber extends HsSerializedBase, hs.HsNumberOptions {
    kind: 'NumberKind'
    type: 'number'
  }
  interface HssObject extends HsSerializedBase, hs.HsObjectOptions<hs.HsProperties> {
    kind: 'ObjectKind'
    type: 'object'
    properties: Record<string, HsSerialized>
    required?: string[]
  }
  interface HssRecord
    extends HsSerializedBase,
      hs.HsOptionsWithDefault<tb.StaticRecord<hs.HsRecordKey, hs.HeapSchema>> {
    kind: 'RecordKind'
    patternProperties: Record<string, HsSerialized>
  }
  interface HssRefLink extends HsSerializedBase, hs.HsLinkOptions {
    kind: 'RefLinkKind'
    type: 'string'
    targetTableName: string
    isSystemTarget: boolean
  }
  interface HssString extends HsSerializedBase, hs.HsStringOptions {
    kind: 'StringKind'
    type: 'string'
  }
  interface HssTuple extends HsSerializedBase, hs.HsOptionsWithDefault<tb.StaticTuple<hs.HeapSchema[]>> {
    kind: 'TupleKind'
    items?: HsSerialized[]
    additionalItems?: boolean
    minItems: number
    maxItems: number
  }
  interface HssUnion extends HsSerializedBase, hs.HsOptionsWithDefault<tb.StaticUnion<hs.HeapSchema[]>> {
    kind: 'UnionKind'
    anyOf: HsSerialized[]
  }
  type HssSerializedSimple = HsSerializedBase
  interface HsSerializedBase {
    kind: string
    modifier?: string
  }
  type HsSerialized =
    | HssArray
    | HssEnum
    | HssGenericLink
    | HssFunctionRouteRef
    | HssIntersect
    | HssJobRouteRef
    | HssMoney
    | HssNumber
    | HssObject
    | HssRecord
    | HssRefLink
    | HssString
    | HssTuple
    | HssUnion
    | HssSerializedSimple
}
declare type HsSerialized = serializeHeapSchema.HsSerialized
interface LocationCtx {
  location: Location | undefined
}
interface Location {
  country: string
  region: string
  timeZone: string
  city: string
  coordinates: Coordinates
}
interface Coordinates {
  latitude: number
  longitude: number
}
interface UgcJobScheduleParams {
  allowRetry?: boolean
}
interface HsPropertiesWithOptions {
  [key: string]: hs.HeapSchema & hs.HsOptionsWithDefault<unknown>
}
declare type BS = hs.HeapSchema
declare type PS = hs.HsObject<hs.HsStringFriendlyProperties> | hs.HsRecord<hs.HsString, hs.HsString | hs.HsNumber>
declare type QS = hs.HsObject<HsPropertiesWithOptions> | hs.HsRecord<hs.HsString, hs.HeapSchema>
declare type RS = hs.HeapSchema
declare type IsOptionalBody<T> = unknown extends T ? true : undefined extends T ? true : false
interface FunctionRouteRef<B, R> {
  readonly pattern: string
  run: IsOptionalBody<B> extends true
    ? (ctx: RichUgcCtx, params?: B) => Promise<R>
    : (ctx: RichUgcCtx, params: B) => Promise<R>
  path(ctx: RichUgcCtx): Promise<string>
  meta(ctx: RichUgcCtx): Promise<AnyObject>
  bodySchema(ctx: RichUgcCtx): Promise<BS>
  resultSchema(ctx: RichUgcCtx): Promise<RS>
  schema(ctx: RichUgcCtx): Promise<{
    meta: AnyObject
    body: BS
    result: RS
  }>
}
interface JobRouteRef<B> {
  readonly pattern: string
  scheduleJobAt: IsOptionalBody<B> extends true
    ? (ctx: RichUgcCtx, startAt: Date, params?: B, scheduleParams?: UgcJobScheduleParams) => Promise<number>
    : (ctx: RichUgcCtx, startAt: Date, params: B, scheduleParams?: UgcJobScheduleParams) => Promise<number>
  scheduleJobAfter: IsOptionalBody<B> extends true
    ? (
        ctx: RichUgcCtx,
        amount: number,
        unit: TimeUnit,
        params?: B,
        scheduleParams?: UgcJobScheduleParams,
      ) => Promise<number>
    : (
        ctx: RichUgcCtx,
        amount: number,
        unit: TimeUnit,
        params: B,
        scheduleParams?: UgcJobScheduleParams,
      ) => Promise<number>
  scheduleJobAsap: IsOptionalBody<B> extends true
    ? (ctx: RichUgcCtx, params?: B, scheduleParams?: UgcJobScheduleParams) => Promise<number>
    : (ctx: RichUgcCtx, params: B, scheduleParams?: UgcJobScheduleParams) => Promise<number>
  path(): string
  meta(ctx: RichUgcCtx): Promise<AnyObject>
  bodySchema(ctx: RichUgcCtx): Promise<BS>
  schema(ctx: RichUgcCtx): Promise<{
    body: BS
  }>
}
declare type RouteRefGetSchemaFn = (
  codeAccountId: number,
  routerUrlPath: string,
  routePattern: string,
  routeType: UgcRouteType,
) => Promise<RouteRefSchema>
declare type RouteRefSchema = {
  meta?: AnyObject
  bs?: BS
  ps?: PS
  qs?: QS
  rs?: RS
}
export declare type PartialEmbeddings = {
  [K in EmbeddingType]?: Array<number[]>
}
export declare type EmbeddingType = 'openai-text-embedding3-large' | 'openai-text-embedding3-small'
declare type TsVectorLangKey = 'ru' | 'en'
declare enum UserRole {
  Admin = 'Admin',
  Staff = 'Staff',
  Support = 'Support',
  ActiveSupport = 'ActiveSupport',
  Developer = 'Developer',
  BetaTester = 'BetaTester',
  User = 'User',
}
declare enum UserStatus {
  Imported = 'Imported',
  Joined = 'Joined',
  AsSupport = 'AsSupport',
  Left = 'Left',
}
declare type PrimaryIdentities = {
  phone?: string
  email?: string
  hasPassword?: boolean
}
declare abstract class SmartUser<Ctx> {
  private ctx
  private coreUser
  private extendedInfo?
  private primaryIdentities?
  protected abstract userApi: SmartUserApi<Ctx>
  protected abstract fileServiceDirectHost: string
  protected abstract fileServiceCdnHost: string
  constructor(
    ctx: LocationCtx,
    coreUser: UgcCtxUser2,
    extendedInfo?: ExtendedUserInfo | undefined,
    primaryIdentities?: PrimaryIdentities | undefined,
  )
  get id(): HeapId
  get type(): User2['type']
  get displayName(): string
  get confirmedPhone(): string | undefined
  get confirmedEmail(): string | undefined
  get accountRole(): AccountRole
  get username(): string | undefined
  get firstName(): string | undefined
  get middleName(): string | undefined
  get lastName(): string | undefined
  get fullName(): string
  get gender(): UserGender | undefined
  get birthdayDate(): Date | undefined
  get birthday(): string | undefined
  get passwordSalt(): string
  get hasPassword(): boolean
  updateAccountRole(ctx: Ctx, newRole: AccountRole): Promise<void>
  updateUsername(ctx: Ctx, username: string): Promise<void>
  updatePassword(ctx: Ctx, password: string): Promise<void>
  updateLang(ctx: Ctx, lang: Lang | null): Promise<void>
  updateExtendedInfo(ctx: Ctx, info: UpdateExtendedUserInfoRaw): Promise<void>
  get smartIconProps(): {
    url?: string
    name?: PlainIconName
    text?: string
  }
  get hasImage(): boolean
  get imageUrl(): string | undefined
  /**
   * Effective image hash XOR url
   * Mainly for copying image data from one user to another
   */
  get rawImageInfo(): {
    imageHash?: string
    imageUrl?: string
  }
  getImageThumbnailUrl(size?: number): string | undefined
  is(role: Exclude<AccountRole, 'None'>): boolean
  get lang(): Lang | undefined
  toJSON(): JSONInputObject
  serialize(): SerializedSmartUser | UgcCtxUser1
  getProfile<T extends JSONInputObject>(): T | undefined
  private get fsHost()
}
declare type SerializedSmartUser = [UgcCtxUser2, ExtendedUserInfo | undefined, PrimaryIdentities | undefined]
interface SmartUserApi<Ctx> {
  updateAccountRole(ctx: Ctx, userId: HeapId, newRole: AccountRole): Promise<AccountRole>
  updateUsername(ctx: Ctx, userId: HeapId, username: string): Promise<string>
  updateExtendedInfo(
    ctx: Ctx,
    userId: HeapId,
    info: UpdateExtendedUserInfo,
  ): Promise<[UgcCtxUser2, ExtendedUserInfo | undefined]>
  updatePassword(ctx: Ctx, userId: HeapId, password: string): Promise<void>
  updateLang(ctx: Ctx, userId: HeapId, lang: Lang | null): Promise<string | undefined>
}
declare type ExtendedUserInfo = ExtendedUserFields & {
  displayName?: string
  profile?: JSONInputObject
}
declare type UpdateExtendedUserInfo = {
  firstName?: string | null
  lastName?: string | null
  middleName?: string | null
  gender?: UserGender | null
  birthday?: string | null
  imageHash?: string | null
  imageUrl?: string | null
}
declare type UpdateExtendedUserInfoRaw = Pick<
  UpdateExtendedUserInfo,
  'firstName' | 'middleName' | 'lastName' | 'gender' | 'imageHash' | 'imageUrl'
> & {
  birthday?: string | Date | null
}
declare type UserGender = 'male' | 'female' | 'other'
declare type HashMediaType = 'file' | 'video' | 'image' | 'audio'
declare abstract class BaseRefLink<T extends object, ReadCtx = unknown> {
  /**
   * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
   *
   * This is technical type, like written to heap-table "type" field,
   *  don't mix up with developer-defined table name provided to Heap.Table.
   * For system ref-links this also contains heap-type ('core.User' instead of 'users').
   */
  readonly type: HeapObjectType
  readonly id: HeapId
  /** Repository (table) that owns the row of this RefLink instance */
  readonly myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>
  /**
   * Repository (table) that owns the row of the target record.
   * Can be passed as table name or as repository instance.
   * When available, used in 'get' method implementation.
   */
  protected targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<hs.HsProperties, unknown, unknown> | undefined
  constructor(
    /**
     * The type of target record table, with account suffix, but **WITHOUT plugin-app prefix**.
     *
     * This is technical type, like written to heap-table "type" field,
     *  don't mix up with developer-defined table name provided to Heap.Table.
     * For system ref-links this also contains heap-type ('core.User' instead of 'users').
     */
    type: HeapObjectType,
    id: HeapId,
    /** Repository (table) that owns the row of this RefLink instance */
    myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>,
    /**
     * Repository (table) that owns the row of the target record.
     * Can be passed as table name or as repository instance.
     * When available, used in 'get' method implementation.
     */
    targetRepoOrTableName?: string | ReadOnlyHeapTableRepo<hs.HsProperties, unknown, unknown> | undefined,
  )
  toJSON(): string
  toString(): string
  get<R = T>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  abstract getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface RefLinkClass {
  new (
    type: HeapObjectType,
    id: HeapId,
    myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>,
    targetRepoOrTableName?: ReadOnlyHeapTableRepo<hs.HsProperties, unknown> | string,
  ): BaseRefLink<AnyObject>
}
declare abstract class BaseGenericLink<ReadCtx = unknown> {
  readonly type: HeapObjectType
  readonly id: HeapId
  readonly myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>;
  [index: number]: HeapObjectType | HeapId
  readonly length = 2
  constructor(type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>)
  get<R = hs.HeapObjectBase>(ctx: ReadCtx): Promise<R>
  getTitle(ctx: ReadCtx): Promise<string>
  /** simulates the serialized format for compatibility */
  [Symbol.iterator](): IterableIterator<HeapObjectType | HeapId>
  toJSON(): GenericLinkJson
  toString(): string
  abstract getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: ReadCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, ReadCtx>>
}
interface GenericLinkClass {
  new (type: HeapObjectType, id: HeapId, myRepo: ReadOnlyHeapTableRepo<hs.HsProperties, unknown>): BaseGenericLink
}
export declare type GenericLinkJson = [HeapObjectType, HeapId]
declare type UnionConstructorInput = hs.HsUnionable | hs.HsUnion<hs.HsUnionable[]>
declare type User2 = hs.HeapObjectBase & {
  type: 'Anonymous' | 'Real' | 'Bot'
  username?: string
  lang?: Lang
  timeZone?: string
  accountRole: AccountRole
  isBlocked: boolean
  knownChildAccounts?: number[]
} & ExtendedUserFields
declare type ExtendedUserFields = {
  firstName?: string
  lastName?: string
  middleName?: string
  gender?: UserGender
  birthday?: string
  imageHash?: string
  imageUrl?: string
}
declare type AccountRole = typeof validAccountRoles[number]
declare const validAccountRoles: readonly ['None', 'Staff', 'Admin', 'Developer', 'Owner']
interface HeapLink<_HD extends HeapData> {
  type: HeapObjectType
  id: HeapId
}
declare type HeapObjectBaseV1 = HeapObjectBaseRaw & {
  idx: number
  createdBy: HeapLink<UserData> | null
  updatedBy: HeapLink<UserData> | null
}
declare type HeapData = {
  '~~heap~data~tag~~': never
}
declare type EraseHD<HD extends HeapData> = Omit<HD, keyof HeapData>
declare type RefLink<HD extends HeapData> = HD & {
  '~~ref~link~tag~~': never
}
declare type GenericLink = {
  '~~generic~link~tag~~': never
}
declare type HeapObjectV1<HD extends HeapData> = HeapObjectBaseV1 & MapHeapLinks<HD>
declare type MapHeapLinks<HD extends HeapData> = {
  [K in keyof EraseHD<HD>]: LinksMap<HD[K]>
}
declare type LinksMap<T> = T extends null
  ? null
  : T extends GenericLink
  ? HeapId
  : T extends RefLink<HeapData>
  ? HeapLink<T>
  : T
interface PurchasedProducts {
  [productName: string]: string | true | undefined
}
interface UserData extends HeapData {
  authId: number
  roles: UserRole[]
  status: UserStatus
  expiresAt: string | null
  avatar: Icon
  firstName: string | null
  lastName: string | null
  phone: string | null
  email: string | null
  platforms: EnvPlatform[]
  purchasedProducts: PurchasedProducts
}
declare type User1 = HeapObjectV1<UserData>
declare type UgcFileStorage = 'cgs' | 'db'
declare type CgsRepoVersion = string
declare type AccountAuthType = 'Email' | 'Phone' | 'Multi'
declare type UgcCodeVersion = CgsRepoVersion
declare type UgcCtxUser1 = Pick<
  User1,
  'id' | 'firstName' | 'lastName' | 'roles' | 'avatar' | 'purchasedProducts' | 'phone' | 'email'
>
declare type UgcCtxUser2 = Pick<
  User2,
  | 'id'
  | 'type'
  | 'accountRole'
  | 'username'
  | 'firstName'
  | 'lastName'
  | 'middleName'
  | 'gender'
  | 'birthday'
  | 'imageHash'
  | 'imageUrl'
  | 'lang'
>
interface UgcCtxPluginApp extends UgcPluginAppUrlInfo {
  type: 'UgcPlugin'
  appId: number
  callingAcc: UgcCtxAccount
  hostAccUser1?: UgcCtxUser1
  hostAccUser2?: UgcCtxUser2 | SerializedSmartUser
}
interface UgcPluginAppUrlInfo {
  appSlug: string
  /** path to the application root directory */
  directoryPath: string
}
interface UgcCtxAccount {
  id: number
  name: string
  host: string
  authType: AccountAuthType
  /** @deprecated use host instead */
  externalHost: string | null
  publishedVersion: string | null
  metaHash: string
  pathPrefix: string
}
interface EnvAvc {
  id: string
  signature: string
  accMap: Record<
    /** base account ID */
    number,
    [
      /** branch account ID */
      number,
      UgcFileStorage,
      UgcCodeVersion | null,
      /** expiration timestamp in seconds */
      number,
    ]
  >
}
interface OptionalEnvCtx {
  env: Env | null
}
interface Env {
  development: boolean
  production: boolean
  platform: EnvPlatform
  version: number
  appBuildNumber?: number
  ios: boolean
  android: boolean
  web: boolean
  job: boolean
  debugSocketId: string | null
  usePreviewMode: boolean
  useScopedPreviewMode: null | Record<string, boolean | null | undefined>
  viewportWidth: number | null
  viewportHeight: number | null
  devicePixelRatio: number
  alwaysHeader: boolean
  clientScope?: 'modal' | 'desktop' | 'ide'
  desktopLayout?: DesktopLayout
  acceptChatiumJson: boolean
  client?: ClientInfo
  avc?: EnvAvc
}
declare const EnvPlatform: {
  readonly iOS: 'iOS'
  readonly Android: 'Android'
  readonly Web: 'Web'
  readonly Job: 'Job'
}
declare type EnvPlatform = keyof typeof EnvPlatform
interface ClientInfo {
  ip: string
  deviceName: string
  osName: string
}
declare type HsSelectOptions<HSP extends hs.HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  limit?: number | null | undefined
  offset?: number | null | undefined
  order?: HsOrderBy<HSP> | null | undefined
}
declare type HsOrderBy<HSP extends hs.HsProperties> = HsSingleOrderBy<HSP> | Array<HsSingleOrderBy<HSP>>
declare type HsSingleOrderBy<HSP extends hs.HsProperties> = (keyof HSP & string) | hs.HsOrderInputObject<HSP>
declare type HsTableSelectOptions<HSP extends hs.HsProperties> = Pick<
  HsSelectOptions<HSP & hs.HeapObjectFilterableSchema>,
  'where' | 'limit' | 'offset'
> & {
  order?: HeapOrderBy<HSP> | null | undefined
}
declare type HsTableSearchByOptions<HSP extends hs.HsProperties> = {
  where?: HsFilter<HSP> | null | undefined
  query: string
  embeddingsQuery?: string
  limit?: number
}
declare type HsUpdateAllOptions<HSP extends hs.HsProperties> = {
  patch: Partial<hs.HsUpdateInputObject<HSP>>
  where?: HsTableFilter<HSP> | null | undefined
  limit: number | null
}
declare type HsDeleteAllOptions<HSP extends hs.HsProperties> = {
  where?: HsTableFilter<HSP> | null | undefined
  limit: number | null
  /** default is false */
  hard?: boolean
}
declare type HsFilter<HSP extends hs.HsProperties> =
  | hs.HsFilterInputObject<HSP>
  | HsTopAndOperator<HSP>
  | HsTopOrOperator<HSP>
  | HsTopNotOperator<HSP>
  | HsNoopOperator
declare type HsTableFilter<HSP extends hs.HsProperties> = HsFilter<HSP & hs.HeapObjectFilterableSchema>
declare type HsTopAndOperator<HSP extends hs.HsProperties> = {
  $and: Array<HsFilter<HSP>>
}
declare type HsTopOrOperator<HSP extends hs.HsProperties> = {
  $or: Array<HsFilter<HSP>>
}
declare type HsTopNotOperator<HSP extends hs.HsProperties> = {
  $not: HsFilter<HSP>
}
declare type HsFilterRighthand<HS extends hs.HeapSchema> = null | HsFilterRighthandNonNull<HS>
declare type HsFilterRighthandNonNull<HS extends hs.HeapSchema> = hs.HsFilterInput<HS> | CommonOperator<HS>
declare type CommonOperator<HS extends hs.HeapSchema> =
  | HsAndOperator<HS>
  | HsNoopOperator
  | HsNotOperator<HS>
  | HsOrOperator<HS>
declare type HsNoopOperator = {
  $noop: true | 1 | '1' | 'true' | 'yes'
}
declare type HsNotOperator<HS extends hs.HeapSchema> = {
  $not: HsFilterRighthand<HS>
}
declare type HsAndOperator<HS extends hs.HeapSchema> = {
  $and: Array<HsFilterRighthand<HS>>
}
declare type HsOrOperator<HS extends hs.HeapSchema> = {
  $or: Array<HsFilterRighthand<HS>>
}
declare type HsCompareOperators<V> = HsGtOperator<V> | HsGteOperator<V> | HsLtOperator<V> | HsLteOperator<V>
declare type HsGtOperator<V> = {
  $gt: V
}
declare type HsGteOperator<V> = {
  $gte: V
}
declare type HsLtOperator<V> = {
  $lt: V
}
declare type HsLteOperator<V> = {
  $lte: V
}
declare type HsIlikeOperator<V> = V extends string
  ? {
      $ilike: string
    }
  : never
declare type HsHasOperator<V> = V extends null | unknown[] | object
  ? never
  : [
      {
        $has: V
      },
    ]
declare type HsIncludesOperator<V> = {
  $includes:
    | V
    | {
        $any: V[]
      }
    | {
        $all: V[]
      }
}
declare type UgcSystemHeapTableName = 'users'
interface HqlSelectQuery {
  from: HqlFrom
  select: HqlSelect
  distinct?: boolean
  where?: CqlWhere
  group?: CqlSelectAlias[]
  having?: CqlHaving
  order?: HqlOrder
  limit?: number
  offset?: number
  resPlainJson?: boolean
  resTakeFirst?: boolean
}
declare type HqlFrom = HqlTable | HqlSubQuery
declare type HqlTable = {
  kind: 'table'
  heapType: HeapObjectType
}
declare type HqlSubQuery = {
  kind: 'sub'
  query: HqlSelectQuery
}
declare type HqlExpr = HqlField | HqlExprFn | HqlExprAgg | CqlDynParam
declare type HqlField = HqlTableField | HqlSubQueryField
declare type HqlTableField = HqlSystemColumn | HqlDataField
declare type HqlSubQueryField = HqlSubPlainField | HqlSubJsonField
declare type HqlSystemColumn = {
  kind: 'sys'
  name: HqlSystemColumnName
}
declare type HqlSystemColumnName = typeof allowedHqlSystemColumns[number]
declare const allowedHqlSystemColumns: readonly ['id', 'createdAt', 'updatedAt', 'createdBy', 'updatedBy']
declare type HqlDataField = {
  kind: 'data'
  path: string | CqlDeepPath
  type: CqlFieldType
}
declare type HqlSubPlainField = {
  kind: 'subPlain'
  name: string
}
declare type HqlSubJsonField = {
  kind: 'subJson'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type HqlExprFn = {
  kind: 'fn'
  fn: string
  args: Array<HqlExpr>
}
declare type HqlExprAgg = {
  kind: 'agg'
  fn: string
  args: [CqlAsterisk] | Array<CqlDynParam | HqlField | HqlExprFnNoAgg>
  distinct?: boolean
}
declare type HqlExprFnNoAgg = {
  kind: 'fn'
  fn: string
  args: Array<HqlField | HqlExprFnNoAgg | CqlDynParam>
}
declare type HqlSelect = Record<string, HqlExpr>
declare type HqlOrder = HqlSimpleOrderBy | Array<HqlSingleOrderBy>
declare type HqlSingleOrderBy = HqlSimpleOrderBy | [HqlSimpleOrderBy, SortDirection]
declare type HqlSimpleOrderBy =
  | HqlSystemColumnName
  | string
  | HqlDataField
  | HqlSubJsonField
  | HqlOrderAliasField
  | HqlExprFn
declare type HqlOrderAliasField = {
  kind: 'aliasJson'
  path: CqlDeepPath
  type: CqlFieldType
}
declare type UgcHeapRegistryLocalTable =
  | Record<'tableName' | 'modulePath' | 'exportName', string>
  | {
      tableName: string
      modulePath: string
      exportName: string
    }
interface ZSmartUnionable {
  $unionable: typeof hs.Unionable
}
interface ZType<HS extends hs.HeapSchema = hs.HeapSchema> {
  $static: HS['$static']
  $hsRuntime: HS['$hsRuntime']
  $hsCreateInput: HS['$hsCreateInput']
  $hsUpdateInput: HS['$hsUpdateInput']
  $hsFilterInput: HS['$hsFilterInput']
  $hsOrderInput: HS['$hsOrderInput']
  readonly kind: HS['kind']
  readonly title?: string
  readonly description?: string
  readonly examples?: unknown[]
  readonly deprecated?: boolean
  readonly customMeta?: Record<string, any>
  readonly defaultValue?: tb.Static<HS>
  parse(data: unknown): hs.HsRuntime<HS>
  safeParse(data: unknown): SafeParseReturnType<hs.HsRuntime<HS>>
  array(): ZArray<HS>
  describe(description: string): this
  meta(meta: hs.HsCommonOptions): this
  nullable(): hs.HsNonRequired<ZSmartUnion<[HS, hs.HsNull]>>
  optional(): hs.HsOptional<this>
  default(defaultValue: hs.NoUndefined<tb.Static<HS>>): hs.HsNonRequired<this>
}
interface HType<HS extends hs.HeapSchema> extends ZType<HS> {
  readonly searchable?: hs.HsSearchable['searchable']
  array(): HArray<HS>
  meta(meta: hs.HsSearchableOptions): this
  nullable(): hs.HsNonRequired<HSmartUnion<[HS, hs.HsNull]>>
}
declare type ZTypeOptsWithDefault<HS extends hs.HeapSchema> = hs.HsCommonOptions & {
  defaultValue?: tb.Static<HS>
}
declare type HTypeOptsWithDefault<HS extends hs.HeapSchema> = hs.HsCommonOptions &
  hs.HsSearchable & {
    defaultValue?: tb.Static<HS>
  }
declare type SafeParseReturnType<Output> = SafeParseSuccess<Output> | SafeParseError
declare type SafeParseSuccess<Output> = {
  success: true
  data: Output
  error?: never
}
declare type SafeParseError = {
  success: false
  error: ValidationError
  data?: never
}
interface ZArrayCommon extends CustomArrayOpts, ZSmartUnionable {
  readonly type: 'array'
  min(minItems: number): this
  max(maxItems: number): this
  length(len: number): this
  skipInvalid(): this
}
interface ZArray<IHS extends hs.HeapSchema> extends ZType<hs.HsArray<IHS>>, ZArrayCommon {
  readonly items: ZType<IHS>
}
interface HArray<IHS extends hs.HeapSchema> extends HType<hs.HsArray<IHS>>, ZArrayCommon {
  readonly items: HType<IHS>
}
declare type HArrayOpts<IHS extends hs.HeapSchema> = HTypeOptsWithDefault<hs.HsArray<IHS>> & CustomArrayOpts
declare type CustomArrayOpts = Pick<
  hs.HsArrayOptions<hs.HeapSchema>,
  'uniqueItems' | 'minItems' | 'maxItems' | 'skipInvalidItems'
>
interface ZNullCommon extends ZSmartUnionable {
  readonly type: 'null'
}
interface HNull extends ZType<hs.HsNull>, ZNullCommon {}
declare type HNullOpts = hs.HsCommonOptions
interface ZSmartUnion<OHS extends readonly hs.HeapSchema[]> extends ZType<hs.HsUnion<OHS>> {
  readonly anyOf: ZSmartUnionAlternatives<OHS>
}
interface HSmartUnion<OHS extends readonly hs.HeapSchema[]> extends HType<hs.HsUnion<OHS>> {
  readonly anyOf: HSmartUnionAlternatives<OHS>
}
declare type HSmartUnionOpts<OHS extends readonly hs.HeapSchema[]> = HTypeOptsWithDefault<hs.HsUnion<OHS>>
declare type ZSmartUnionAlternatives<OHS extends readonly hs.HeapSchema[]> = {
  [K in keyof OHS]: ZType<OHS[K]>
}
declare type HSmartUnionAlternatives<OHS extends readonly hs.HeapSchema[]> = {
  [K in keyof OHS]: HType<OHS[K]>
}
declare type HAny<T> = HType<hs.HsAny<T>>
declare type HAnyOpts<T> = HTypeOptsWithDefault<hs.HsAny<T>>
interface ZBooleanCommon extends ZSmartUnionable {
  readonly type: 'boolean'
}
interface HBoolean extends HType<hs.HsBoolean>, ZBooleanCommon {}
declare type HBooleanOpts = HTypeOptsWithDefault<hs.HsBoolean>
interface ZCurrencyCommon extends ZSmartUnionable {
  readonly type: 'string'
  readonly pattern: string
}
interface HCurrency extends HType<hs.HsString>, ZCurrencyCommon {}
declare type HCurrencyOpts = HTypeOptsWithDefault<hs.HsString>
interface ZDateCommon extends ZSmartUnionable {
  readonly type: 'string'
  readonly format: 'date-time'
}
interface HDate extends HType<hs.HsDateTime>, ZDateCommon {}
declare type HDateOpts = HTypeOptsWithDefault<hs.HsDateTime>
interface ZEnumCommon<ES extends tb.TEnumKey[]> extends ZSmartUnionable {
  readonly anyOf: ES
}
interface HEnum<ES extends tb.TEnumKey[]> extends HType<hs.HsEnum<ES>>, ZEnumCommon<ES> {}
declare type HEnumOpts<ES extends tb.TEnumKey[]> = HTypeOptsWithDefault<hs.HsEnum<ES>>
declare type EnumTypeToSchema<ET extends tb.TEnumType> = tb.TEnumKey<ET[keyof ET]>[]
declare type EnumValue = string | number
interface ZNumericCommon extends ZSmartUnionable {
  readonly minimum?: number
  readonly exclusiveMinimum?: number
  readonly maximum?: number
  readonly exclusiveMaximum?: number
  readonly multipleOf?: number
  min(minimum: number): this
  gte(minimum: number): this
  gt(exclusiveMinimum: number): this
  max(maximum: number): this
  lte(maximum: number): this
  lt(exclusiveMaximum: number): this
  divisibleBy(multipleOf: number): this
}
interface ZNumberCommon extends ZNumericCommon {
  readonly type: 'number'
}
interface ZNumber extends ZType<hs.HsNumber>, ZNumberCommon {
  int(): NumberToInteger<this, ZInteger>
}
interface HNumber extends HType<hs.HsNumber>, ZNumberCommon {
  int(): NumberToInteger<this, HInteger>
}
declare type HNumberOpts = HTypeOptsWithDefault<hs.HsNumber> & CustomNumberOpts
declare type CustomNumberOpts = Pick<
  tb.NumberOptions,
  'exclusiveMinimum' | 'exclusiveMaximum' | 'minimum' | 'maximum' | 'multipleOf'
>
declare type NumberToInteger<T, Int extends hs.HeapSchema> = T extends hs.HsOptional<ZNumber>
  ? hs.HsOptional<Int>
  : T extends hs.HsNonRequired<ZNumber>
  ? hs.HsNonRequired<Int>
  : Int
interface ZIntegerCommon extends ZNumericCommon {
  readonly type: 'integer'
}
interface ZInteger extends ZType<hs.HsInteger>, ZIntegerCommon {}
interface HInteger extends HType<hs.HsInteger>, ZIntegerCommon {}
interface ZStringCommon extends ZSmartUnionable {
  readonly type: 'string'
  readonly minLength?: number
  readonly maxLength?: number
  readonly format?: 'date-time' | 'email'
  readonly pattern?: string
  datetime(): this
  email(): this
  length(len: number): this
  max(maxLength: number): this
  min(minLength: number): this
  nonempty(): this
  regex(pattern: string): this
}
interface HString<S extends string = string> extends HType<hs.HsString<S>>, ZStringCommon {}
declare type HStringOpts<S extends string> = HTypeOptsWithDefault<hs.HsString<S>> & CustomStringOpts
declare type CustomStringOpts = Pick<
  tb.StringOptions<'date-time' | 'email'>,
  'format' | 'minLength' | 'maxLength' | 'pattern'
>
interface ZFunctionRouteRefCommon extends ZSmartUnionable {
  readonly type: 'array'
  readonly additionalItems: false
  readonly minItems: number
  readonly maxItems: number
  readonly body: hs.HeapSchema
  readonly result: hs.HeapSchema
}
interface HFunctionRouteRef<B, R> extends HType<hs.HsFunctionRouteRef<B, R>>, ZFunctionRouteRefCommon {
  readonly items: readonly [HNumber, HString, HString]
}
declare type HFunctionRouteRefOpts<B, R> = ZTypeOptsWithDefault<hs.HsFunctionRouteRef<B, R>>
interface HGenericLink extends HType<hs.HsGenericLink>, ZSmartUnionable {
  readonly type: 'array'
  readonly additionalItems: false
  readonly minItems: number
  readonly maxItems: number
  readonly items: readonly [HString, HString]
  readonly onDelete: hs.HsGenericLink['onDelete']
}
declare type HGenericLinkOpts = Partial<hs.HsLinkOptions>
interface ZJobRouteRefCommon extends ZSmartUnionable {
  readonly type: 'array'
  readonly additionalItems: false
  readonly minItems: number
  readonly maxItems: number
  readonly body: hs.HeapSchema
}
interface HJobRouteRef<B> extends HType<hs.HsJobRouteRef<B>>, ZJobRouteRefCommon {
  readonly items: readonly [HNumber, HString, HString]
}
declare type HJobRouteRefOpts<B> = ZTypeOptsWithDefault<hs.HsJobRouteRef<B>>
interface ZLiteralCommon<T extends tb.TValue> extends ZSmartUnionable {
  readonly type: 'string' | 'number' | 'boolean'
  readonly const: T
}
interface HLiteral<T extends tb.TValue> extends HType<hs.HsLiteral<T>>, ZLiteralCommon<T> {}
declare type HLiteralOpts = hs.HsSearchableOptions
interface ZMoneyCommon extends ZSmartUnionable {
  readonly type: 'array'
  readonly additionalItems: false
  readonly minItems: number
  readonly maxItems: number
}
interface HMoney extends HType<hs.HsMoney>, ZMoneyCommon {
  readonly items: readonly [HNumber, HCurrency]
}
declare type HMoneyOpts = HTypeOptsWithDefault<hs.HsMoney>
interface ZObjectCommon extends ZSmartUnionable {
  readonly type: 'object'
  readonly required?: string[]
  readonly additionalProperties?: boolean
}
interface HObject<HSP extends hs.HsProperties> extends HType<hs.HsObject<HSP>>, ZObjectCommon {
  readonly properties: HObjectProps<HSP>
}
declare type HObjectOpts<HSP extends hs.HsProperties> = HTypeOptsWithDefault<hs.HsObject<HSP>> & {
  additionalProperties?: boolean
}
declare type HObjectProps<HSP extends hs.HsProperties> = {
  [K in keyof HSP]: HType<HSP[K]>
}
interface ZRecordCommon extends ZSmartUnionable {
  readonly type: 'object'
  readonly additionalProperties: false
}
interface HRecord<KHS extends hs.HsRecordKey, VHS extends hs.HeapSchema>
  extends HType<hs.HsRecord<KHS, VHS>>,
    ZRecordCommon {
  readonly patternProperties: {
    [pattern: string]: HType<VHS>
  }
}
declare type HRecordOpts<KHS extends hs.HsRecordKey, VHS extends hs.HeapSchema> = HTypeOptsWithDefault<
  hs.HsRecord<KHS, VHS>
>
interface HRefLink<T extends object> extends HType<hs.HsRefLink<T>>, ZSmartUnionable {
  readonly type: 'string'
  readonly targetType: HeapObjectType | UgcSystemHeapTableName
  readonly targetRepoOrTableName?: ReadOnlyHeapTableRepo<hs.HsProperties, unknown, unknown> | string
  readonly isSystemTarget: boolean
  readonly onDelete: hs.HsGenericLink['onDelete']
}
declare type HRefLinkOpts = Partial<hs.HsLinkOptions>
interface ZStorageFileCommon extends ZSmartUnionable {
  readonly type: 'string'
}
interface HStorageFile extends ZType<hs.HsFile>, ZStorageFileCommon {}
declare type HStorageFileOpts = ZTypeOptsWithDefault<hs.HsFile>
interface HStorageImageFile extends ZType<hs.HsImageFile>, ZStorageFileCommon {}
interface HStorageVideoFile extends ZType<hs.HsVideoFile>, ZStorageFileCommon {}
interface HStorageAudioFile extends ZType<hs.HsAudioFile>, ZStorageFileCommon {}
interface ZTupleCommon extends ZSmartUnionable {
  readonly type: 'array'
  readonly additionalItems: false
  readonly minItems: number
  readonly maxItems: number
}
interface HTuple<IHS extends hs.HeapSchema[]> extends HType<hs.HsTuple<IHS>>, ZTupleCommon {
  readonly items: HTupleAlternatives<IHS>
}
declare type HTupleOpts<IHS extends hs.HeapSchema[]> = HTypeOptsWithDefault<hs.HsTuple<IHS>>
declare type HTupleAlternatives<IHS extends hs.HeapSchema[]> = {
  [K in keyof IHS]: HType<IHS[K]>
}
interface ZUndefinedCommon extends ZSmartUnionable {
  readonly type: 'undefined'
}
interface HUndefined extends ZType<hs.HsUndefined>, ZUndefinedCommon {}
declare type HUndefinedOpts = hs.HsCommonOptions
declare type HUnknown = HType<hs.HsUnknown>
declare type HUnknownOpts = HTypeOptsWithDefault<hs.HsUnknown>
interface TableSchemaBuilder {
  any<T = any>(options?: HAnyOpts<T>): HAny<T>
  array<IHS extends hs.HeapSchema>(items: IHS, options?: HArrayOpts<IHS>): HArray<IHS>
  array<IHS extends hs.HeapSchema>(items: ZType<IHS>, options?: HArrayOpts<IHS>): HArray<IHS>
  boolean(options?: HBooleanOpts): HBoolean
  currency(options?: HCurrencyOpts): HCurrency
  date(options?: HDateOpts): HDate
  enum<ET extends tb.TEnumType>(items: ET, options?: HEnumOpts<EnumTypeToSchema<ET>>): HEnum<EnumTypeToSchema<ET>>
  enum<T extends EnumValue, EV extends readonly [T, ...T[]]>(
    items: EV,
    opts?: HEnumOpts<tb.TEnumKey<EV[number]>[]>,
  ): HEnum<tb.TEnumKey<EV[number]>[]>
  genericLink(options?: HGenericLinkOpts): HGenericLink
  functionRouteRef<B extends hs.HeapSchema, R extends hs.HeapSchema>(
    bs: B,
    rs: R,
    options?: HFunctionRouteRefOpts<B['$hsRuntime'], R['$hsRuntime']>,
  ): HFunctionRouteRef<B['$hsRuntime'], R['$hsRuntime']>
  /** @deprecated use s.functionRouteRef instead */
  interAppCallRouteRef<B extends hs.HeapSchema, R extends hs.HeapSchema>(
    bs: B,
    rs: R,
    options?: HFunctionRouteRefOpts<B['$hsRuntime'], R['$hsRuntime']>,
  ): HFunctionRouteRef<B['$hsRuntime'], R['$hsRuntime']>
  jobRouteRef<B extends hs.HeapSchema>(bs: B, options?: HJobRouteRefOpts<B>): HJobRouteRef<B['$hsRuntime']>
  literal<T extends tb.TValue>(value: T, options?: HLiteralOpts): HLiteral<T>
  money(options?: HMoneyOpts): HMoney
  null(options?: HNullOpts): HNull
  nullable<HS extends hs.HeapSchema>(innerType: HType<HS>): hs.HsNonRequired<HSmartUnion<[HS, hs.HsNull]>>
  number(options?: HNumberOpts): HNumber
  object<HSP extends hs.HsProperties>(properties: hs.HsPropertiesNo$<HSP>, options?: HObjectOpts<HSP>): HObject<HSP>
  optional<Z extends HType<hs.HeapSchema>>(innerType: Z): hs.HsOptional<Z>
  record<KHS extends hs.HsRecordKey, VHS extends hs.HeapSchema>(
    key: KHS | HType<KHS>,
    value: VHS | HType<VHS>,
    options?: HRecordOpts<KHS, VHS>,
  ): HRecord<KHS, VHS>
  refLink<T extends Record<string, unknown>>(tableName: string, options?: HRefLinkOpts): HRefLink<T>
  refLink<HSP extends hs.HsProperties>(
    repo: UgcAnyHeapTableRepo<HSP>,
    options?: HRefLinkOpts,
  ): HRefLink<hs.HsRuntime<hs.HsObject<HSP & hs.HeapObjectBaseSchema>>>
  smartUnion<OHS extends UnionConstructorInput[]>(items: OHS, options?: HSmartUnionOpts<OHS>): HSmartUnion<OHS>
  storageFile(options?: HStorageFileOpts): HStorageFile
  storageImageFile(options?: HStorageFileOpts): HStorageImageFile
  storageVideoFile(options?: HStorageFileOpts): HStorageVideoFile
  storageAudioFile(options?: HStorageFileOpts): HStorageAudioFile
  string<S extends string = string>(options?: HStringOpts<S>): HString<S>
  tuple<IHS extends hs.HeapSchema[]>(items: [...IHS], options?: HTupleOpts<IHS>): HTuple<IHS>
  undefined(options?: HUndefinedOpts): HUndefined
  unknown(options?: HUnknownOpts): HUnknown
}
declare type UgcPluginAppVmInfo = Pick<UgcCtxPluginApp, 'appId' | 'appSlug' | 'directoryPath'> & {
  /** @deprecated use codeAccount.id */
  hostAccId: number
  /** @deprecated use codeAccount.name */
  hostAccName: string
  codeAccount: UgcCtxAccount
}
/**
 * Converts serialized heap schema back to HeapSchema
 */
export declare function deserializeHeapSchema(serialized: HsSerialized): hs.HeapSchema
declare class UgcRefLink<T extends object> extends BaseRefLink<T, RichUgcCtx> {
  protected prefetchValue: T | undefined
  /**
   * This method called by `prefetchFields` method. Allow to make batched prefetch values for
   * a bunch of reflink instances
   *
   * @param ctx
   * @param values
   */
  static prefetch(ctx: RichUgcCtx, values: Array<UgcRefLink<object>>): Promise<void>
  getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: RichUgcCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, RichUgcCtx>>
  get<R = T>(ctx: RichUgcCtx): Promise<R>
}
declare class UgcGenericLink extends BaseGenericLink<RichUgcCtx> {
  getTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
    ctx: RichUgcCtx,
  ): Promise<ReadOnlyHeapTableRepo<HSP, RichUgcCtx>>
}
export declare type GenericLinkInputJson = hs.GenericLinkInputJson
export declare type HsCreateInput<T extends hs.HeapSchema> = hs.HsCreateInput<T>
export declare type HsUpdateInput<T extends hs.HeapSchema> = hs.HsUpdateInput<T>
export declare type HsRuntime<T extends hs.HeapSchema> = hs.HsRuntime<T>
export declare type HsFilterInput<T extends hs.HeapSchema> = hs.HsFilterInput<T>
export declare type HsSchema = hs.HeapSchema
export declare const s: TableSchemaBuilder
/**
 * Common type for any heap table record (HeapObject)
 */
export declare type HeapObject = HeapObjectBaseRaw & {
  createdBy: UgcRefLink<User2> | null
  updatedBy: UgcRefLink<User2> | null
}
export declare const Heap: {
  /**
   * Main heap-table definition constructor.
   *
   * The third argument (host account ID) is provided (appended) by transpiler during build.
   * If it's not, that means edge case not covered by the transpiler and should be fixed.
   * @see tsHeapTablesTransformer
   * @see appendAccountIdToHeapTable
   */
  Table<HSP extends hs.HsProperties, X extends string>(
    tableName: UgcHeapTableName<X>,
    fields: hs.HsPropertiesNo$<HSP> | ((s: TableSchemaBuilder) => hs.HsPropertiesNo$<HSP>),
    tableOptions?: HeapTableOptions<HSP> | undefined,
  ): UgcHeapTableRepo<HSP>
  ReadOnlyTable<HSP_1 extends hs.HsProperties>(repo: UgcHeapTableRepo<HSP_1>): UgcReadOnlyHeapTableRepo<HSP_1>
  AppHostTable<HSP_2 extends hs.HsProperties>(repo: UgcHeapTableRepo<HSP_2>): UgcHeapTableRepo<HSP_2>
  GenericLink(options?: Partial<hs.HsLinkOptions>): hs.HsGenericLink
  RefLink: typeof RefLink
  UserRefLink(options?: hs.HsLinkOptions): hs.HsRefLink<UgcSmartUser>
  /** @deprecated use FunctionRouteRef instead */
  InterAppCallRouteRef<B extends hs.HeapSchema, R extends hs.HeapSchema>(
    bs: B,
    rs: R,
    options?: hs.HsCommonOptions,
  ): hs.HsFunctionRouteRef<hs.HsRuntime<B>, hs.HsRuntime<R>>
  Any<T = any>(options?: hs.HsOptionsWithDefault<T> | undefined): hs.HsAny<T>
  Array<T_1 extends hs.HeapSchema>(items: T_1, options?: hs.HsArrayOptions<T_1> | undefined): hs.HsArray<T_1>
  Boolean(options?: hs.HsOptionsWithDefault<boolean> | undefined): hs.HsBoolean
  DateTime(options?: hs.HsDateTimeOptions | undefined): hs.HsDateTime
  Enum<T_2 extends tb.TEnumType>(
    item: T_2,
    options?: hs.HsOptionsWithDefault<T_2[keyof T_2]> | undefined,
  ): hs.HsEnum<tb.TEnumKey<T_2[keyof T_2]>[]>
  File(options?: hs.HsCommonOptions | undefined): hs.HsFile
  ImageFile(options?: hs.HsCommonOptions | undefined): hs.HsImageFile
  VideoFile(options?: hs.HsCommonOptions | undefined): hs.HsVideoFile
  AudioFile(options?: hs.HsCommonOptions | undefined): hs.HsAudioFile
  Integer(options?: hs.HsNumberOptions | undefined): hs.HsInteger
  FunctionRouteRef<B_1 extends hs.HeapSchema, R_1 extends hs.HeapSchema>(
    bs: B_1,
    rs: R_1,
    options?: hs.HsCommonOptions | undefined,
  ): hs.HsFunctionRouteRef<hs.HsRuntime<B_1>, hs.HsRuntime<R_1>>
  Intersect<T_3 extends hs.HsIntersectable[]>(
    items: [...T_3],
    options?: hs.HsIntersectOptions<T_3> | undefined,
  ): hs.HsIntersect<T_3>
  JobRouteRef<B_2 extends hs.HeapSchema>(
    bs: B_2,
    options?: hs.HsCommonOptions | undefined,
  ): hs.HsJobRouteRef<hs.HsRuntime<B_2>>
  KeyOf<T_4 extends hs.HsObject<hs.HsProperties>>(
    object: T_4,
    options?: hs.HsOptionsWithDefault<hs.SelectablePropertyKeys<T_4>> | undefined,
  ): hs.HsKeyOf<hs.SelectablePropertyKeys<T_4>[]>
  Literal<T_5 extends tb.TValue>(value: T_5, options?: hs.HsSearchableOptions | undefined): hs.HsLiteral<T_5>
  Money(options?: hs.HsMoneyOptions | undefined): hs.HsMoney
  NonRequired<T_6 extends hs.HeapSchema>(item: T_6, dflt: tb.Static<T_6>): hs.HsNonRequired<T_6>
  Null(options?: hs.HsCommonOptions | undefined): hs.HsNull
  Number(options?: hs.HsNumberOptions | undefined): hs.HsNumber
  Object<T_7 extends hs.HsProperties>(
    properties: hs.HsPropertiesNo$<T_7>,
    options?: hs.HsObjectOptions<T_7> | undefined,
  ): hs.HsObject<T_7>
  Omit<T_8 extends hs.HsObject<hs.HsProperties>, K extends hs.SelectablePropertyKeys<T_8>[]>(
    object: T_8,
    keys: [...K],
    options?: hs.HsOptionsWithDefault<Omit<hs.SelectableProperties<T_8>, K[number]>> | undefined,
  ): hs.HsObject<Omit<hs.SelectableProperties<T_8>, K[number]>>
  Optional<T_9 extends hs.HeapSchema>(item: T_9): hs.HsOptional<T_9>
  Partial<T_10 extends hs.HsObject<hs.HsProperties>>(
    object: T_10,
    options?: hs.HsOptionsWithDefault<tb.StaticObject<hs.StaticPartial<T_10['properties']>>> | undefined,
  ): hs.HsObject<hs.StaticPartial<T_10['properties']>>
  Pick<T_11 extends hs.HsObject<hs.HsProperties>, K_1 extends hs.SelectablePropertyKeys<T_11>[]>(
    object: T_11,
    keys: [...K_1],
    options?: hs.HsOptionsWithDefault<Pick<hs.SelectableProperties<T_11>, K_1[number]>> | undefined,
  ): hs.HsObject<Pick<hs.SelectableProperties<T_11>, K_1[number]>>
  Record<K_2 extends hs.HsRecordKey, T_12 extends hs.HeapSchema>(
    key: K_2,
    value: T_12,
    options?: hs.HsOptionsWithDefault<tb.StaticRecord<K_2, T_12>> | undefined,
  ): hs.HsRecord<K_2, T_12>
  RegEx(regex: RegExp, options?: hs.HsOptionsWithDefault<string> | undefined): hs.HsString<string>
  Required<T_13 extends hs.HsObject<hs.HsProperties>>(
    object: T_13,
    options?: hs.HsOptionsWithDefault<tb.StaticObject<hs.StaticRequired<T_13['properties']>>> | undefined,
  ): hs.HsObject<hs.StaticRequired<T_13['properties']>>
  String<S extends string = string>(options?: hs.HsStringOptions | undefined): hs.HsString<S>
  Tuple<T_14 extends hs.HeapSchema[]>(
    items: [...T_14],
    options?: hs.HsOptionsWithDefault<tb.StaticTuple<T_14>> | undefined,
  ): hs.HsTuple<T_14>
  Undefined(options?: hs.HsCommonOptions | undefined): hs.HsUndefined
  Union<T_15 extends UnionConstructorInput[]>(
    items: [...T_15],
    options?: hs.HsOptionsWithDefault<tb.StaticUnion<T_15>> | undefined,
  ): hs.HsUnion<T_15>
  Unknown(options?: hs.HsOptionsWithDefault<unknown> | undefined): hs.HsUnknown
  Nullable<T_16 extends UnionConstructorInput>(type: T_16): hs.HsNonRequired<hs.HsUnion<[T_16, hs.HsNull]>>
  NonEmptyString(
    options?: (Pick<tb.StringOptions<never>, 'maxLength'> & hs.HsOptionsWithDefault<string>) | undefined,
  ): hs.HsString<string>
  Currency(options?: hs.HsOptionsWithDefault<import('core/heap/v2/Money').Currency> | undefined): hs.HsString<string>
}
declare function RefLink<T extends Record<string, unknown>>(
  tableName: string,
  options?: Partial<hs.HsLinkOptions>,
): hs.HsRefLink<T>
declare function RefLink<T extends hs.HsProperties>(
  repo: UgcAnyHeapTableRepo<T>,
  options?: Partial<hs.HsLinkOptions>,
): hs.HsRefLink<HsRuntime<hs.HsObject<T & hs.HeapObjectBaseSchema>>>
export declare type HeapTableRepo<HSP extends hs.HsProperties = hs.HsProperties> = UgcHeapTableRepo<HSP>
declare const tbKinds: {
  readonly AnyKind: typeof tb.AnyKind
  readonly ArrayKind: typeof tb.ArrayKind
  readonly BooleanKind: typeof tb.BooleanKind
  readonly EnumKind: typeof tb.EnumKind
  readonly IntegerKind: typeof tb.IntegerKind
  readonly IntersectKind: typeof tb.IntersectKind
  readonly KeyOfKind: typeof tb.KeyOfKind
  readonly LiteralKind: typeof tb.LiteralKind
  readonly NullKind: typeof tb.NullKind
  readonly NumberKind: typeof tb.NumberKind
  readonly ObjectKind: typeof tb.ObjectKind
  readonly RecordKind: typeof tb.RecordKind
  readonly StringKind: typeof tb.StringKind
  readonly TupleKind: typeof tb.TupleKind
  readonly UndefinedKind: typeof tb.UndefinedKind
  readonly UnknownKind: typeof tb.UnknownKind
  readonly UnionKind: typeof tb.UnionKind
}
/**
 * Schema-related types and symbols to help in introspection of table schema
 */
export declare const schema: typeof hs & typeof tbKinds
export declare function getRefLinkTargetTableRepo<HSP extends hs.HsProperties = hs.HsProperties>(
  ctx: RichUgcCtx,
  schema: hs.HsRefLink<AnyObject>,
): Promise<ReadOnlyHeapTableRepo<HSP, RichUgcCtx>>
export declare function getAccountTablesInfo(
  ctx: RichUgcCtx,
  options?: {
    loadFrom?: UgcFileStorage
  },
): Promise<UgcHeapRegistryLocalTable[]>
export declare function getAccountTableByName<HSP extends hs.HsProperties = hs.HsProperties>(
  ctx: RichUgcCtx,
  tableName: string,
  options?: {
    loadFrom?: UgcFileStorage
  },
): Promise<UgcHeapTableRepo<HSP>>
export declare function createOrUpdateAccountTableFile<HSP extends hs.HsProperties>(
  ctx: RichUgcCtx,
  filePath: string,
  props: {
    tableName: string
    schema: hs.HsObject<HSP>
    customMeta?: AnyObject
  },
): Promise<void>
/**
 * Starts SERIALIZABLE transaction and injects the transaction ID into the given ctx and passes it to the callback
 *  so all heap operations inside the callback using that ctx will be performed inside the transaction.
 * The transaction is committed after the given callback is run and "awaited"
 *
 * This function-cretated transaction works only for CALLING-ACCOUNT-HOSTED tables
 */
export declare function serializableTransaction<T>(ctx: RichUgcCtx, fn: (ctx: RichUgcCtx) => Promise<T>): Promise<T>
/**
 * Starts SERIALIZABLE transaction and injects the transaction ID into the given ctx and passes it to the callback
 *  so all heap operations inside the callback using that ctx will be performed inside the transaction.
 * The transaction is committed after the given callback is run and "awaited"
 *
 * This function-cretated transaction works only for APP-ACCOUNT-HOSTED tables
 */
export declare function appHostSerializableTransaction<T>(
  ctx: RichUgcCtx,
  fn: (ctx: RichUgcCtx) => Promise<T>,
): Promise<T>
/**
 * WARNING: this probably will never be exposed to public, but leaving here for a while
 *          if we'll decide to provide two different transaction isolation level APIs
 *
 * Starts READ COMMITTED transaction and injects the transaction ID into the given ctx and passes it to the callback
 *  so all heap operations inside the callback using that ctx will be performed inside the transaction.
 * The transaction is committed after the given callback is run and "awaited"
 */
export declare function batchTransaction<T>(ctx: RichUgcCtx, fn: (ctx: RichUgcCtx) => Promise<T>): Promise<T>
export declare function prefetchFields<T>(ctx: RichUgcCtx, records: Array<T>, fields: Array<keyof T>): Promise<void>
export { Currency, Money, MoneyJson } from 'core/heap/v2/Money'

export {
  HeapOrderBy as HeapTableOrder,
  HsFilter as HeapTableWhere,
  UgcGenericLink as GenericLink,
  UgcRefLink as RefLink,
}

export {}
